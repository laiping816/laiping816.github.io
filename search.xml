<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>树形结构</title>
      <link href="/2019/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84/"/>
      <url>/2019/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p>二分搜索树（集合、映射）、堆、线段树、并查集、哈希表、未完待续更新</p></blockquote><p><img src="/2019/04/05/数据结构/树形结构/time.jpg" alt=""></p><a id="more"></a><h1 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h1><ul><li>树<ul><li>二分搜索树</li><li>平衡二叉树：AVL；红黑树</li><li>堆；并查集</li><li>线段树；Trie（字典树，前缀树）</li></ul></li></ul><h2 id="二分搜索树"><a href="#二分搜索树" class="headerlink" title="二分搜索树"></a>二分搜索树</h2><p>动态数据结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    E e;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>特点</p><ul><li>每个节点的值 &gt; 其左子树<strong>所有</strong>节点值，&lt; 右子树</li><li>每棵子树也是二分搜索树</li><li>自定义类，必须提供比较规则</li></ul></li><li><p>遍历：O(n)</p><ul><li><p>深度优先遍历（一扎到底）</p><ul><li>前序（<code>node</code>,  <code>node.left</code>,  <code>node.right</code>）<ul><li>一般只是想遍历执行操作（或输出结果）可选用先序遍历</li></ul></li><li>中序（<code>node.left</code>,  <code>node</code>,  <code>node.right</code>）<ul><li>符合从小到大（或从大到小）顺序的，故要遍历输出<strong>排序</strong>好的结果需要使用中序遍历</li></ul></li><li>后续（<code>node.left</code>,  <code>node.right</code>, <code>node</code>）<ul><li>肯定已经遍历过该节点的左右子节点，故适用于要进行破坏性操作的情况，比如删除所有节点</li></ul></li></ul></li><li><p>广度优先遍历（更快找到问题的解 - 最短路径）</p><ul><li>层序</li></ul></li></ul></li></ul><h2 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合(Set)"></a>集合(Set)</h2><p>元素不重复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Interface Set&lt;E&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E)</span></span>; <span class="comment">//不能添加重复元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(E)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>实现方式</p><ul><li><p>二分搜索树（有序）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTSet</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p>h（层数1.2.3…）对应有<code>2^(h - 1)</code>个结点。满二叉树结点数<code>n = 2^h - 1</code></p><p>h = log(n + 1)</p><ul><li>增删查的复杂度：O(h) = O(logn)</li></ul></li><li><p>链表（无序）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>复杂度O(n)效率低</li><li>基于哈希表效率高</li></ul></li></ul></li></ul><blockquote><p>当h = n时，二分搜索树即退化成链表。</p><p>解决方法：平衡二叉树</p></blockquote><h2 id="映射-Map"><a href="#映射-Map" class="headerlink" title="映射(Map)"></a>映射(Map)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">remove</span><span class="params">(K key)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K key)</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(K key)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度<ul><li>链表<ul><li>增删改查O(n)</li></ul></li><li>二分搜索树 <ul><li>增删改查O(h)  = O(logn)</li></ul></li></ul></li></ul><blockquote><p>集合，完全可以通过映射实现，只要把value置为null即可</p></blockquote><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><ul><li><p>实现</p><ul><li>普通线性结构   <ul><li>入队：O（1）</li><li>出队：O（n）</li></ul></li><li><p>顺序线性结构</p><ul><li>入队：O（n）</li><li>出队：O（1）</li></ul></li><li><p>堆</p><ul><li>入队：O（logn）</li><li>出队：O（logn）</li></ul></li></ul></li></ul><h3 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h3><ul><li><p>特点</p><ul><li>完全二叉树（区别满二叉树）：最后层上面一层一定是满的，最后1层叶子结点一定在最左边</li><li>堆中某个节点的值总是 &lt;= 其父节点的值 （最大堆）</li></ul></li><li><p>存储结构</p><ul><li><p>树(略)</p></li><li><p>数组</p><p><strong>注意</strong>：为了后面求<code>parent</code>和<code>child</code>数组0号位置空出</p></li></ul><p><img src="/2019/04/05/数据结构/树形结构/二叉堆.png" alt=""></p><p>保留第一个位置：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%转换只要把原来的i地方用i+1替换最后减个1就行</span></span><br><span class="line">parent(<span class="built_in">i</span>) = (<span class="built_in">i</span>+<span class="number">1</span>)/<span class="number">2</span> - <span class="number">1</span> = (<span class="built_in">i</span><span class="number">-1</span>)/<span class="number">2</span></span><br><span class="line">left child(<span class="built_in">i</span>) = <span class="number">2</span>*(<span class="built_in">i</span>+<span class="number">1</span>) - <span class="number">1</span> = <span class="number">2</span>*<span class="built_in">i</span>+<span class="number">1</span>;</span><br><span class="line">right child(<span class="built_in">i</span>) = <span class="number">2</span>*(<span class="built_in">i</span>+<span class="number">1</span>)+<span class="number">1</span> - <span class="number">1</span> = <span class="number">2</span>*<span class="built_in">i</span>+<span class="number">2</span>;</span><br></pre></td></tr></table></figure></li></ul><p>  <img src="/2019/04/05/数据结构/树形结构/二叉堆2.png" alt=""></p><ul><li><p>操作堆</p><ul><li><p>添加(<code>Sift Up</code>堆特有称谓)</p><ul><li>先加在数组最后面</li><li>然后跟父亲比较，一层层比上去直到根节点或者小于等于其父节点</li></ul></li><li><p>取出堆中最大元素(<code>Sift Down</code>)</p><p><img src="/2019/04/05/数据结构/树形结构/siftdown.gif" alt=""></p></li><li><p>replace(取出最大并替换)</p></li><li><p>heapify(将任意数组整理成堆的形状)</p><ul><li><p>O(n)</p></li><li><p><strong>关键</strong>：找到最后1个非叶子结点，一直上去到根一直做下沉操作</p><ul><li>定位最后1个非叶子结点，就是最后1个节点的父节点</li></ul></li></ul></li></ul></li></ul><h3 id="索引堆"><a href="#索引堆" class="headerlink" title="索引堆"></a>索引堆</h3><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><ul><li><p>引入</p><ul><li>区间染色</li><li>区间查询</li></ul><p>对于给定区间</p><p>更新：更新区间中的一个元素或者一个区间的值</p><p>查询：一个区间[i, j]的最大值，最小值，或者区间数字和</p></li><li><p>特点</p><ul><li>平衡二叉树（最大和最小深度差距1）</li></ul></li></ul><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>Union Find</p><ul><li><p>复杂度：O(log*n)     近乎是O(1)</p><script type="math/tex; mode=display">\log * n=\left\{\begin{array}{cc}{0} & {\text { if }(n \leq 1)} \\ {1+\log *(\log n)} & {\text { if }(n>1)}\end{array}\right.</script></li><li><p>场景</p><ul><li>处理连接问题Connectivity Problem</li><li>路径问题</li><li>集合并集</li></ul></li><li><p>特点</p><ul><li>孩子指向父亲</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通常还需要一个find方法来确定，当前元素p所对应的集合</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li><p>用数组，查O(1)，但是合并O(n)</p><p><img src="/2019/04/05/数据结构/树形结构/union.png" alt=""></p></li><li><p>树形，查O(logn)，合并O(logn)</p><p><img src="/2019/04/05/数据结构/树形结构/树状union.png" alt=""></p></li></ul><h3 id="路径优化"><a href="#路径优化" class="headerlink" title="路径优化"></a>路径优化</h3><ul><li><p>基于size优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入sz数组</span></span><br><span class="line"><span class="keyword">int</span>[] sz;  <span class="comment">//sz[i]表示以i为根的集合中元素个数</span></span><br><span class="line"><span class="comment">//每次union根据对应集合的size，少的指向多的</span></span><br></pre></td></tr></table></figure></li><li><p>基于rank优化(更合理)</p><p>基于size，在如下情况就不适用</p></li></ul><p><img src="/2019/04/05/数据结构/树形结构/size优化问题.png" alt=""></p><ul><li><p>路径压缩(多调用几次也能达到最优效果)</p><p>发生在find方法过程</p><p><img src="/2019/04/05/数据结构/树形结构/路径压缩.png" alt=""></p><p>基于性能考虑不维护rank，但rank仍可作为参考</p></li><li><p>最大化路径压缩(递归耗费性能，并非最优)</p></li></ul><p><img src="/2019/04/05/数据结构/树形结构/路径压缩最大.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//借助递归实现，一归到底，逐级return保证parent[i] = 根</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (p &lt; <span class="number">0</span> || p &gt;= parent.length)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"p out of bound"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (p != parent[p])</span><br><span class="line">    parent[p] = find(parent[p]);</span><br><span class="line">  <span class="keyword">return</span> parent[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哈希表-散列表"><a href="#哈希表-散列表" class="headerlink" title="哈希表(散列表)"></a>哈希表(散列表)</h2><ul><li><p>经典设计思想：空间换时间</p></li><li><p>什么是哈希表？</p><ul><li><p>例子</p><p>​    例如单词（只含小写字母）字母频率统计，<code>int[26] freq</code> 就是一个哈希表。每一个字符都和一个索引相对应</p></li><li><p>哈希函数 (“键”转换为”索引”)</p><ul><li><p><code>ch - &#39;a&#39;</code></p><p>字符转换为索引的函数 </p></li></ul></li><li><p>哈希冲突</p><p><img src="/2019/04/05/数据结构/树形结构/哈希冲突.png" alt=""></p></li></ul></li></ul><h3 id="哈希函数设计"><a href="#哈希函数设计" class="headerlink" title="哈希函数设计"></a>哈希函数设计</h3><ul><li><p>原则</p><p>“键”转换为”索引”</p><ul><li>一致性：if a = b 则hash(a)  =  hash(b)也一定相等</li><li>高效性：计算高效简便</li><li>均匀性：哈希值均匀分布</li></ul></li><li><p>对象</p><ul><li><p>大整数</p><ul><li>%M，模一个素数(数论相关)，素数选择上网查，该素数即哈希表大小</li></ul></li><li><p>浮点数</p><ul><li>内存空间当做int、long来处理转换为大整数的问题</li></ul></li><li><p>字符串</p><ul><li>看做是1个B(base用户可选，如全是小写字母，就为26)进制的大整形</li></ul><p><img src="/2019/04/05/数据结构/树形结构/字符串转哈希.png" alt=""></p></li><li><p>符合类型</p><ul><li>可以套用字符串的处理方法，每个字符可以对应一个字段，Java中进制B取了31。</li></ul></li></ul></li><li><p>Java中的hashCode</p><blockquote><p>注意：hashCode只是把”键”转化成了一个整型值，具体要转换为”索引”，还需要%M，这个需要在自己设计的哈希表的类中内部逻辑来完成</p></blockquote></li></ul><h3 id="哈希冲突处理"><a href="#哈希冲突处理" class="headerlink" title="哈希冲突处理"></a>哈希冲突处理</h3><ul><li><p>链地址法(Seperate Chaining)</p><ul><li>保证hashCode为正数 &amp;0x7fffffff，取模</li></ul><p><img src="/2019/04/05/数据结构/树形结构/链地址法.png" alt=""></p><ul><li>每一个索引存储的查找表，用树替代</li></ul><p><img src="/2019/04/05/数据结构/树形结构/哈希表最终设计.png" alt=""></p><blockquote><p><strong>注意</strong>：转成红黑树也是有条件的，如果Key不具有可比较性那不能转</p></blockquote></li><li><p>开放地址法</p><ul><li>线性探测：效率低</li><li>平方探测：1+4+9+16…</li><li>二次哈希</li></ul></li><li>再哈希法</li><li>Coalesced Hashing：综合链地址法和开放地址发</li></ul><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>平均复杂度</p><p>总共M个地址，如果放入哈希表的元素为N，哈希碰撞导致平均复杂度如下</p><ul><li>链表：O(N/M)</li><li>平衡树：O(log(N/M))</li></ul></li><li><p>优化 趋于均摊复杂 O(1)</p><ul><li><p>动态空间处理</p><ul><li>平均每个地址承载的元素多过一定程度，即扩容 <code>N / M &gt;= upperTol</code></li><li>平均每个个地址…少…，缩容<code>N / M &lt; lowerTol</code></li></ul></li><li><p>容量变换后M可能不是素数</p><ul><li>构建素数数组，通过索引增加来改变M大小</li></ul></li></ul></li></ul><h2 id="未完待续更新"><a href="#未完待续更新" class="headerlink" title="未完待续更新"></a>未完待续更新</h2>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 非线性 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>排序算法</title>
      <link href="/2019/03/24/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/03/24/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p>冒泡、选择、插入、希尔、归并、快速、堆</p></blockquote><p><img src="/2019/03/24/算法/排序/排序分类.png"></p><a id="more"></a><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><ul><li><p><a href="https://www.geeksforgeeks.org/" target="_blank" rel="noopener">GeeksForGeeks</a>网站用于学习相应的原理以及编码</p></li><li><p><a href="https://visualgo.net/zh" target="_blank" rel="noopener">Visualgo</a>网站可以查看各种排序算法的动图，容易加深理解</p></li></ul><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ul><li>复杂度：O(n^2)</li><li><p>每次确定最大的</p></li><li><p>步骤:</p><ol><li>第一个元素起，向后一个个挨着比较下去，大于则交换，一直到最后1个元素(确定了最大的)</li><li>还是从第一个起，向后…一直到倒数第2个(确定了第2大的)</li><li>一直重复…直到确定了第n-1最大的，则留下的第一个元素即为最小</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">        swap(arr, j, j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ul><li><p>复杂度：O(n^2)</p></li><li><p>每次确定最小的</p></li><li><p>步骤：</p><ol><li>第一个元素起，向后找一直找到末尾，确定比它小的最小的元素交换(确定了第小的)</li><li>第二个元素其，向后..(确定了第2小的)</li><li>一直重复，直到确定了第n-1小的，则留下的最后一个元素即为最大</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> minIndex = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n ; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">        minIndex = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, i, minIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><ul><li>复杂度：O(n^2)，最优时退化成O(n)</li><li><p>每次确定前n个有序</p></li><li><p>步骤</p><ol><li>从第1个开始一个个遍历下去</li><li>每次让当前索引指到的元素向前面的有序数组进行插入</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j - <span class="number">1</span>]; j--) &#123;   </span><br><span class="line">      swap(arr, j, j-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//问题：每次一碰到小，就一直换（3步）直到不再小</span></span><br><span class="line"><span class="comment">//改进(更符合人的思维模式的插入)</span></span><br><span class="line"><span class="comment">//1.每次碰到小了不交换，只把要换的数后移1位</span></span><br><span class="line"><span class="comment">//2.遇到不再小时，把当前次循环要处理的值移到当前位置后1位置。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j-<span class="number">1</span>] &gt; temp; j--) &#123;</span><br><span class="line">      arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li><p>由于break的存在，在对几乎已经排好序的数据操作时，效率高，即可以达到<strong>O(n)</strong>效率。</p></li><li><p>在数据量小的时候，可以考虑用插入，不一定要选择归并和快速。</p></li></ul><hr><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><ul><li><p>复杂度O(n^(1.3—2))</p></li><li><p>基于插入排序对有序效率高特点进行优化，分组实现尽可能最大化有序，各组仍用插入，并慢慢加大组内元素规模同时减少组</p></li><li><p>步骤</p><p>具体参考<a href="https://blog.csdn.net/qq_39207948/article/details/80006224" target="_blank" rel="noopener">图解希尔排序</a></p><p>其他具体关注公众号：趣谈编程</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> gap = n/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap/=<span class="number">2</span>) </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; n; i++) &#123;</span><br><span class="line">      insertI(arr, gap, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertI</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> gap, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> inserted = arr[i];</span><br><span class="line">  <span class="keyword">int</span> j;</span><br><span class="line">  <span class="keyword">for</span> (j = i; j &gt;= gap &amp;&amp; inserted &lt; arr[j - gap]; j -= gap)</span><br><span class="line">    arr[j] = arr[j - gap];</span><br><span class="line">  arr[j] = inserted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>分组+插入，使得对较大规模并且无序的数据也非常有效</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ul><li><p>O(nlogn)</p></li><li><p>思想：分治思想，分治(普通二分递归到底)，合(重点，双指针合)</p></li></ul><p><img src="/2019/03/24/算法/排序/归并.jpg" alt=""></p><ul><li><p>步骤</p><p><a href="https://mp.weixin.qq.com/s/YNF-6vY5m2Q_kEXJbep5NQ" target="_blank" rel="noopener">图解归并</a></p><p><strong>关键</strong>：合并2个有序数组</p></li></ul><p><img src="/2019/03/24/算法/排序/双指针合并.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  _mergeSort(arr, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">_mergeSort</span><span class="params">(<span class="keyword">int</span>[]arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r) </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">//该步可选择，再数据规模小于一定程度的时候选择使用归并排序</span></span><br><span class="line"><span class="comment">//if (r - l &lt;= 15) </span></span><br><span class="line"><span class="comment">//  return insertionSort(arr, l, r);</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> mid = (r + l) / <span class="number">2</span>;</span><br><span class="line">  _mergeSort(arr, l, mid);</span><br><span class="line">  _mergeSort(arr, mid+<span class="number">1</span>, r);</span><br><span class="line">  <span class="keyword">if</span> (arr[mid] &gt; arr[mid + <span class="number">1</span>])</span><br><span class="line">    _merge(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">_merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">    temp[i] = arr[l + i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> lp = l, rp = mid + <span class="number">1</span>;<span class="comment">//lp, rp代表左右数组指针</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (rp &gt; r) </span><br><span class="line">      arr[i] = temp[-l + lp++];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (lp &gt; mid)</span><br><span class="line">      arr[i] = temp[-l + rp++];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (temp[lp - l] &lt; temp[rp - l]) </span><br><span class="line">      arr[i] = temp[-l + lp++];</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      arr[i] = temp[-l + rp++];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><ul><li><p>逆序对(衡量数组的有序程度)</p><ul><li><p>暴力解法：考察数组中每一个数对，复杂度O(n^2)</p></li><li><p>使用归并</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只需要在merge操作的时，右指针数大于左指针数时，增加逆序对个数 </span></span><br><span class="line">reverseCount += (mid - i + <span class="number">1</span>); <span class="comment">//算逆序对</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul><li><p>O(nlogn)</p></li><li><p>思想：分治思想，分(重点，根据第一个元素划分区域)，合(递归返回合上去)</p></li><li><p>步骤</p><p><strong>关键</strong>：划分区域</p><p><img src="/2019/03/24/算法/排序/partition.png" alt=""></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  _quickSort(arr, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">_quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> p = _partition(arr, l, r);</span><br><span class="line">  _quickSort(arr, l, p - <span class="number">1</span>);</span><br><span class="line">  _quickSort(arr, p + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">_partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> j = l, v = arr[l];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; v) </span><br><span class="line">      swap(arr, ++j, i);</span><br><span class="line">  &#125;</span><br><span class="line">  swap(arr, l, j);</span><br><span class="line">  <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>优化</p><ul><li><p>随机化(普通和较大程度有序均可)</p><p>当排序数组在较大程度上有序的情况下</p><p><img src="/2019/03/24/算法/排序/退化.png" alt=""></p><p>分区域后树就不平衡，最差情况退化成线性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">_partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//随机化第一个数,此时退化成线性可能性及其低</span></span><br><span class="line">  <span class="keyword">int</span> random = <span class="keyword">new</span> Random().nextInt(r - l + <span class="number">1</span>) + l;</span><br><span class="line">  swap(arr, l, random);</span><br><span class="line">  <span class="keyword">int</span> j = l, v = arr[l];</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>双路</p><p>​    有大量重复数字，此时因为与分界点v相同值的点有大量，按照上面的方法，都是让等于v归于左边要么右边。又会导致数及其不平衡</p></li><li><p>三路 (一般有大量重复使用)</p><p>​    针对上面大量重复数字，此法最好</p><p><img src="/2019/03/24/算法/排序/3路.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">_partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//随机化第一个数,此时退化成线性可能性及其低</span></span><br><span class="line">  <span class="keyword">int</span> random = <span class="keyword">new</span> Random().nextInt(r - l + <span class="number">1</span>) + l;</span><br><span class="line">  swap(arr, l, random);</span><br><span class="line">  <span class="keyword">int</span> v = arr[l];</span><br><span class="line">  <span class="keyword">int</span> lt = l, gt = r + <span class="number">1</span>; </span><br><span class="line">  <span class="comment">//for (int i = l + 1; i &lt;= r; i++) &#123;</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="keyword">int</span> i &lt; gt) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; v)</span><br><span class="line">      swap(arr, i++, ++lt);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] == v)</span><br><span class="line">      i++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      swap(arr, i, --gt);</span><br><span class="line">  &#125;</span><br><span class="line">  swap(arr, l, lt);</span><br><span class="line">  此时需要<span class="keyword">return</span> lt-<span class="number">1</span>和gt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_quickSort(arr, l, lt-<span class="number">1</span>);</span><br><span class="line">_quickSort(arr, gt, r);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h3><ul><li><p>取数组中第n大的元素(100万个数里第100大的元素)</p><ul><li><p>排序O(nlogn)</p></li><li><p>快速排序：O(n)</p><ul><li><p>n + n/2 + n/4 + n/8 + … + 1 = O(2n);</p></li><li><p>每次确定的数都是最后在数组中的位置，根据该位置选择左区域还是右区域</p></li></ul></li></ul></li></ul><hr><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ul><li><p>O(nlogn)</p></li><li><p>思想：</p><ul><li><p>法1(耗费空间)</p><ul><li><p>构建二叉最小堆，<strong>sift up</strong>和<strong>sift down</strong>操作来添加和取出元素</p></li><li><p>把一个数组转换成二叉堆</p><ul><li><p>不用1个个添加到空堆，此时要O(nlogn)时间</p></li><li><p><strong>heapify</strong>:O(n) 更好</p><ol><li><p>找到最后1个非叶子结点，一直上去到根一直做下沉操作</p></li><li><p>定位最后1个非叶子结点，就是最后1个节点的父节点</p></li></ol></li></ul></li></ul></li><li><p>法2(原地排序)</p><ul><li>首先进行1次heapify，构建1个最大堆(n个元素)</li><li>把第一个元素和最后1个进行交换，做shiftdown操作，从而再次保证最大堆(n-1个元素)</li><li>一直重复第2步直到最后只剩下1个元素位置</li></ul></li></ul></li><li><p>步骤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = (n - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    _shiftDown(arr, n, i);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    swap(arr, <span class="number">0</span>, i);</span><br><span class="line">    _shiftDown(arr, i, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">_shiftDown</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">2</span> * k + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (j + <span class="number">1</span> &lt; n &amp;&amp; arr[j + <span class="number">1</span>] &gt; arr[j])</span><br><span class="line">      j += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[k] &gt;= arr[j])</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    swap(arr, k, j);</span><br><span class="line">    k = j;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h3><ul><li><p>堆这种数据结构，不仅仅在排序中有用，更能处理优先队列问题。</p></li><li><p>处理100W个数据求前100个数据，复杂度O(nlogm)</p></li></ul><h1 id="排序对比"><a href="#排序对比" class="headerlink" title="排序对比"></a>排序对比</h1><p><img src="/2019/03/24/算法/排序/排序小对比.png" alt=""></p><ul><li><p>稳定性</p><p>对于相等的元素，在排序后，原来靠前的元素依然靠前。相等元素的相对位置没有发生变化</p><ul><li><p>意义</p><p>比如学生成绩单对象有很多字段(姓名，各科成绩…..)，初始是按照学生名字字典序排序，现在希望通过某科成绩排序，但学生姓名字典序仍不变</p></li></ul></li><li><p>解决不稳定的问题</p><ul><li><p>通过自定义比较函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加比较条件</span></span><br><span class="line"><span class="function">bool <span class="title">compareTo</span><span class="params">(Student s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> score != s.score ?</span><br><span class="line">    score &gt; s.score :</span><br><span class="line">    name &lt; s.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>​                                        <strong>未完待续……</strong></p><p><img src="/2019/03/24/算法/排序/总结图.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线性数据结构</title>
      <link href="/2019/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2019/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p>时间复杂度、数组、栈、队列、链表</p></blockquote><p><img src="https://image-link.nos-eastchina1.126.net/linearDS"></p><a id="more"></a><h1 id="复杂度介绍"><a href="#复杂度介绍" class="headerlink" title="复杂度介绍"></a>复杂度介绍</h1><ul><li><p>衡量代码好坏指标</p><ul><li>运行时间（时间复杂度）</li><li>占用空间（空间复杂度）</li></ul></li><li><p>时间复杂度</p><p>由于运行环境和输入规模的影响，代码绝对时间无法估计，但可预估代码的基本操作<strong>执行次数</strong></p><p>计算得出T(n) = ….表达式</p><ul><li><p>渐进时间复杂度</p><p>当n趋于 ∞ 的时候得到的极值</p><ul><li>运行时间为常数量级，O （1）</li><li>只保留时间函数中最高阶项，且省去最高阶前系数</li><li>常见有O（1）&lt; O（logn）&lt; O（n）&lt; O（n^2）</li></ul></li></ul></li></ul><h1 id="线性数据结构"><a href="#线性数据结构" class="headerlink" title="线性数据结构"></a>线性数据结构</h1><ul><li><p>底层依托静态数组</p><p>（ArrayList、数组栈、数组队列）</p><ul><li>优<ul><li>有随机访问能力，index</li></ul></li><li>缺<ul><li>靠resize解决固定容量问题</li></ul></li></ul></li><li><p>真正动态数据结构（无需考虑容量）</p><p>（链表LinkedList、链表栈、链表队列）</p><ul><li>优<ul><li>真正动态，不需要处理固定容量问题</li></ul></li><li>缺<ul><li>丧失随机访问能力</li></ul></li></ul></li></ul><h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><blockquote><p>注意</p><ul><li>参数有index，都需要界限判断</li><li>容量capacity不够，加倍;   删除导致容量过多，减半</li></ul></blockquote><ul><li><p>复杂度分析</p><ul><li><p>添加操作：<code>O(n)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addLast(e)  O(<span class="number">1</span>)</span><br><span class="line">addFirst(e)  O(n)    </span><br><span class="line">add(index, e)  O(n) 算期望为n/<span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>删除操作：<code>O(n)</code></p><p>同添加</p></li><li><p>修改操作：已知索引<code>O(1)</code>；未知索引<code>O(n)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(index, e)O(<span class="number">1</span>):支持随机访问</span><br></pre></td></tr></table></figure></li><li><p>查找操作：已知索引<code>O(1)</code>；未知索引<code>O(n)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get(index)O(<span class="number">1</span>)</span><br><span class="line">contain(e)O(n)</span><br><span class="line">find(e)O(n)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>均摊时间复杂度</p><p>由于<code>resize</code>操作的存在，不可能每次添加都会触发。</p><p>假设<code>capacity = n</code>，n+1次<code>addLast</code>，触发1次<code>resize</code>，总共进行2n+1次基本操作。</p><p>（2n+1）/（n+1）≈ 2， 所以均摊时间复杂度为O(1)</p></li><li><p>复杂度震荡的问题</p><p>在capacity临界的地方，交替执行<code>addLast</code>和<code>removeLast</code>会出现频繁扩容缩容。</p><p>解决：Lazy，当size == capacity / 4时，再减去一半。</p></li></ul><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><ul><li><p>节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    E e;</span><br><span class="line">    Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>★设立虚拟头结点dummyHead</p><ol><li>为了解决，由于头位置没有前节点，有些操作（寻找Predecessor）需要区别对待的问题</li><li>为统一操作，故而添加</li></ol></blockquote><ul><li><p>时间复杂度</p><ul><li>增     <code>O(n)</code><ul><li>addLast                  O(n) </li><li>addFirst                  O(1)</li><li>add                          O(n/2)=O(n)</li></ul></li><li>删    <code>O(n)</code><ul><li>removeLast            O(n) </li><li>removeFirst           O(1)</li><li>remove                   O(n/2)=O(n)</li></ul></li><li><p>改    <code>O(n)</code></p></li><li><p>查    <code>O(n)</code></p><ul><li>get                           O(n)</li><li>contains                  O(n)</li></ul></li></ul><blockquote><p>小结</p></blockquote><ol><li>如果只对链表头进行操作：O(1)</li><li>一般不进行修改操作</li><li>只查表头元素 O(1)</li></ol></li></ul><blockquote><p><strong>引申</strong></p><ol><li>双链表</li><li>循环链表，jdk内部实现方式，null节点为虚拟头结点</li><li>数组链表</li></ol></blockquote><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>相当于数组操作的一个子集。后进先出Last In First Out（LIFO）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line">Interface Stack&lt;E&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E)</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>; <span class="comment">//栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间复杂度</p><ul><li><p>ArrayStack（数组栈）</p><ul><li>push        O(1) 均摊</li><li>pop              O(1) 均摊</li><li>peek            O(1)</li><li>getSize        O(1)</li><li>isEmpty       O(1)</li></ul></li><li><p>LinkedListStack</p><ul><li>push        O(1) </li><li>pop              O(1) </li><li>peek            O(1)</li><li>getSize        O(1)</li><li>isEmpty       O(1)</li></ul></li></ul><blockquote><p>对比</p><ol><li>复杂度相同，所以差异很小</li><li>但是当插入数据很多的时候，有可能链表栈效率会慢， 因为其<strong>new次数太多</strong>耗费时间，会去内存找新的可以开辟空间的地方</li></ol></blockquote></li></ul><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>先进先出 （FIFO）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line">Interface Queue&lt;E&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">dequeue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">getFront</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组队列"><a href="#数组队列" class="headerlink" title="数组队列"></a>数组队列</h3><ul><li>时间复杂度<ul><li>ArrayQueue（数组对列）<ul><li>enqueue     O(1) 均摊</li><li>dequeue     <strong>O(n) </strong>动态数组每次要往前移，重新赋值</li><li>front            O(1)</li><li>getSize        O(1)</li><li>isEmpty       O(1)</li></ul></li></ul></li></ul><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><blockquote><p>数组队列存在的问题：</p><p>删除队首元素时，O(n)，整体需要往前移一个位置，当n很大的时候，耗时</p></blockquote><ul><li>时间复杂度<ul><li>LoopQueue（循环对列）<ul><li>enqueue     O(1) 均摊</li><li>dequeue     <strong>O(1) </strong>均摊</li><li>front            O(1)</li><li>getSize        O(1)</li><li>isEmpty       O(1)</li></ul></li></ul></li></ul><h3 id="链表队列"><a href="#链表队列" class="headerlink" title="链表队列"></a>链表队列</h3><ul><li><p>思路历程</p><ol><li>LinkedList的头部增或删都是 O（1）级别的，而在尾部则需要O（n）级别搜索过去</li><li>因此可以用一个tail引用来记录尾部的地址，这样在尾部增操作也只需要O（1）级别操作。但在尾部删还是需要O（n），因为删除需要prev节点，还是需要遍历</li><li>综合考虑时间复杂度<ul><li>链表头head当做队首，作为删除元素</li><li>尾tail当做队尾，来添加元素</li></ul></li></ol></li><li><p>时间复杂度</p><ul><li>LinkedListQueue<ul><li>enqueue     O(1) </li><li>dequeue     O(1) </li><li>front            O(1)</li><li>getSize        O(1)</li><li>isEmpty       O(1)</li></ul></li></ul></li></ul><h2 id="链表与递归"><a href="#链表与递归" class="headerlink" title="链表与递归"></a>链表与递归</h2><p>近乎和链表相关的所有操作，都可以使用递归的形式完成。</p><ul><li>案例（删除链表中的元素）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:  <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">6</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span>, val = <span class="number">6</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure><ul><li><p>方法</p><ul><li><p>普通链表（不带虚拟头结点）</p><ul><li>思路<ol><li>删除操作，必然要找前继结点prev，为做统一化处理，故而头结点需要单独处理</li><li>先写出一般情况，默认头结点一定不是val，则写出遍历</li><li>单独处理头结点，保证头结点一定不是val开头</li></ol></li></ul></li><li><p>带虚拟头结点dummyHead</p><ul><li><p>思路</p><p>dummyHead的存在使得可以统一处理问题，简便</p></li></ul></li><li><p>递归</p><ul><li><p>思路</p><p>递归解决删除更小的链表中相应的元素</p></li></ul></li></ul></li></ul><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul><li><p>步骤</p><ol><li>求解最基本的问题</li><li>把原问题转化为更小的问题</li></ol></li><li><p>链表天然的递归性</p><p>链表1：0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; null</p><p>后面看做整体，0 -&gt; 1234 -&gt; null</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaWeb基础学习(2)</title>
      <link href="/2019/01/07/JavaWeb/JavaWeb%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A02/"/>
      <url>/2019/01/07/JavaWeb/JavaWeb%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A02/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p>MVC、事务、连接池、Ajax、监听器、过滤器、动态代理、注解</p></blockquote><p><img src="https://image-link.nos-eastchina1.126.net/javaweb_02"></p><a id="more"></a><h1 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h1><p><code>JavaBean</code>：一个普通类（实体bean）,包含3个标准</p><ol><li>无参构造</li><li>私有属性</li><li>公共的getter和setter方法</li></ol><h2 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h2><p>JSP + Servlet + JavaBean</p><p>MVC:开发模式 </p><p>M：模型     <code>JavaBean</code></p><p>V：视图        <code>JSP</code></p><p>C：控制器    <code>Servlet</code></p><h2 id="分层思想"><a href="#分层思想" class="headerlink" title="分层思想"></a>分层思想</h2><p>强内聚、弱耦合</p><p><img src="/2019/01/07/JavaWeb/JavaWeb基础学习2/分层.png" alt=""></p><h1 id="事务与连接池"><a href="#事务与连接池" class="headerlink" title="事务与连接池"></a>事务与连接池</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务指逻辑上的一组操作，组成这组操作的各个单元，要么全部成功，要么全部不成功。</p><h3 id="mysql事务"><a href="#mysql事务" class="headerlink" title="mysql事务"></a>mysql事务</h3><ol><li>mysql引擎支持事务</li><li>默认自动提交事务。(<strong>每条</strong>语句都处在<strong>单独</strong>的事务中)</li><li>手动控制事务<ul><li>开启：<code>start transaction | begin</code></li><li>提交：<code>commit</code></li><li>回滚：<code>rollback</code></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    conn.setAutoCommit(<span class="keyword">false</span>); <span class="comment">//1.相当于begin</span></span><br><span class="line">...<span class="comment">//2.做一些数据库操作</span></span><br><span class="line">conn.commit(); <span class="comment">//3.提交事务commit</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conn.rollback(); <span class="comment">//4.出异常，回滚rollback事务   </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    关闭资源</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h3><ul><li><p>原子性</p><ul><li>指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 </li></ul></li><li><p>一致性</p><ul><li>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。转账前和转账后的总金额不变。</li></ul></li><li><p>隔离性</p><ul><li>事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。</li></ul></li><li><p>持久性</p><ul><li>指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</li></ul></li></ul><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ul><li><p>赃读</p><ul><li>指一个事务读取了另一个事务未提交的数据。（<strong>绝对要避免</strong>）</li></ul></li><li><p>不可重复读</p><ul><li>在一个事务内读取表中的某一行数据，多次读取结果不同。一个事务读取到了另一个事务提交后的数据。（update）</li></ul></li><li><p>虚读（幻读）</p><ul><li>是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。 (insert)</li></ul></li></ul><p>设置事务的隔离级别：</p><p> 1、<code>READ UNCOMMITTED</code>: 赃读、不可重复读、虚读都有可能发生。</p><p> 2、<code>READ COMMITTED</code>: 避免赃读。不可重复读、虚读都有可能发生。（oracle默认的）</p><p> 4、<code>REPEATABLE READ</code>:避免赃读、不可重复读。虚读有可能发生。（mysql默认）</p><p> 8、<code>SERIALIZABLE</code>: 避免赃读、不可重复读、虚读。  (<strong>相当于锁住资源</strong>)</p><p>级别越高，性能越低，数据越安全</p><p>查看事务：<code>SELECT @@transaction_isolation;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDBC中控制事务隔离级别</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置隔离级别：必须在开启事务之前。</span></span><br><span class="line">Connection.setTransactionIsolation(<span class="keyword">int</span> level);</span><br><span class="line"><span class="comment">//可用宏</span></span><br><span class="line">TRANSACTION_READ_UNCOMMITTED <span class="comment">//可脏读</span></span><br><span class="line">TRANSACTION_READ_COMMITTED  <span class="comment">//不可脏读</span></span><br><span class="line">TRANSACTION_REPEATABLE_READ <span class="comment">//不可脏读、重复读</span></span><br><span class="line">TRANSACTION_SERIALIZABLE  <span class="comment">//不可脏读、重复读和虚读</span></span><br></pre></td></tr></table></figure><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="/2019/01/07/JavaWeb/JavaWeb基础学习2/连接池原理.jpg" alt=""></p><p>目的：解决建立数据库连接耗费资源和时间很多的问题，提高性能。</p><h3 id="模拟连接池"><a href="#模拟连接池" class="headerlink" title="模拟连接池"></a>模拟连接池</h3><p>自定义数据库连接池要实现<code>javax.sql.DataSource</code>接口，一个标准，防五花八门。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDataSource</span> <span class="keyword">implements</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于默认的<code>Connection</code>接口的<code>close()</code>方法直接关闭，而在连接池中不允许关闭</p><p>解决方法</p><ul><li>装饰设计模式：包装<code>Connection</code>，直接写<code>MyConnection</code></li><li>先用适配器包装一遍，再写自己的包装类<code>MyConnection</code></li></ul><h3 id="常用数据源配置"><a href="#常用数据源配置" class="headerlink" title="常用数据源配置"></a>常用数据源配置</h3><h4 id="DPCP"><a href="#DPCP" class="headerlink" title="DPCP"></a>DPCP</h4><h4 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h4><h1 id="DBUtils"><a href="#DBUtils" class="headerlink" title="DBUtils"></a>DBUtils</h1><p>DBUtils封装了对JDBC的操作，简化了JDBC操作。可以少写代码。</p><ol><li><p>对于数据表的<strong>读操作</strong>，他可以把结果转换成List，Array，Set等java集合，便于程序员操作；</p></li><li><p>对于数据表的<strong>写操作</strong>，也变得很简单（只需写sql语句）</p></li><li><p>可以使用数据源，使用JNDI，数据库连接池等技术来优化性能—重用已经构建好的数据库连接对象</p></li></ol><h2 id="核心对象"><a href="#核心对象" class="headerlink" title="核心对象"></a>核心对象</h2><ul><li><code>QueryRunner</code> 类<ul><li>提供对sql语句操作的API<ul><li><code>query()</code>：执行select</li><li><code>update()</code>：执行insert update delete</li><li><code>batch()</code>：批处理</li></ul></li></ul></li><li><code>ResultSetHandler</code>：接口<ul><li>用于定义select操作后，怎样封装结果集</li><li><code>ArrayHandler</code>：取1条记录。把该条记录的每列值封装到一个数组中<code>Object[]</code></li><li><code>ArrayListHandler</code>：取多条记录</li><li><code>ColumnListHandler</code>：取某一列的数据，封装到List中</li><li><code>KeyedHandler</code>：取多条记录</li><li><code>MapHandler</code>：取1条记录。把当前记录的列名和列值放到一个Map中</li><li><code>MapListHandler</code>：取多条记录。把每条记录封装到一个Map中，再把Map封装到List中</li><li><code>ScalarHandler</code>：取单行单列数据</li><li><code>BeanHandler</code></li><li><code>BeanListHandler</code> </li></ul></li><li><code>DbUtils</code>类（用的不多）<ul><li>它就是一个工具类,定义了关闭资源与事务处理的方法</li></ul></li></ul><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ol><li>导入jar包</li><li>创建<code>QueryRunner</code>对象</li><li>使用<code>query</code>方法执行<code>select</code>语句</li><li>使用<code>ResultSetHandler</code>封装结果集 (<code>BeanListHandler</code>)</li><li>使用<code>DbUtils</code>类释放资源</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QueryRunner qr = <span class="keyword">new</span> QueryRunner(C3P0Util.getDataSource());</span><br><span class="line">List&lt;User&gt; list = qr.query(<span class="string">"select * from users"</span>, <span class="keyword">new</span> BeanListHandler&lt;User&gt;(User.class));</span><br></pre></td></tr></table></figure><h2 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h2><p>模拟<code>ThreadLocal</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Runnable,Object&gt; container = <span class="keyword">new</span> HashMap&lt;Runnable,Object&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object value)</span></span>&#123;</span><br><span class="line">        container.put(Thread.currentThread(),value);<span class="comment">//用当前线程作为key</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> container.get(Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">        container.remove(Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p>(Asynchronous JavaScript And XML)</p><p> = DHTML(html4.0) + XHR</p><p><strong>只刷新局部页面的技术</strong></p><ul><li>JavaScript：更新局部的网页</li><li>XML：一般用于请求数据和响应数据的封装</li><li><code>XMLHttpRequest</code>对象：发送请求到服务器并获得返回结果</li><li>CSS：美化页面样式</li><li>异步：发送请求后不等返回结果，由回调函数处理结果</li></ul><h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h2><ol><li>方法</li></ol><ul><li><code>open(method,URL,async)</code> <ul><li>get|post</li><li>url?name=fyd</li><li>true |false   (默认true，异步)</li></ul></li><li><code>send(content)</code><ul><li>发送请求。 可带参数或null</li></ul></li><li><code>setRequestHeader(header,value)</code><ul><li>请求消息头</li></ul></li></ul><ol><li>属性</li></ol><ul><li><p>readyState：类型short；只读  </p><p> (XMLHttpRequest的状态信息)</p><ul><li><p>0     XMLHttpRequest对象没有完成初始化</p><ul><li>刚刚创建</li></ul></li><li><p>1     对象<strong>开始</strong>发送请求</p><ul><li>调用了open方法，但还没有调用send方法。请求还没有发出</li></ul></li><li><p>2     请求<strong>发送完成</strong></p><ul><li>send方法已经调用，数据已经提交到服务器，但没有任何响应</li></ul></li><li><p>3      <strong>开始读取响应，还没有结束</strong></p><ul><li>收到了所有的响应消息头，但正文还没有完全收到</li></ul></li><li><p>4       对象读取<strong>响应结束</strong></p><ul><li>一切都收到了</li></ul></li></ul></li><li><p>responseText：类型String；只读</p></li><li><p>responseXML：类型Document；只读</p></li><li><p>status：类型short；只读</p><ul><li>200   正常</li><li>400   无法找到请求的资源</li><li>403   没有访问权限</li><li>404   访问的资源不存在</li><li>500   服务器内部错误</li></ul></li></ul><ol><li>事件处理器</li></ol><ul><li>onreadystatechange(当状态码变动调用，回调的功能)</li></ul><h1 id="Listener-amp-Filter"><a href="#Listener-amp-Filter" class="headerlink" title="Listener &amp; Filter"></a>Listener &amp; Filter</h1><h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><ol><li><p>什么是监听器</p><p> Javaweb中的监听器是用于监听web常见对象<code>HttpServletRequest</code>,<code>HttpSession</code>,<code>ServletContext</code></p></li><li><p>监听器的作用</p><ul><li>监听web对象创建与销毁.</li><li>监听web对象的属性变化</li><li>监听session绑定javaBean操作.</li></ul></li><li><p>监听机制相关概念</p><ul><li>事件——一件事情</li><li>事件源—-产生这件事情的源头</li><li>注册监听—-将监听器与事件绑定，当事件产生时，监听器可以知道，并进行处理。-</li><li>监听器—-对某件事情进行处理监听的一个对象</li></ul></li></ol><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>Javaweb中的过滤器可以拦截所有访问web资源的请求或响应操作。</p><h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><ol><li><p>jdk提供一个Proxy类可以直接给实现接口类的对象直接生成代理对象。</p></li><li><p>cglib  (spring学习)</p></li></ol><h2 id="AOP编程思想"><a href="#AOP编程思想" class="headerlink" title="AOP编程思想"></a>AOP编程思想</h2><ul><li>业务方法日后会很多，会有很多重复的代码</li><li>已经存在很多的方法，并没有考虑到事务的问题，现在要求加上</li></ul><p><img src="/2019/01/07/JavaWeb/JavaWeb基础学习2/aop.jpg" alt=""></p><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="JDK三个基本注解"><a href="#JDK三个基本注解" class="headerlink" title="JDK三个基本注解"></a>JDK三个基本注解</h2><ul><li><p><code>@Override</code>：检查子类确实是覆盖了父类的方法。</p></li><li><p><code>@Deprecated</code>：说明已经过时了。</p></li><li><p><code>@SuppressWarnings({ &quot;unused&quot;, &quot;deprecation&quot; })</code>：抑制程序中的警告。unused警告的类型。{}数组。all抑制所有警告。</p></li></ul><h2 id="自定义注解语法"><a href="#自定义注解语法" class="headerlink" title="自定义注解语法"></a>自定义注解语法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注解它的本质就是一个接口，这个接口需要继承 Annotation接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyAnnotation</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">annotation</span>.<span class="title">Annotation</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span>  <span class="keyword">default</span> -1</span>;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">Class <span class="title">clazz</span><span class="params">()</span> <span class="keyword">default</span> Object.class</span>;</span><br><span class="line">    String[] value(); <span class="comment">//赋值可一个字符串，相当于一个元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseAnnotation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@MyAnnotation</span>(age=<span class="number">26</span>,name=<span class="string">"lp"</span>,value=<span class="string">"fyd"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>注解中的成员</p><ul><li>本质接口，接口中为属性方法</li></ul></li><li><p>注解属性类型</p><ul><li>基本类型</li><li>String</li><li>枚举类型</li><li>注解类型</li><li>Class类型</li><li>以上类型的一维数组类型</li></ul></li><li><p>注解的反射<strong>重点</strong></p><ol><li>反射注解类</li></ol><p><code>java.lang.reflect.AnnotatedElement:</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;T extends Annotation&gt; <span class="function">T <span class="title">getAnnotation</span><span class="params">(Class&lt;T&gt; annotationType)</span></span></span><br><span class="line"><span class="function"><span class="comment">//得到指定类型的注解引用。没有返回null。</span></span></span><br><span class="line"><span class="function">Annotation[] <span class="title">getAnnotations</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//得到所有的注解，包含从父类继承下来的。</span></span></span><br><span class="line"><span class="function">Annotation[] <span class="title">getDeclaredAnnotations</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//得到自己身上的注解。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAnnotationPresent</span><span class="params">(Class&lt;? extends Annotation&gt; annotationType)</span></span></span><br><span class="line"><span class="function"><span class="comment">//判断指定的注解有没有</span></span></span><br></pre></td></tr></table></figure><p><code>Class</code>、<code>Method</code>、<code>Field</code>、<code>Constructor</code>等实现了<code>AnnotatedElement</code>接口.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class.isAnnotationPresent(MyTest.class)</span><br><span class="line"><span class="comment">//判断类上面有没有@MyTest注解；</span></span><br><span class="line">Method.isAnnotationPresent(MyTest.class)</span><br><span class="line"><span class="comment">//判断方法上面有没有@MyTest注解。</span></span><br></pre></td></tr></table></figure><ol><li>反射注解中的属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = MyClass.class;</span><br><span class="line">Method methods = clazz.getMethods();</span><br><span class="line"><span class="keyword">for</span> (Method m:methods) &#123;</span><br><span class="line">    MyTest myTest = m.getAnnotation(MyTest.class);</span><br><span class="line">    <span class="keyword">if</span> (myTest != <span class="keyword">null</span>) &#123; <span class="comment">//方法上面有MyTest注解</span></span><br><span class="line">        <span class="comment">//获取注解的timeout属性</span></span><br><span class="line">        <span class="keyword">long</span> time = myTest.timeout(); <span class="comment">// -1或者大于0的值</span></span><br><span class="line">        <span class="keyword">if</span> (time &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//不需要测试效率</span></span><br><span class="line">            m.invoke(clazz.newInstance(), <span class="keyword">null</span>);<span class="comment">//执行方法</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//需要测试效率</span></span><br><span class="line">            <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">            m.invoke(clazz.newInstance(), <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">long</span> costTime = System.nanoTime() - startTime;</span><br><span class="line">            <span class="keyword">if</span> (costTime &gt; time) &#123;</span><br><span class="line">                System.out.println(m.getName()+<span class="string">"超时"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>自定义的注解的存活范围（生命周期）：默认是CLASS。</p><p><img src="/2019/01/07/JavaWeb/JavaWeb基础学习2/生命周期.jpg" alt=""></p><p>只能用在注解上的注解叫做元注解。（即：用于修饰注解的注解）</p><ul><li><p><code>@Retention</code>：作用。改变自定义的注解的存活范围。</p><ul><li>RetentionPolicy宏对象:<ul><li>SOURCE</li><li>CLASS</li><li>RUNTIME</li></ul></li></ul></li><li><p><code>@Target</code>：作用。指定该注解能用在什么地方。</p><ul><li>ElementType:<ul><li>TYPE</li><li>METHOD</li><li>FIELD</li><li>ANNOTATION_TYPE</li></ul></li></ul></li><li><p><code>@Documented</code>：作用，使用了@MyTest的注解的类，如果@MyTest注解上面有<code>@Documented</code>注解，那么使用了@MyTest的注解的类的API文档中会出现@MyTest的身影。</p></li><li><p><code>@Inherited</code>：作用，说明该注解可以被继承下去</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mysql</title>
      <link href="/2018/12/23/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
      <url>/2018/12/23/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p>Mysql、JDBC</p></blockquote><p><img src="https://image-link.nos-eastchina1.126.net/mysql"></p><a id="more"></a><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><ul><li><p>常用命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p passwd -P 端口号 -h 服务器地址  </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">VERSION</span>();</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">NOW</span>();</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>();</span><br></pre></td></tr></table></figure><ul><li>关键字与函数名全部大写</li><li>数据库名、表名、字段名全部小写</li></ul></li></ul><h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><ul><li><p>数据定义语言（Data Definition Language）</p><ul><li><p>用来定义数据库对象：库、表、列等；</p></li><li><p><code>CREATE、 ALTER、DROP</code></p></li></ul></li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li>创建</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> &#123;<span class="keyword">DATABASE</span> | <span class="keyword">SCHEMA</span>&#125; [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] db_name</span><br><span class="line">[<span class="keyword">DEFAULT</span>] <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> [=] charset_name;  </span><br><span class="line"><span class="comment">/* if not 不直接报错，把错误加到warining中 */</span></span><br></pre></td></tr></table></figure><ul><li>查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*查看当前数据库服务器中的所有数据库*/</span></span><br><span class="line"><span class="keyword">SHOW</span> &#123;<span class="keyword">DATABASES</span> | SCHEMAS&#125; [<span class="keyword">LIKE</span> <span class="string">'pattern'</span> | <span class="keyword">WHERE</span> expr];</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">WARNINGS</span>;</span><br><span class="line"><span class="comment">/*显示数据库创建时指令*/</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> db_name;</span><br></pre></td></tr></table></figure><ul><li>修改</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*改编码方式*/</span></span><br><span class="line"><span class="keyword">ALTER</span> &#123;<span class="keyword">DATABASE</span> | <span class="keyword">SCHEMA</span>&#125; [db_name] [<span class="keyword">DEFAULT</span>] <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> [=] charset_name;</span><br></pre></td></tr></table></figure><ul><li>删除</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> &#123;<span class="keyword">DATABASE</span> | <span class="keyword">SCHEMA</span>&#125; [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] db_name;</span><br></pre></td></tr></table></figure><h3 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h3><p><code>USE db_name;</code></p><p><code>SELECT DATABASE();</code>   查看当前使用的数据库</p><ul><li>创建</li></ul><h4 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h4><ul><li><p>主键约束(<code>PRIMARY KEY</code>)</p><ul><li>每张表只能存在一个主键</li><li>主键保证记录唯一性</li><li>主键自动为NOT NULL    </li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*方法1*/</span></span><br><span class="line">Id int primary key,</span><br><span class="line"><span class="comment">/*方法2：可联合主键*/</span></span><br><span class="line">id int,</span><br><span class="line">Name varchar(50),</span><br><span class="line">Primary key(id)</span><br><span class="line"><span class="comment">/*方法3：创建后修改*/</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">ADD</span>  PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure></li><li><p>唯一约束(<code>UNIQUE KEY</code>)</p><ul><li>可以存在多个唯一约束</li><li>可保记录唯一性</li><li>字段可为NULL</li></ul></li><li><p>默认约束（ <code>DEFAULT</code>）</p><p><code>sex ENUM(&#39;1&#39;, &#39;2&#39;, &#39;3&#39;) DEFAULT &#39;3&#39;</code></p></li><li><p>非空约束（<code>NOT NULL</code>）</p></li><li><p>外键约束（一般不用物理外键，而用逻辑外键）</p><p>保持数据一致性，完整性。实现1对1，1对多的关系。</p><p><code>FOREIGN KEY (pid) REFERENCES tb_name (id) ON {DELETE|UPDATE} 操作</code></p><ul><li>要求<ul><li>父表和子表必须为相同存储引擎，禁止用临时表</li><li>数据表的存储引擎只是为InnoDB</li><li>外键列和参照列必须具有相似数据类型。其中数字的长度或是否有符号位必须相同；而字符的长度则可以不同。</li><li>外键列和参照列必须创建索引。如果外键列不存在索引，MySQL会自动创建</li></ul></li><li>参照操作<ul><li>CASCADE：父表删除或更新且自动删除或者更新字表中匹配行</li><li>SET NULL：父表删除或更新行，并设置字表中外键列为NULL。字表不为NOT NULL </li><li>RESTRICT：拒绝对父表的删除或更新操作</li><li>NOT ACTION：标准SQL关键字，在MySQL中同RESTRICT</li></ul></li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] table_name (</span><br><span class="line">    column_name data_type </span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span>, <span class="comment">/*自动编号，必须为主键*/</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*查数据库中表*/</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLES</span> [<span class="keyword">FROM</span> db_name] [<span class="keyword">LIKE</span> <span class="string">'pattern'</span> | <span class="keyword">WHERE</span> expr];</span><br><span class="line"><span class="comment">/*查某表所有列*/</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">COLUMNS</span> <span class="keyword">FROM</span> tb_name;</span><br><span class="line"><span class="comment">/*查某表索引*/</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEXES</span> <span class="keyword">FROM</span> tb_name\G;</span><br></pre></td></tr></table></figure><ul><li>修改</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*添加单列*/</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb_name <span class="keyword">ADD</span>  col_name column_def [FRIST | <span class="keyword">AFTER</span> col_name]</span><br><span class="line"></span><br><span class="line"><span class="comment">/*添加多列*/</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb_name <span class="keyword">ADD</span>  (col_name column_def, ...)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*添加约束*/</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb_name <span class="keyword">ADD</span>  PRIMARY <span class="keyword">KEY</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">/*添加删除默认约束*/</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb_name <span class="keyword">ALTER</span>  col_name &#123;<span class="keyword">SET</span> <span class="keyword">DEFAULT</span> 默认值/<span class="keyword">DROP</span> <span class="keyword">DEFAULT</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>删除</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*删列*/</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">DROP</span> col_name1,<span class="keyword">DROP</span> col_name2;</span><br></pre></td></tr></table></figure><h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><ul><li><p>数据操作语言（Data Manipulation Language）</p><ul><li><p>用来定义数据库记录（数据）   </p></li><li><p><code>INSERT、 UPDATE、 DELETE</code></p></li></ul></li><li><p>插入记录</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> tbl_name [(col_name,...)] <span class="keyword">VALUES</span>(val1,...),(val2);</span><br><span class="line"><span class="comment">/*默认值用DEFAULT或者在字段名中省略对应*/</span></span><br><span class="line"><span class="keyword">INSERT</span> tb1_name <span class="keyword">SET</span> col_name=&#123;expr|<span class="keyword">DEFAULT</span>&#125;,...;<span class="comment">/*可用子查询*/</span></span><br></pre></td></tr></table></figure><ul><li>删除记录</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tb_name <span class="keyword">WHERE</span> 条件</span><br></pre></td></tr></table></figure><ul><li>更新记录</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">SET</span> col_name = <span class="keyword">DEFAULT</span> | 表达式 [<span class="keyword">WHERE</span> 条件];</span><br></pre></td></tr></table></figure><h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><ul><li>数据查询语言<ul><li><code>SELECT</code></li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> selection_list <span class="comment">/*要查询的列名称*/</span></span><br><span class="line"><span class="keyword">FROM</span> table_list <span class="comment">/*要查询的表名称*/</span></span><br><span class="line"><span class="keyword">WHERE</span> condition <span class="comment">/*行条件*/</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> grouping_columns <span class="comment">/*对结果分组*/</span></span><br><span class="line"><span class="keyword">HAVING</span> condition <span class="comment">/*分组后的行条件*/</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> sorting_columns <span class="comment">/*对结果分组*/</span></span><br><span class="line"><span class="keyword">LIMIT</span> offset_start, <span class="keyword">row_count</span> <span class="comment">/*结果限定*/</span></span><br></pre></td></tr></table></figure><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><ul><li>=、!=、&lt;&gt;、&lt;、&lt;=、&gt;、&gt;=；</li><li>BETWEEN…AND； </li><li>IN(set)；</li><li>IS NULL； IS NOT NULL</li><li>AND；</li><li>OR；</li><li>NOT； </li></ul><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><ul><li>通配符: <ul><li><code>_</code>：任意一个字符</li><li><code>%</code>：任意0~n个字符</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*查询姓名中第2个字母为“i”的学生记录*/</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stu <span class="keyword">WHERE</span> sname <span class="keyword">LIKE</span> <span class="string">'_i%'</span>;</span><br></pre></td></tr></table></figure><h3 id="字段控制查询"><a href="#字段控制查询" class="headerlink" title="字段控制查询"></a>字段控制查询</h3><ul><li><p>去重</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> sal <span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure></li><li><p>加法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*查询出来结果会多一列求和结果*/</span></span><br><span class="line"><span class="keyword">SELECT</span> *,sal+comm <span class="keyword">FROM</span> emp;</span><br><span class="line"><span class="comment">/*IFNULL把NULL转换为数值*/</span></span><br><span class="line"><span class="keyword">SELECT</span> *,sal+<span class="keyword">IFNULL</span>(comm,<span class="number">0</span>) <span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure></li><li><p>给列起别名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *, sal+<span class="keyword">IFNULL</span>(comm,<span class="number">0</span>) <span class="keyword">AS</span> total <span class="keyword">FROM</span> emp;</span><br><span class="line"><span class="comment">/*AS可以省略*/</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stu <span class="keyword">ORDER</span> <span class="keyword">BY</span> sage [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>];</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">ORDER</span> <span class="keyword">BY</span> sal <span class="keyword">DESC</span>,empno <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>聚合函数是用来做纵向运算的函数：</p><ul><li><p><code>COUNT()</code>：统计指定列不为NULL的记录行数；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*查询emp表中记录数：*/</span> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> cnt <span class="keyword">FROM</span> emp;</span><br><span class="line"><span class="comment">/*查询emp表中有佣金的人数：*/</span> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(comm) cnt <span class="keyword">FROM</span> emp;</span><br><span class="line"><span class="comment">/*查询有佣金的人数，有领导的人数：*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(comm), <span class="keyword">COUNT</span>(mgr) <span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure></li><li><p><code>MAX()</code>：计算指定列的最大值，如果指定列是字符串类型，那么使用字符串排序运算；</p></li><li><p><code>MIN()</code>：计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*查询最高工资和最低工资：*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(sal), <span class="keyword">MIN</span>(sal) <span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure></li><li><p><code>SUM()</code>：计算指定列的数值和，如果指定列类型不是数值类型，那么计算结果为0；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*查询所有雇员月薪和，以及所有雇员佣金和*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(sal), <span class="keyword">SUM</span>(comm) <span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure></li><li><p><code>AVG()</code>：计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为0；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*统计所有员工平均工资：*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(sal) <span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure></li></ul><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><ul><li><p>普通分组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*查询每个部门的部门编号和每个部门的工资和：*/</span></span><br><span class="line"><span class="keyword">SELECT</span> deptno, <span class="keyword">SUM</span>(sal) </span><br><span class="line"><span class="keyword">FROM</span> emp </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno;</span><br><span class="line"><span class="comment">/*凡和聚合函数同时出现的列名，一定要写在group by 之后*/</span></span><br></pre></td></tr></table></figure></li><li><p><code>HAVING</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*查询工资总和大于9000的部门编号以及工资和：*/</span></span><br><span class="line"><span class="keyword">SELECT</span> deptno, <span class="keyword">SUM</span>(sal)</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">SUM</span>(sal) &gt; <span class="number">9000</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意点</p></blockquote><p>having与where的区别:</p><ol><li><p><code>having</code>是在分组后对数据进行过滤.</p><p><code>where</code>是在分组前对数据进行过滤​        </p></li><li><p><code>having</code>后面可以使用聚合函数(统计函数)</p></li></ol><p>​         <code>where</code>后面不可以使用聚合函数。</p><p><code>WHERE</code>是对分组前记录的条件，如果某行记录没有满足WHERE子句的条件，那么这行记录不会参加分组；而<code>HAVING</code>是对分组后数据的约束。</p></li></ul><h3 id="LIMIT（特有）"><a href="#LIMIT（特有）" class="headerlink" title="LIMIT（特有）"></a>LIMIT（特有）</h3><ul><li>LIMIT用来限定查询结果的起始行，以及总行数。（作分页用）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*查询5行记录，起始行从0开始*/</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">LIMIT</span> <span class="number">0</span>, <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><ul><li><p>合并结果集；UNION 、  UNION ALL</p></li><li><p>连接查询</p><ul><li>内连接  [INNER] JOIN  ON </li><li>外连接  OUTER JOIN ON<ul><li>左外连接 LEFT [OUTER] JOIN</li><li>右外连接 RIGHT [OUTER] JOIN</li><li>全外连接（MySQL不支持）FULL JOIN</li></ul></li><li>自然连接  NATURAL JOIN</li></ul></li><li>子查询</li></ul><h3 id="合并结果集"><a href="#合并结果集" class="headerlink" title="合并结果集"></a>合并结果集</h3><ul><li><p>作用</p><ul><li>合并结果集就是把两个select语句的查询结果合并到一起！</li></ul></li><li><p>两种方式</p><ul><li><p>UNION：去除重复记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t2；</span><br></pre></td></tr></table></figure></li><li><p>UNION ALL：不去除重复记录</p></li></ul></li></ul><blockquote><p>要求：</p></blockquote><p><strong>要被合并的两个结果：列数、列类型必须相同，列名可不同。</strong></p><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>连接查询会产生笛卡尔积</p><p><strong>使用主外键关系做为条件来去除无用信息</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp,dept <span class="keyword">WHERE</span> emp.deptno=dept.deptno</span><br></pre></td></tr></table></figure><ul><li>内连接<ul><li>特点：查询结果必须满足条件。</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> emp e </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> dept d <span class="comment">/*MySQL默认的连接方式就是内连接*/</span></span><br><span class="line"><span class="keyword">ON</span> e.deptno=d.deptno;</span><br></pre></td></tr></table></figure><ul><li>外连接(左、右连接)<ul><li>特点：查询出的结果存在不满足条件的可能(不满足条件的显示NULL。)。</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*左连接*/</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp e </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> dept d </span><br><span class="line"><span class="keyword">ON</span> e.deptno=d.deptno;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*右连接*/</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp e </span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> dept d </span><br><span class="line"><span class="keyword">ON</span> e.deptno=d.deptno;</span><br></pre></td></tr></table></figure><h3 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h3><p>连接查询会产生无用笛卡尔积，我们通常使用主外键关系等式来去除它。而自然连接无需你去给出主外键等式，它会自动找到这一等式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> dept;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">NATURAL</span> <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> dept;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">NATURAL</span> <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> dept;</span><br></pre></td></tr></table></figure><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><ul><li><p>出现位置</p><ul><li><p>where后，作为条为被查询的一条件的一部分；</p></li><li><p>from后，作表；</p></li></ul></li><li><p>当子查询出现在where后作为条件时，还可以使用如下关键字：</p><ul><li><p>any</p></li><li><p>all</p></li></ul></li><li><p>子查询结果集的形式：</p><ul><li>单行单列（用于条件）</li><li>单行多列（用于条件）</li><li>多行单列（用于条件）</li><li>多行多列（用于表）</li></ul></li></ul><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p>自己连接自己，起别名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*求7369员工编号、姓名、经理编号和经理姓名*/</span></span><br><span class="line"><span class="keyword">SELECT</span> e1.empno , e1.ename,e2.mgr,e2.ename </span><br><span class="line"><span class="keyword">FROM</span> emp e1, emp e2 </span><br><span class="line"><span class="keyword">WHERE</span> e1.mgr = e2.empno <span class="keyword">AND</span> e1.empno = <span class="number">7369</span>;</span><br></pre></td></tr></table></figure><h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><ul><li>操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//1、注册驱动</span></span><br><span class="line">DriverManager.registerDriver(<span class="keyword">new</span> com.mysql.jdbc.Driver());</span><br><span class="line"><span class="comment">//2、创建连接</span></span><br><span class="line">Connection conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/test"</span>, <span class="string">"root"</span>, <span class="string">""</span>);</span><br><span class="line"><span class="comment">//3、得到操作db的sql语句的对象Statement</span></span><br><span class="line">Statement stmt = conn.createStatement();</span><br><span class="line"><span class="comment">//4、执行sql</span></span><br><span class="line">ResultSet rs = stmt.executeQuery(<span class="string">"select * from emp limit 0, 1"</span>);</span><br><span class="line"><span class="comment">//5、处理结果</span></span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">    System.out.println(rs.getObject(<span class="number">1</span>));<span class="comment">//结果某行第一列</span></span><br><span class="line">    System.out.println(rs.getObject(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6、关闭资源</span></span><br><span class="line">rs.close();</span><br><span class="line">stmt.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure><h2 id="常用类和接口"><a href="#常用类和接口" class="headerlink" title="常用类和接口"></a>常用类和接口</h2><h3 id="java-sql-Drivermanager类"><a href="#java-sql-Drivermanager类" class="headerlink" title="java.sql.Drivermanager类"></a>java.sql.Drivermanager类</h3><ul><li><p>创建连接</p></li><li><p>注册驱动</p><p><code>DriverManager.registerDriver(new com.mysql.jdbc.Driver());</code>不建议使用</p><ul><li>导致驱动被注册2次（<code>com.mysql.jdbc.Driver</code>中有静态代码块注册驱动）</li><li>强烈依赖数据库的驱动jar</li></ul><blockquote><p>推荐使用</p></blockquote><p><code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code>//直接加载这个Class</p></li></ul><h3 id="java-sql-Connection接口："><a href="#java-sql-Connection接口：" class="headerlink" title="java.sql.Connection接口："></a>java.sql.Connection接口：</h3><ul><li>一个连接</li></ul><p><code>Statement createStatement();</code> //创建操作sql语句的对象</p><h3 id="java-sql-Statement接口"><a href="#java-sql-Statement接口" class="headerlink" title="java.sql.Statement接口"></a>java.sql.Statement接口</h3><ul><li>操作sql语句，并返回相应结果的对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ResultSet  <span class="title">executeQuery</span><span class="params">(String sql)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//根据查询语句返回结果集。只能执行select语句。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">(String sql)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//根据执行的DML（insert update delete）语句，返回受影响的行数。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(String sql)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//此方法可以执行任意sql语句。返回boolean值，表示是否返回ResultSet结果集。仅当执行select语句，且有返回结果时返回true, 其它语句都返回false;</span></span></span><br></pre></td></tr></table></figure><h3 id="java-sql-ResultSet接口"><a href="#java-sql-ResultSet接口" class="headerlink" title="java.sql.ResultSet接口"></a>java.sql.ResultSet接口</h3><ul><li>结果集（客户端存表数据的对象）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">getObject</span><span class="params">(<span class="keyword">int</span> columnIndex)</span></span>;<span class="comment">//根据序号取值，索引从1开始</span></span><br><span class="line"><span class="function">Object <span class="title">getObject</span><span class="params">(String ColomnName)</span></span>; <span class="comment">//根据列名取值。</span></span><br></pre></td></tr></table></figure><ul><li><p>将结果集中的数据封装到javaBean中</p><ul><li><p>java的数据类型与数据库中的类型的关系</p><p>byte               tityint</p><p>short             smallint</p><p>int                  int</p><p>long             bigint</p><p>float             float</p><p>double            double</p><p>String            char varchar </p><p>Date             date</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span><span class="comment">//将光标从当前位置向下移动一行</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">(<span class="keyword">int</span> colIndex)</span><span class="comment">//以int形式获取ResultSet结果集当前行指定列号值</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">(String colLabel)</span><span class="comment">//以int形式获取ResultSet结果集当前行指定列名值</span></span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">getFloat</span><span class="params">(String colLabel)</span></span></span><br><span class="line"><span class="function">String <span class="title">getString</span><span class="params">(String colLabel)</span>  </span></span><br><span class="line"><span class="function">Date <span class="title">getDate</span><span class="params">(String columnName)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>可移动游标</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">previous</span><span class="params">()</span></span>;<span class="comment">//将光标移动到此 ResultSet 对象的上一行。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">absolute</span><span class="params">(<span class="keyword">int</span> row)</span></span>;<span class="comment">//参数是当前行的索引，从1开始。根据行的索引定位移动的指定索引行。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterLast</span><span class="params">()</span></span>;<span class="comment">//将光标移动到末尾，正好位于最后一行之后。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">beforeFirst</span><span class="params">()</span></span>;<span class="comment">//将光标移动到开头，正好位于第一行之前。</span></span><br></pre></td></tr></table></figure><h3 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  ...  </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rs.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//stmt、conn同rs</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><ul><li><p>SQL注入问题：<code>preparedStatement</code></p><p>preparedStatement：预编译对象， 是Statement对象的子类。</p><ul><li>特点<ul><li>性能要高，会把sql语句先编译</li><li>sql语句中的参数会发生变化，过滤掉用户输入的关键字</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"select * from users where name? and password=?"</span>;</span><br><span class="line">ps = conn.prepareStatement(sql); </span><br><span class="line"><span class="comment">//给预编译sql赋值</span></span><br><span class="line">ps.setString(<span class="number">1</span>, name); <span class="comment">//1代表sql语句第一个？</span></span><br><span class="line">ps.setString(<span class="number">2</span>, password);</span><br><span class="line">ps.executeQuery();</span><br></pre></td></tr></table></figure></li><li><p>DBUtils</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        加载驱动</span><br><span class="line">    &#125;</span><br><span class="line">    方法：获取连接</span><br><span class="line">    方法：关闭资源</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Insert</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stmt = conn.prepareStatement(<span class="string">"INSERT INTO users VALUES(?,?,?,?,?)"</span>);</span><br><span class="line"><span class="keyword">int</span> i = stmt.executeUpdate();</span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">"success"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Update</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stmt = conn.prepareStatement(<span class="string">"UPDATE users SET NAME=?,PASSWORD=?,email=? WHERE id=?"</span>);</span><br><span class="line">stmt.setString(<span class="number">1</span>, <span class="string">"fyd"</span>);</span><br><span class="line">stmt.setString(<span class="number">2</span>, <span class="string">"208"</span>);</span><br><span class="line">stmt.setString(<span class="number">3</span>, <span class="string">"lp@163.com"</span>);</span><br><span class="line">stmt.setInt(<span class="number">4</span>, <span class="number">1206</span>);</span><br><span class="line"><span class="keyword">int</span> i = stmt.executeUpdate();</span><br></pre></td></tr></table></figure></li><li><p>Delete</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stmt = conn.createStatement();</span><br><span class="line"><span class="keyword">int</span> i = stmt.executeUpdate(<span class="string">"DELETE FROM users WHERE id=4"</span>);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaWeb基础学习(1)</title>
      <link href="/2018/12/10/JavaWeb/JavaWeb%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A01/"/>
      <url>/2018/12/10/JavaWeb/JavaWeb%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A01/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p>XML语言、Tomcat服务器、Servlet、JSP简介</p></blockquote><p><img src="https://image-link.nos-eastchina1.126.net/javaweb_01"></p><a id="more"></a><h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><ol><li>概述</li></ol><ul><li>可扩展：所有的标签都是自定义的。  </li><li><p>功能：数据存储</p><ul><li>配置文件</li><li>数据传输</li></ul></li><li><p>html与xml区别：</p><ul><li>html语法松散，xml语法严格</li><li>html做页面展示，xml做<strong>数据存储</strong></li><li>html所有标签都是预定义的，xml所有标签都是自定义的</li></ul></li></ul><ol><li>语法</li></ol><ul><li><p>文档声明：</p><ul><li>必须写在xml文档的第一行。</li><li>写法：<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</code></li><li>属性：    <ul><li>version：版本号 固定值 1.0</li><li>encoding:指定文档的码表。默认值为 iso-8859-1</li><li>standalone：指定文档是否独立  yes 或 no</li></ul></li></ul></li><li><p>元素：xml文档中的标签</p><ul><li><p>文档中必须有且只能有一个根元素</p></li><li><p>元素需要正确闭合。<code>&lt;body&gt;&lt;/body&gt; &lt;br/&gt;</code></p></li><li>元素需要正确嵌套</li><li>元素名称要遵守：<ul><li>元素名称区分大小写</li><li>数字不能开头</li></ul></li></ul></li><li><p>文本：</p><ul><li>转义字符：<code>&amp;gt;</code>  等价于&gt;</li><li>CDATA: 里边的数据会原样显示<ul><li><code>&lt;![CDATA[ 数据内容 ]]&gt;</code></li></ul></li></ul></li><li><p>属性：</p><ul><li>属性值必须用引号引起来。单双引号都行</li></ul></li><li><p>注释：</p><!-- --></li><li><p>处理指令：现在基本不用<br><code>&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;1.css&quot;?&gt;</code></p></li></ul><ol><li><p>xml约束</p><p>1）、dtd:</p><ul><li>内部dtd：在xml内部定义dtd(了解，一般不自己写)</li></ul></li></ol><ul><li><p>外部dtd：在外部文件中定义dtd<br>​    * 本地dtd文件：<code>&lt;!DOCTYPE students SYSTEM  &quot;student.dtd&quot;&gt;</code></p><ul><li>网络dtd文件：<code>&lt;!DOCTYPE students PUBLIC &quot;名称空间&quot;  &quot;student.dtd&quot;&gt;</code></li></ul><p>2）、schema:</p></li><li><p>导入xsd约束文档：</p><ul><li>编写根标签</li><li>引入实例名称空间 <code>xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</code></li><li>引入名称空间 <code>xsi:schemaLocation=&quot;localhost/xml student.xsd&quot;</code></li><li>引入默认的名称空间</li></ul></li></ul><ol><li>xml解析<ul><li>DOM4J解析</li><li>XPATH(专用于查询)</li></ul></li></ol><h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><ul><li><p>javaEE规范：</p><ul><li>13种技术的总称。<code>Servelet/Jsp</code>、<code>JDBC</code>、<code>JNDI</code>、<code>JTA</code>…</li></ul></li><li><p>常见服务器</p><ul><li><p>WebLogic、WebSphereAS、JbossAS，都支持javaEE规范</p></li><li><p>轻量级Tomcat，支持<code>Servelet/Jsp</code>规范</p></li></ul></li></ul><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><ul><li><p>目录</p><p><img src="/2018/12/10/JavaWeb/JavaWeb基础学习1/目录介绍.jpg" alt=""></p></li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul><li><p>请求</p><p><img src="/2018/12/10/JavaWeb/JavaWeb基础学习1/request.png" alt=""></p><ul><li><p>请求消息行</p><p><code>GET  /index.html?name=lp&amp;pwd=fyd  HTTP/1.1</code></p></li><li><p>请求消息头</p><ul><li>Accept:浏览器可接受的MIME类型(能接收的文件类型)</li><li>Accept-Encoding:浏览器能够进行解码的数据编码方式</li><li>……</li></ul></li><li><p>消息正文</p><p><code>name=lp&amp;pwd=fyd</code></p></li></ul></li><li><p>响应</p><ul><li><p>响应消息行</p><p><code>HTTP/1.1   200   OK</code></p><p>协议/版本   响应状态码  对响应码的描述（一切正常）</p><ul><li><p>200(正常)  一切正常</p></li><li><p>302/307(临时重定向)</p></li><li><p>304(未修改)</p><ul><li>表示客户机缓存的版本是最新的，客户机可以继续使用它，无需到服务器请求。</li></ul></li><li><p>404(找不到)  服务器上不存在客户机所请求的资源。</p></li><li><p>500(服务器内部错误)</p></li></ul></li><li><p>响应消息头</p></li><li><p>响应正文</p></li></ul></li></ul><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>​    servlet 是运行在 Web 服务器中的小型 Java 程序（即：服务器端的小应用程序）<strong>无须手动new</strong>。servlet 通常通过 HTTP（超文本传输协议）接收和响应来自 Web 客户端的请求。</p><ul><li>写一个Java类，实现servlet</li><li>修改web.xml文件，给servlet提供一个可访问的URI地址</li></ul><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><ol><li><p>浏览器   <code>:8080/myWebApp/demo</code></p></li><li><p>tomcat   找到<code>myWebApp</code></p></li><li><p>web.xml  找到<code>/demo</code>后</p></li><li><p>通过<code>&lt;servlet-name&gt;</code>找到对应的<code>.class</code>并实例化(单实例)</p><p>(<code>&lt;load-on-startup&gt;</code>可以启动就实例化，数字表示优先级)</p></li><li><p>调用<code>init()</code></p></li><li><p>调用<code>service()</code>，多线程（来一次请求调用一次）</p></li><li><p>把信息响应给客户端 </p></li><li><p>直到<code>myWebApp</code>被卸载调用<code>destroy()</code></p></li></ol><h3 id="三种创建方式"><a href="#三种创建方式" class="headerlink" title="三种创建方式"></a>三种创建方式</h3><ul><li>实现<code>javax.servlet.Servlet</code>接口</li><li><p>继承<code>javax.servet.GenericServlet</code>类     (适配器模式)</p></li><li><p>继承<code>javax.servlet.http.HttpServlet</code>类（模板方法设计模式）开发使用</p></li></ul><blockquote><p>注意点</p></blockquote><p>如果<code>&lt;url-pattern&gt;</code>的值是/，表示执行默认映射，所有资源都是servlet</p><h3 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h3><p><img src="/2018/12/10/JavaWeb/JavaWeb基础学习1/Servlet核心类.jpg" alt=""></p><h3 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h3><ul><li>获取servlet配置信息<ul><li>法1：重写<code>init</code>方法，获取<code>ServletConfig</code>对象</li><li>法2：通过<code>getServletConfig()</code>方法获取对象</li><li>法3：直接调用父类<code>getInitParameter(key)</code>方法，因为子类没重写该方法this或者super均可。</li></ul></li></ul><blockquote><p><strong>深入分析</strong></p></blockquote><ol><li><code>HttpServlet</code>继承了<code>GenericServlet</code>默认的<code>init(ServletConfig config)</code>方法</li><li><p>该方法实现了抽象类<code>GenericServlet</code>中私有的<code>ServletConfig config</code>的赋值</p></li><li><p>使得<code>HttpServlet</code>的this调用<code>getInitParameter</code>方法能获取到配置信息。</p></li><li><p>所以如果重写了init方法，就会导致this调用失败</p></li></ol><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><p><code>this.getServletContext()</code>代表整个应用。</p><p>一个webApp<strong>只有一个</strong>ServletContext对象（无论多少个用户共用一个），单实例</p><ul><li><p>域对象</p><ul><li>使多个<code>Servlet</code>共享数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name,object value)</span></span>;</span><br><span class="line"><span class="comment">//向ServletContext对象的map中添加数据</span></span><br><span class="line"><span class="function">Object <span class="title">getAttribute</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="comment">//从ServletContext对象的map中取数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rmoveAttribute</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="comment">//根据name去移除数据</span></span><br></pre></td></tr></table></figure></li><li><p>获取全局配置信息</p><p>web.xml（必须是全局，也就是在servlet标签外部的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;UTF-8&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br><span class="line">String encoding = sc.getInitParmeter(<span class="string">"encoding"</span>);</span><br></pre></td></tr></table></figure></li><li><p>获取资源路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc.getRealPath(<span class="string">"/WEB-INF/classes/包名/文件名"</span>);</span><br><span class="line">sc.getRealPath(<span class="string">"/index.jsp"</span>)</span><br></pre></td></tr></table></figure></li><li><p>实现servlet转发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ServletContext sc = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">RequstDispatcher rd = sc.getRequstDispatcher(<span class="string">"/servlet/new"</span>);</span><br><span class="line"><span class="comment">//不需要再加App名的路径,只是app内部的servlet转发</span></span><br><span class="line">rd.forward(request, response);</span><br></pre></td></tr></table></figure></li></ul><h3 id="Req-amp-Res"><a href="#Req-amp-Res" class="headerlink" title="Req &amp; Res"></a>Req &amp; Res</h3><ol><li><code>HttpServletResponse</code></li></ol><ul><li><p>响应行</p></li><li><p>响应头</p><ul><li><p>不缓存</p><p><code>response.setHeader(&quot;cache-control&quot;, &quot;no-cache&quot;)</code></p><p><code>response.setDateHeader(&quot;expires&quot;,0);</code></p></li><li><p>刷新</p><p><code>response.setHeader(&quot;refresh&quot;, &quot;3;url=...&quot;)</code>3秒后刷新到新页面</p></li><li><p>下载文件</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String filename = URLEncoder.encode(文件名, <span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">//告知客户端下载文件</span></span><br><span class="line">response.setHeader(<span class="string">"content-disposition"</span>, <span class="string">"attachment;filename="</span>+filename);</span><br><span class="line">response.setHeader(<span class="string">"content-type"</span>, <span class="string">"image/jpeg"</span>);</span><br></pre></td></tr></table></figure></li><li><p>响应正文</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">response.setCharacterEncoding(<span class="string">"UTF-8"</span>);<span class="comment">//服务器编码</span></span><br><span class="line">response.setHeader(<span class="string">"content-type"</span>, <span class="string">"text/html;charset=UTF-8"</span>);<span class="comment">//告诉浏览器应使用编码</span></span><br><span class="line">response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>)<span class="comment">//一步到位</span></span><br><span class="line"></span><br><span class="line">response.getWriter().write();</span><br><span class="line">response.getOutputStream().write(<span class="string">"str"</span>.getBytes());</span><br></pre></td></tr></table></figure></li><li><p>请求重定向</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">response.setStatus(<span class="number">302</span>);</span><br><span class="line">response.setHeader(<span class="string">"location"</span>, <span class="string">"/myApp/servlet/className"</span>);</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">response.sendRedirect(<span class="string">"/myApp/servlet/className"</span>); </span><br><span class="line"><span class="comment">//重定向之后的代码会继续执行再跳转，可以加个return</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意点</p><ol><li><p><code>getOutputStream</code>和<code>getWriter</code>互相排斥，只能用其一</p></li><li><p>底层分别对应<code>ServletOutputStream</code>和<code>PrintWriter</code></p></li><li>Servlet程序向两个输出流对象写入的数据将被Servlet引擎从<code>response</code>里获取，再将这些当响应消息正文，与行和头组合输出到客户端</li><li>Servlet的<code>service</code>方法结束后，引擎将检查输出流对象是否调用过<code>close()</code>，若未关闭则由引擎来关闭</li></ol></blockquote><ol><li>HttpServletRequest</li></ol><ul><li>请求行</li></ul><p><code>Get  http://localhost:8080/myApp/servlet/main?username=lp  http/1.1</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getMethod</span><span class="params">()</span></span>; <span class="comment">//获得请求方式 GET</span></span><br><span class="line"><span class="function">String <span class="title">getRequestURL</span><span class="params">()</span></span>;<span class="comment">//返回客户端发出请求时的完整URL。</span></span><br><span class="line"><span class="function">String <span class="title">getRequestURI</span><span class="params">()</span></span>; <span class="comment">//返回请求行中的资源名部分。</span></span><br><span class="line"><span class="function">String <span class="title">getContextPath</span><span class="params">()</span></span>; <span class="comment">//当前应用的虚拟目录    /my (重要)</span></span><br><span class="line"><span class="function">String <span class="title">getQueryString</span><span class="params">()</span> </span>; <span class="comment">//返回请求行中的参数部分   username=lp</span></span><br></pre></td></tr></table></figure><ul><li>请求消息头</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getHeader</span><span class="params">(String name)</span>  <span class="comment">//根据头名称得到头信息值</span></span></span><br><span class="line"><span class="function">Enumeration <span class="title">getHeaderNames</span><span class="params">()</span>  <span class="comment">//得到所有头信息name</span></span></span><br><span class="line"><span class="function">Enumeration <span class="title">getHeaders</span><span class="params">(String name)</span><span class="comment">//根据头名称得到相同名称头信息值</span></span></span><br></pre></td></tr></table></figure><ul><li>请求正文</li></ul><blockquote><p>切记：告诉服务端解析请求的编码方式</p></blockquote><p><code>req.setCharacterEncoding(&quot;UTF-8&quot;);</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> name=<span class="string">"username"</span> /&gt;</span><br><span class="line"><span class="function">String <span class="title">getParameter</span><span class="params">(name)</span> <span class="comment">//根据表单中name属性的名，获取value</span></span></span><br><span class="line"><span class="function">String <span class="title">getParameterValues</span><span class="params">(String name)</span><span class="comment">//专业为复选框取取提供的方法</span></span></span><br><span class="line"><span class="function">Enumeration <span class="title">getParameterNames</span><span class="params">()</span> <span class="comment">//得到表单提交的所有name的方法 </span></span></span><br><span class="line"><span class="function">Map&lt;String, String[]&gt; getParameterMap </span></span><br><span class="line"><span class="function"><span class="comment">//到表单提交的所有值的方法  (做框架用)非常实用</span></span></span><br><span class="line"><span class="function">getInputStream  <span class="comment">//以字节流的方式得到所有表单数据</span></span></span><br></pre></td></tr></table></figure><ul><li>请求转发</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">req.setAttribute(<span class="string">"newKey"</span>, <span class="string">"newData"</span>);<span class="comment">//2次包装，转发</span></span><br><span class="line">req.getAttribute(<span class="string">"newKey"</span>);<span class="comment">//必须set过的，表单提交的无法获取</span></span><br><span class="line">req.removeAttribute(<span class="string">"newKey"</span>);        </span><br><span class="line">req.getRequstDispatcher(<span class="string">"/servlet/new"</span>).foward(req, resp);</span><br><span class="line"><span class="comment">//转发处理完会回来继续执行原servlet未执行的语句</span></span><br><span class="line">    <span class="comment">//请求包含</span></span><br><span class="line">req.getRequstDispatcher(<span class="string">"/servlet/new"</span>).include(req, resp);</span><br><span class="line"><span class="comment">//与转发的区别</span></span><br><span class="line"><span class="number">1</span>.如果Aservlet请求BServlet那么A中最好不要在添加响应体，否则导致的结果即是两种，但是添加响应头是可以的（就是“留头不留体”）</span><br><span class="line"><span class="number">1</span>）数据被清空，不会发送到客户端。</span><br><span class="line"><span class="number">2</span>）数据已提交但是在转发时出现异常。</span><br></pre></td></tr></table></figure><blockquote><p>转发和包含的区别</p></blockquote><ul><li><p>转发</p><p>如果Aservlet请求BServlet那么A中最好不要在添加响应体，否则导致的结果即是两种，但是添加响应头是可以的（就是“<strong>留头不留体</strong>”）</p><ul><li>数据被清空，不会发送到客户端。</li><li>数据已提交但是在转发时出现异常。</li></ul></li><li><p>包含</p><p><strong>留头又留体</strong>，由两个Servlet共同完成响应。</p></li></ul><blockquote><p>转发和重定向的区别</p></blockquote><ul><li><p>转发</p><ul><li>转发request 由服务器执行</li><li>客户端只发送一次请求</li><li>地址栏不变</li><li>转发能传递数据</li><li>转发不可跳转其他应用，只能在本应用下的资源</li><li>转发也是一个域对象（当前应用，多个servlet共享）</li><li>要么是Get要么是Post</li></ul></li><li><p>重定向</p><ul><li>重定向response 由客户端执行</li><li>客户端发送2次请求</li><li>地址栏会变</li><li>不能传递数据</li><li>可跳转到其他应用</li><li>一定是Get</li></ul></li></ul><h3 id="Cookie-amp-Session"><a href="#Cookie-amp-Session" class="headerlink" title="Cookie&amp;Session"></a>Cookie&amp;Session</h3><ol><li><p>Cookie</p><p>由于Cookie数据是由客户端来保存和携带的，所以称之为<strong>客户端技术</strong></p></li></ol><ul><li>小案例：上次访问时间</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">req.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">resp.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">PrintWriter out = resp.getWriter();</span><br><span class="line"><span class="comment">//获取当前path下的所有Cookie</span></span><br><span class="line">Cookie[] cookies = req.getCookies();</span><br><span class="line"><span class="keyword">if</span>(cookies != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Cookie ck : cookies) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"lastTime"</span>.equals(ck.getName())) &#123;</span><br><span class="line">            out.print(<span class="string">"上次访问时间为："</span> + <span class="keyword">new</span>                   Date(Long.parseLong(ck.getValue())).toLocaleString());</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置Cookie</span></span><br><span class="line">Cookie ck = <span class="keyword">new</span> Cookie(<span class="string">"lastTime"</span>, System.currentTimeMillis()+<span class="string">""</span>);</span><br><span class="line"><span class="comment">//持久化5min存到磁盘</span></span><br><span class="line">ck.setMaxAge(<span class="number">60</span>*<span class="number">5</span>); </span><br><span class="line">ck.setPath(<span class="string">"/myApp"</span>);</span><br><span class="line">ck.setPath(req.getContextPath())<span class="comment">//同上，当前App下共享Cookie</span></span><br><span class="line">ck.setPath(<span class="string">"/"</span>) <span class="comment">//直接把服务器上的所有应用共享Cookie</span></span><br><span class="line">resp.addCookie(ck);</span><br></pre></td></tr></table></figure><ul><li><p>属性</p><ul><li><p>name：名称不能唯一确定一个Cookie。因为路径可能不同。</p></li><li><p>value：能存中文。注意考虑编码的一致性</p></li><li><p>path：默认值是写Cookie的那个程序的访问路径</p><p><code>http://localhost:8080/myApp/servlet/ck1</code>写的Cookie</p><ul><li>path就是：<code>/myApp/servlet/</code></li><li>客户端在访问服务器另外资源时，根据访问的路径来决定是否带着Cookie到服务器</li><li>当前访问的路径如果是以Cookie的path开头的路径，浏览器就带。否则不带。例如<code>/myApp/servlet/1path/2path</code>可访问，而<code>/myApp/</code>不行，可以通过<code>setPath()</code>方式解决。</li></ul></li><li><p>maxAge：Cookie的缓存时间。默认是-1（默认存在浏览器的内存中）。单位是秒。</p><ul><li><p>负数：cookie的数据存在浏览器缓存中</p></li><li><p>0：删除。路径要保持一致，否则可能删错人。</p></li><li><p>正数：缓存（持久化到磁盘上）的时间</p></li></ul></li></ul></li><li><p>相关细节</p><ul><li><p>一个Cookie只能标识一种信息</p></li><li><p>浏览器一般只允许存放300个Cookie，每个站点最多存放20个，每个限制为4KB</p></li><li><p>如果创建了一个Cookie，并将它发送到浏览器</p><ul><li><p>默认情况下是一个会话级别的（即存储在浏览器内存中），用户退出浏览器则被删除。</p></li><li><p>若希望持久化存储到磁盘，则需要使用<code>maxAge</code>。</p></li></ul></li><li><p>删除Cookie时，path必须一致，否则无法删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cookie ck = <span class="keyword">new</span> Cookie(<span class="string">"lastTime"</span>, <span class="string">""</span>);</span><br><span class="line">ck.setPath(<span class="string">"/myApp"</span>);</span><br><span class="line">ck.setMaxAge(<span class="number">0</span>); </span><br><span class="line">resp.addCookie(ck);</span><br></pre></td></tr></table></figure></li></ul></li></ul><ol><li><p>Session</p><p>​    服务器为每个用户浏览器创一个Session对象，<strong>一个浏览器独占一个Session</strong>。因此，在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的Session。当用户浏览器访问当前App下其他程序，获取该Session。</p></li></ol><ul><li><p>特点</p><ul><li>同一个会话下<strong>，可以使一个应用的</strong>多个资源共享数据</li><li>cookie客户端技术，只能存字符串。HttpSession服务器端的技术，它可以存对象。</li></ul></li><li><p>原理</p><ul><li>服务器获取名称为<code>JSESSIONID</code>的Cookie的值。</li><li>若无该Cookie，创建一个新的HttpSession对象，分配一个唯一的<code>SessionID</code>，并保存在B的cookie中<code>JSESSIONID:1023</code>。</li><li>有这样的Cookie，获取cookie的值（即HttpSession对象的值），从服务器的内存中根据ID找那个HttpSession对象</li></ul></li><li><p>常用API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name,Object value)</span></span>;</span><br><span class="line"><span class="function">Object <span class="title">getAttribute</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String name)</span></span>;</span><br><span class="line">HttpSession.getId():</span><br><span class="line">setMaxInactiveInterval(<span class="keyword">int</span> interval)  设置session的存活时间</span><br><span class="line">invalidate() 使此会话无效</span><br></pre></td></tr></table></figure></li><li><p>状态</p><ul><li><p>创建</p></li><li><p>销毁</p><ul><li>强制：<code>invalidate()</code></li><li><p>超时：<code>setMaxInactiveInterval</code>（默认30min）</p></li><li><p>xml中设置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置有效时间min --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>1<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>序列化</p><p>​    当内存溢出，服务器重启等，tomcat会把HttpSession持久化到本地，记得对应类要实现<code>serializable</code>接口（钝化-搁置）    </p><p>​    等重启后（活化-激活）</p></li></ul></li></ul><blockquote><p>当禁用cookie</p></blockquote><ol><li><p><code>request.getSession();</code>必须写。</p></li><li><p><code>response.encodeURL(String url);</code></p><p>返回的url： <code>http://url;JSESSIONID=111</code></p></li></ol><h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><p>JSP<strong>本质</strong>就是Servlet。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol><li><p>浏览器访问jsp页面，服务器是如何调用执行jsp页面？（Servlet）</p><ul><li><p>tomcat定位到<code>/myWebApp</code>项目</p></li><li><p>服务器把<code>index.jsp</code>转译成<code>index_jsp.java</code>，继而编译成<code>.class</code>文件</p><p>（故而第二次访问会快很多，由于已经编译好）</p></li></ul></li><li><p>web服务器在执行jsp页面时，如何把页面中html发送给客户端，以及执行Java代码？</p><ul><li>在转译后的<code>.java</code>文件，<code>out.write(&quot;&lt;html&gt;\r\n&quot;)</code>，就像原生返回字符串一样返回。</li><li>java代码原样执行</li></ul></li></ol><h3 id="编写原则"><a href="#编写原则" class="headerlink" title="编写原则"></a>编写原则</h3><ul><li><p>Servlet：重点编写java代码逻辑 （获取表单数据、处理业务逻辑、分发转向）</p></li><li><p>JSP：代码显示模板。重点在于显示数据</p></li></ul><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul><li><p>模板元素即html</p></li><li><p>脚本</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;% code %&gt;</span><br><span class="line">&lt;%=<span class="number">2</span>+<span class="number">3</span>%&gt; 等价于 out.print(<span class="number">2</span>+<span class="number">3</span>)</span><br><span class="line">&lt;%! %&gt; 表示在类中定义全局成员，和静态块</span><br><span class="line"></span><br><span class="line">&lt;%-- 被注释内容 --%&gt; 安全，省流量</span><br><span class="line">&lt;!--html注释 --&gt;  用户看的到不安全</span><br></pre></td></tr></table></figure></li><li><p>3指令 (告诉jsp引擎如何处理jsp页面中其余部分)</p><ul><li>page</li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span>  pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br></pre></td></tr></table></figure><ul><li><p>include</p><ul><li><p>静态包含</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ include file=<span class="string">"/include/header.jsp"</span> %&gt;</span><br></pre></td></tr></table></figure></li><li><p>动态包含</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include page="/include/header.jsp"&gt;&lt;/jsp:include&gt;</span><br></pre></td></tr></table></figure><blockquote><p>区别：翻译的时间段不同</p></blockquote><p>前者：在翻译时就把两个文件合并</p><p>后者：不会合并文件，当代码执行到include时，才包含另一个文件的内容。</p><p>原则：能用静的就不用动的。</p></li></ul></li><li><p>tablib</p><p>作用：在JSP页面中导入JSTL标签库。替换jsp中的java代码片段。</p></li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> prefix=<span class="string">"别名"</span> %&gt;</span><br></pre></td></tr></table></figure></li><li><p>6个动作</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include &gt; 动态包含</span><br><span class="line">&lt;jsp:forward&gt; 请求转发</span><br><span class="line">&lt;jsp:param&gt; 设置请求参数</span><br><span class="line"></span><br><span class="line">&lt;jsp:useBean&gt; 创建一个对象</span><br><span class="line">&lt;jsp:setProperty&gt; 给指定的对象属性赋值</span><br><span class="line">&lt;jsp:getProperty&gt; 取出指定对象的属性值</span><br></pre></td></tr></table></figure></li><li><p>9大内置对象</p><p> 在&lt;%=%&gt; &lt;% %&gt;内部直接使用的对象</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">对象名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left">request</td><td>javax.servlet.http.HttpServletRequest</td><td></td></tr><tr><td style="text-align:left">response</td><td>…HttpServletResponse</td><td></td></tr><tr><td style="text-align:left">session</td><td>…HttpSession</td><td>由session=”true”开关</td></tr><tr><td style="text-align:left">application</td><td>javax.servlet.ServletContext</td><td></td></tr><tr><td style="text-align:left">exception</td><td>java.lang.Throwable</td><td>由isErrorPage=”false”开关</td></tr><tr><td style="text-align:left">page</td><td>java.lang.Object当前对象this</td><td>当前servlet实例</td></tr><tr><td style="text-align:left">config</td><td>javax.servlet.ServletConfig</td><td></td></tr><tr><td style="text-align:left">out</td><td>javax.servlet.jsp.JspWriter</td><td>printWriter对象</td></tr><tr><td style="text-align:left">pageContext</td><td>javax.servlet.jsp.PageContext</td></tr></tbody></table></div><p>pageContext(重要)</p><ol><li><p>本身也是一个域对象：它可以操作其它三个域对象（request session application）的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">findAttribute(String name); </span><br><span class="line"><span class="comment">//自动从page request session application依次查找，找到了就取值，结束查找。</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><p><code>PageContext</code> :  存放的数据在当前页面有效。开发时使用较少。</p></li><li><p><code>ServletRequest</code>: 存放的数据在一次请求（转发）内有效。使用非常多。</p></li><li><p><code>HttpSession</code>: 存放的数据在一次会话中有效。使用的比较多。如：存放用户的登录信息，购物车功能。</p></li><li><p><code>ServletContext</code>: 存放的数据在整个应用范围内都有效。因为范围太大，应尽量少用。</p></li></ul><ol><li><p>它可以创建其它的8个隐式对象</p><p>在普通类中可以通过PageContext获取其他JSP隐式对象。自定义标签时就使用。</p></li><li><p>提供了的简易方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pageContext.forward(<span class="string">"2.jsp"</span>);</span><br><span class="line">pageContext.include(<span class="string">"2.jsp"</span>);</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>附加：简化java代码</p></blockquote><ul><li><p>EL表达式：</p><p>要简化jsp中java代码开发。它不是一种开发语言，是jsp中<strong>获取数据</strong>的一种规范</p></li><li><p>JSTL：JSP标准标签库</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XML语言 </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>shell编程</title>
      <link href="/2018/12/01/Linux/Shell/"/>
      <url>/2018/12/01/Linux/Shell/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p>bash、变量、shell编程</p></blockquote><p><img src="https://image-link.nos-eastchina1.126.net/shell"></p><a id="more"></a><h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><p>命令行解释器，提供给user一个向Linux内核发送请求以便执行对应任务的工具</p><ul><li><p>分类</p><p>Bourne Shell：sh、ksh、<strong>Bash</strong>、psh、zsh</p><p>C Shell（BSD版的Unix中）：csh、tcsh</p></li><li><p>执行</p><ul><li><p>直接运行</p><p>chmod  755  hello.sh</p><p>./hello.sh</p></li><li><p>Bash调用执行</p><p>bash  hello.sh </p></li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash     (若调用其他语言，这行不要省略)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注释</span></span><br><span class="line">echo -e "\e[1;31m text \e[0m"          </span><br><span class="line"><span class="meta">#</span><span class="bash">31m=红色     32m=绿色    33m=黄色</span></span><br></pre></td></tr></table></figure><h2 id="bash中基本功能"><a href="#bash中基本功能" class="headerlink" title="bash中基本功能"></a>bash中基本功能</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1.别名</span></span><br><span class="line">alias ls='ls --color=auto' </span><br><span class="line"><span class="meta">#</span><span class="bash">设定别名，临时生效  </span></span><br><span class="line"><span class="meta">#</span><span class="bash">永久，写入环境变量配置文件 ~/.bashrc   再souce重新加载配置文件生效，不然要重启</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">2.历史</span></span><br><span class="line">history -c:清空历史命令</span><br><span class="line">-w:把缓存中历史命令写入~/.bash_history</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">3.输出重定向</span></span><br><span class="line">命令 &amp;&gt;文件  #覆盖方式全都写到文件中</span><br><span class="line">命令 &gt;&gt; 文件1  2&gt;&gt;文件2 #正确追加到文件1，错误输出追加到文件2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">4.多命令执行</span></span><br><span class="line">date ; 处理 ; date #可以用来看处理时间  可以配合&amp;&amp; ||</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">5.通配符</span></span><br><span class="line">*  ?  [0-9]   [^0-9]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">6.Bash中其他特殊符号</span></span><br><span class="line">'' #单引号中所有特殊字符都没特殊含义</span><br><span class="line">"" #双引号中，$调用变量   `引用命令  \转义符</span><br><span class="line"><span class="meta">$</span><span class="bash">() &lt;=&gt; `` 等价于反引号执行系统命令   $取变量值</span></span><br></pre></td></tr></table></figure><h2 id="Bash变量与变量分类"><a href="#Bash变量与变量分类" class="headerlink" title="Bash变量与变量分类"></a>Bash变量与变量分类</h2><p>bash中变量存的所有类型（string,number,date等）都是字符串类型</p><h3 id="用户自定义变量"><a href="#用户自定义变量" class="headerlink" title="用户自定义变量"></a>用户自定义变量</h3><ul><li>只在当前shell有效</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name="lai ping"   #  =不能有空格，否则当命令解析错误</span><br><span class="line">name="$name"456   #  变量叠加  name=lai ping456</span><br><span class="line">set  #  查询系统下所有变量  -u  可以用提示，调用未定义的变量，默认无</span><br><span class="line">unset name      # 删除变量</span><br></pre></td></tr></table></figure><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>全局变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export x=1  #设置环境变量</span><br><span class="line">set #查看所有变量(当前shell局部和全局)</span><br><span class="line">env #查看环境变量</span><br></pre></td></tr></table></figure><p>常用环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SHELL:当前</span><br><span class="line">TERM:终端环境</span><br><span class="line">PATH:PATH环境变量  系统查找命令的路径</span><br><span class="line"></span><br><span class="line">PATH="$PATH":/root/sh  #增加PATH变量的值</span><br></pre></td></tr></table></figure><h3 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h3><ul><li>$n：n为数字，0代表命令本身，1-9代表第1到9个参数，10以上参数需要 {10}</li><li>$*：命令行所有参数，把所有参数看做一个整体</li><li>$@：所有参数，把每个参数区分对待，for循环体现区别</li><li>$#：所有参数个数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">num1=$1</span><br><span class="line">num2=$2</span><br><span class="line">sum=$(($num1+$num2))</span><br><span class="line">echo $sum</span><br><span class="line"></span><br><span class="line">./sum.sh 12 2434</span><br></pre></td></tr></table></figure><h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><ul><li>$?：最后一次执行的命令的返回状态。若为0，证明上个命令正确执行</li><li>$$：当前进程的进程号（PID）</li><li>$!：后台运行最后一个进程的进程号</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>declare [+/-] 选项  变量名   </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">declare -i c  #定义c为整型变量 </span><br><span class="line">declare -x MYPATH #等价于 export MYPATH</span><br></pre></td></tr></table></figure><p>$((运算式))</p><p>变量测试在脚本优化时用</p><h2 id="环境变量配置文件"><a href="#环境变量配置文件" class="headerlink" title="环境变量配置文件"></a>环境变量配置文件</h2><ul><li><p>简介</p><ul><li>主要是定义对系统的操作环境生效的系统默认环境变量，如PATH、HISTSIZE、PS1、HOSTNAME等默认环境变量。</li></ul></li><li><p>source 配置文件 或 . 配置文件</p><ul><li>配置文件生效，不用重启</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/profile</span><br><span class="line">/etc/profile.d/*.sh</span><br><span class="line">~/.bash_profile</span><br><span class="line">~/.bashrc  </span><br><span class="line">/etc/bashrc</span><br></pre></td></tr></table></figure><ul><li>登录调用顺序</li></ul><p>/etc/profile →  ~/.bash_profile →  ~/.bashrc →  /etc/bashrc  →  命令提示符</p><p>​           ↓                                    (区分no login 即切换子shell)</p><p>/etc/profile.d/*.sh</p><p>​           ↓</p><p>/etc/profile.d/lang.sh  →   /etc/sysc config/i18n（语言）</p><p>(区分no login就是切换子shell) </p><ul><li>其他配置文件<ul><li>~/.bash_logout：  注销生效</li><li>~/.bash_history：  当前的会在history,注销才写入</li><li>/etc/issue： 本地终端登录信息 issue.net 远程登录</li></ul></li></ul><h2 id="Shell-编程"><a href="#Shell-编程" class="headerlink" title="Shell 编程"></a>Shell 编程</h2><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><ul><li><p>把本来输出到屏幕到重定向到文件</p><ul><li>/dev/stdout  1 正确  </li><li>/dev/stderr   2 错误</li></ul></li><li><p>用来管理错误日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">错误命令  2&gt;&gt;err.log</span><br><span class="line"></span><br><span class="line">命令 &gt;&gt; 文件 2&gt;1&amp; <span class="comment">#追加方式，正确错误都保存到文件</span></span><br><span class="line">命令 &amp;&gt;&gt;文件   <span class="comment">#同上功能</span></span><br><span class="line">    &amp;&gt;/dev/null <span class="comment">#丢弃</span></span><br><span class="line">命令 &gt;&gt;文件1 2&gt;&gt;文件2 <span class="comment">#正确1 错误2</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><ul><li><p>与通配符区别</p><ul><li>正则是文件中匹配符合条件的<strong>字符串</strong>，包含匹配。grep、awk、sed等</li><li>通配符（*, ?）是匹配条件的<strong>文件名</strong>，完全匹配。ls、find、cp</li></ul></li><li><p>常见</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">*  前一个字符匹配0次或任意多次  <span class="string">"a*"</span> 匹配所有，无意义</span><br><span class="line">.    匹配任意一个字符</span><br><span class="line">^匹配行首<span class="string">"^$"</span> 空白行</span><br><span class="line">$匹配行尾</span><br><span class="line">[]一个字符</span><br><span class="line">[^]</span><br><span class="line">\转义 (一部分必须转义才能表示、一部分转义后有特殊含义或功能)</span><br><span class="line">\+      1次或多次</span><br><span class="line">\?零次或一次</span><br><span class="line">\&#123;n\&#125;表示其前面字符恰好n次</span><br><span class="line">\&#123;n,\&#125;</span><br><span class="line">\&#123;n,m\&#125;</span><br></pre></td></tr></table></figure><h3 id="字符截取命令"><a href="#字符截取命令" class="headerlink" title="字符截取命令"></a>字符截取命令</h3><ul><li>cut<ul><li>提取一行中某个字段，与grep搭配使用</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#格式</span></span><br><span class="line">cut -f(列号) 1,3  -d(分隔符,默认是tab) <span class="string">":"</span>    <span class="comment"># 第1列内容:第3列内容</span></span><br><span class="line"><span class="comment">#案例 （提取自添加用户名）</span></span><br><span class="line">cat /etc/passwd | grep /bin/bash | grep -v(取反) root | cut -d <span class="string">":"</span> -f 1</span><br></pre></td></tr></table></figure><ul><li>printf （在awk中用，一般就用cat、echo）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#很像C语言</span></span><br><span class="line">%ns   <span class="comment">#n表示输出几个字符</span></span><br><span class="line">%ni  <span class="comment">#n输出几个数字</span></span><br><span class="line">%m.nf <span class="comment">#m整数位数，n小数位数</span></span><br></pre></td></tr></table></figure><ul><li><p>awk （比cut强大多、复杂）</p></li><li><p>sed（重点★）</p><ul><li>轻量级流编辑器。对数据进行选取、替换、删除、新增的命令</li><li>相比于vi，不光可以修改文件内容，还可以直接修改命令结果</li></ul><p>格式：</p><p>​    <code>sed [option] &#39;[action]&#39; 文件名</code></p><ul><li>option:<ul><li>-n       一般sed命令输出所有数据。此处会把经过sed处理的行输出到屏幕</li><li>-e       允许对输入数据应用多条sed编辑</li><li>-i        用sed的修改结果直接修改读取数据的文件，而不是输出到屏幕        </li></ul></li><li>action:<ul><li>a \       追加， 在当前行后添加一行或多行。添加多行，除最后一行，每行末尾需要用<code>&quot;\&quot;</code>代表数据未完结。</li><li>c \     行替换，用c后面的字符串替换原数据行，替换多行时………同上</li><li>i \     插入，在当期行前插入一行或多行。插入多行………同上</li><li>d     删除，删除指定行</li><li>p    打印，输出指定的行</li><li>s    字串替换，用一个字符串替换另一个字符串。</li></ul></li></ul></li></ul><p>​            格式为<code>&quot;行范围s/旧字串/新字串/g&quot;</code></p><p>​          （ /g表示一行中<strong>所有</strong>匹配到的，不加则为第一次匹配到的）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'2p'</span> file  <span class="comment">#打印输出第2行</span></span><br><span class="line">sed <span class="string">'2,4d'</span> file <span class="comment">#删除第2到4行   $表示最后行</span></span><br><span class="line">sed <span class="string">'/2/d'</span> test.txt     <span class="comment">#sed中正则用/.../中间</span></span><br><span class="line">sed <span class="string">'2a hello'</span> file  <span class="comment">#在第二行后追加hello</span></span><br><span class="line">sed <span class="string">'2i hello\</span></span><br><span class="line"><span class="string">world'</span> file <span class="comment">#在第二行前插入两行数据(hello\nworld)</span></span><br><span class="line">sed <span class="string">'2c no such p'</span> file</span><br><span class="line">sed -i <span class="string">'4s/99/55/g'</span> file     <span class="comment">#把第4行的99改为55</span></span><br><span class="line">sed -e <span class="string">'s/lp//g;s/fyd//g'</span> file <span class="comment">#同时吧"lp"和"fyd"替换为空</span></span><br></pre></td></tr></table></figure><h3 id="字符处理命令"><a href="#字符处理命令" class="headerlink" title="字符处理命令"></a>字符处理命令</h3><ul><li><p>排序命令sort</p><ul><li><p>-f  忽略大小写</p></li><li><p>-n  以数值型进行排序，默认用字符串排序</p></li><li><p>-r   反向排序</p></li><li><p>-t    指定分隔符，默认是制表符</p></li><li><p>-k n[,m] 按照执行的字段范围排序。从第n字段开始，m字段结束（默认到行尾）</p></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort -n -t <span class="string">":"</span> -k 3,3 /etc/passwd <span class="comment">#用:分割后第三个字段按数值大小排序</span></span><br></pre></td></tr></table></figure><ul><li><p>统计命令wc</p><ul><li><p>-l   只统计行数</p></li><li><p>-w 只统计单词数</p></li><li><p>-m 只统计字符数</p></li></ul></li></ul><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><ul><li>符号<code>[]</code></li></ul><ol><li>按照文件类型进行判断</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-d  <span class="comment">#判断该文件是否存在，并且是否为目录</span></span><br><span class="line">-e  <span class="comment">#判断该文件是否存在</span></span><br><span class="line">-f  <span class="comment">#判断该文件是否存在，并且是否为普通文件</span></span><br><span class="line"><span class="built_in">test</span> -e file</span><br><span class="line">[ -e file ]   <span class="comment">#两种方式等价  echo $?判断</span></span><br><span class="line">[ -d file ] &amp;&amp; <span class="built_in">echo</span> <span class="string">'yes'</span> || <span class="built_in">echo</span> <span class="string">"no"</span>  <span class="comment">#不用手工判断</span></span><br></pre></td></tr></table></figure><ol><li><p>判断文件权限</p><ul><li>-r</li><li>-w</li><li>-x</li></ul></li><li><p>两个文件之间进行比较</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">文件1 -nt 文件2 <span class="comment">#判断文件1修改时间是否比文件2新</span></span><br><span class="line">-ot <span class="comment">#比谁旧</span></span><br><span class="line">-ef <span class="comment">#判断Inode号一致，两个文件是否为同一个文件。用于判断硬链接(Inode号一致)</span></span><br></pre></td></tr></table></figure><ol><li>两个整数之间比较</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-eq=</span><br><span class="line">-ne!=</span><br><span class="line">-gt&gt;</span><br><span class="line">-lt&lt;</span><br><span class="line">-ge&gt;=</span><br><span class="line">-le   &lt;=</span><br></pre></td></tr></table></figure><ol><li>字符串判断</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-z<span class="comment">#判断字符串是否为空</span></span><br><span class="line">-n<span class="comment">#非空</span></span><br><span class="line">==</span><br><span class="line">!=</span><br></pre></td></tr></table></figure><ol><li>多重条件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">判断1 -a 判断2<span class="comment">#与</span></span><br><span class="line">-o<span class="comment">#或</span></span><br><span class="line">!<span class="comment">#非</span></span><br></pre></td></tr></table></figure><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 条件判断 ];<span class="keyword">then</span></span><br><span class="line">code</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">或者</span><br><span class="line"><span class="keyword">if</span> [ 条件判断 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">code</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#双分支</span></span><br><span class="line"><span class="keyword">if</span> [ 条件判断 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">success</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    fail</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#多分支</span></span><br><span class="line"><span class="keyword">if</span> [ 条件1 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="keyword">elif</span> [ 条件2 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ul><li><p>案例1 备份</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">date=$(date +\%y\%m\%d) <span class="comment">#百分号必须转义，不然在定时任务中会到其内定含义</span></span><br><span class="line">size=$(du -sh 需要备份的文件夹)</span><br><span class="line"><span class="keyword">if</span> [ -d /tmp/backup ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Date : <span class="variable">$date</span>!"</span> &gt; /tmp/backup/info.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Data size: <span class="variable">$size</span>"</span> &gt;&gt; /tmp/backup/info.txt</span><br><span class="line"><span class="built_in">cd</span> /tmp/backup</span><br><span class="line">tar -zcf  backupDB_<span class="variable">$date</span>.tar.gz  /etc /tmp/backup/info.txt &amp;&gt;/dev/null</span><br><span class="line">rm -rf /tmp/backup/info.txt</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    mkdir /tmp/backup</span><br><span class="line">    同上</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li><li><p>案例2 判断用户输入 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"please input a filename:"</span> -t 3 file <span class="comment">#3s内输入</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$file</span>"</span> ] <span class="comment">#空</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"error, null"</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">elif</span> [ ! -e <span class="string">"<span class="variable">$file</span>"</span> ] <span class="comment">#是否存在</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"file not exist"</span></span><br><span class="line"><span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">elif</span> [ -d <span class="string">"<span class="variable">$file</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"file is a directory"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="case"><a href="#case" class="headerlink" title="case"></a>case</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> $变量名 <span class="keyword">in</span></span><br><span class="line"><span class="string">"值1"</span>)</span><br><span class="line">;;</span><br><span class="line"><span class="string">"值2"</span>)</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><ul><li><p>格式1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量名 <span class="keyword">in</span> 值1 值2 值3...</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">$变量名</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ul><li>案例：批量解压缩</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/lp</span><br><span class="line">ls *.tar.gz &gt; ls.log</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(cat ls.log)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">tar -zxf <span class="variable">$i</span> &amp;&gt;/dev/null</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">rm -rf ~/lp/ls.log</span><br></pre></td></tr></table></figure></li><li><p>格式2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>((初始;条件;))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="comment">#todo:</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="while和until"><a href="#while和until" class="headerlink" title="while和until"></a>while和until</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ 条件 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="comment">#todo:</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">until [ 条件 ]  <span class="comment">#到条件退出循环</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="comment">#todo:</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><h4 id="crontab设置"><a href="#crontab设置" class="headerlink" title="crontab设置"></a>crontab设置</h4><ul><li><p>前提：crond服务默认自启动</p></li><li><p>用法</p><ul><li>-e         编辑定时任务</li><li>-l              查询任务</li><li>-r              删除当前用户所有的任务</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line"><span class="comment">#进入vim编辑工作</span></span><br><span class="line">* * * * * 执行的任务</span><br><span class="line">一小时当中第几分   0-59</span><br><span class="line">一天中第几小时   0-23</span><br><span class="line">一月中第几天    1-31</span><br><span class="line">一年中第几月1-12</span><br><span class="line">一周中星期几0-7(0、7都代表星期日)</span><br><span class="line">* 任何时间</span><br><span class="line">，不连续时间  0 8,12,16 * * * <span class="comment">#每天8、12、16时</span></span><br><span class="line">- 连续时间</span><br><span class="line">*/n每隔多久</span><br></pre></td></tr></table></figure></li></ul><h3 id="单机备份"><a href="#单机备份" class="headerlink" title="单机备份"></a>单机备份</h3><ul><li><p>前提</p><ul><li><code>yum -y install dump</code></li></ul></li><li><p>备份目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dump -oj -f ~/myBakup.dump.bz2  待备份的目录</span><br><span class="line"><span class="comment">#目录只能用0级别完全备份</span></span><br><span class="line"></span><br><span class="line">cat /etc/dumpdatas <span class="comment">#查看备份时间文件</span></span><br></pre></td></tr></table></figure></li><li><p>恢复</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restore -r -f ~/myBakup.dump.bz2  <span class="comment">#恢复到当前目录</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mood</title>
      <link href="/2018/11/26/mood/"/>
      <url>/2018/11/26/mood/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p>Java (基础、并发、虚拟机)<br>JavaWeb (基础、TCP/IP、HTTP)<br>Mysql (事务、锁、ORM、索引)<br>数据结构和算法、 设计模式<br>Spring等框架、分布式、Linux基础<br>走 了 好 多 弯 路， 不 过 谁 不 是 这 么 过 来 的 呢💪🏻</p></blockquote>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Git 操作小结</title>
      <link href="/2018/06/24/git%E6%93%8D%E4%BD%9C%E5%B0%8F%E7%BB%93/"/>
      <url>/2018/06/24/git%E6%93%8D%E4%BD%9C%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="git提交代码"><a href="#git提交代码" class="headerlink" title="git提交代码"></a>git提交代码</h2><ol><li>可以先pull的情况</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#该方法适合远端代码和你当前的(包括未add或者已add未commit)进行比较</span></span><br><span class="line">git pull  <span class="comment">#若无冲突，可直接merge</span></span><br><span class="line">git commit -a -m <span class="string">"message"</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><ol><li>无法先pull（即存在冲突）方案一：推荐</li></ol><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git stash <span class="comment">#把当前的所有修改暂存下来，此时status会恢复到最初干净的状态</span></span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line">git stash pop <span class="comment">#把暂存区的修改恢复出来，并且冲突的地方会标记出来，待手动修改</span></span><br><span class="line">git stash apply stash@&#123;0&#125; <span class="comment">#上面这样恢复若无冲突和自动删除stash记录，而这个不会</span></span><br><span class="line"></span><br><span class="line">git commit -a -m <span class="string">"message"</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>附加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git stash list <span class="comment">#查看暂存的内容列表(包含在哪条分支上的暂存)</span></span><br><span class="line"><span class="comment">#如果使用git stash pop 不加名，则恢复最近一条记录，哪怕是mybranch上的内容也会被恢复到master。(若无冲突，会吧list中记录删除，若冲突则需冲动删除)</span></span><br><span class="line">git stash clear <span class="comment">#清空所有内容</span></span><br><span class="line">git stash drop stash@&#123;0&#125;<span class="comment">#删除第一个队列，不加默认删除编号为0</span></span><br></pre></td></tr></table></figure><ol><li>无法先pull（即存在冲突）方案二（缺点：需要提交2次，有时并不想提交）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m <span class="string">"messgae1"</span></span><br><span class="line">git pull <span class="comment">#此时冲突处会标记出来，手动解决冲突</span></span><br><span class="line">git commit -a -m <span class="string">"messgae2"</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h2 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --all <span class="comment">#查看所有分支情况，包括本地和远端</span></span><br></pre></td></tr></table></figure><p>无论在主分支，或者其他分支上修改了东西，但是未commit，切换分支时，会<strong>仍然存在</strong>。</p><p>因此，在切换分支的时候，最好commit再切换，或者git stash下来。</p><h3 id="分支新建与合并"><a href="#分支新建与合并" class="headerlink" title="分支新建与合并"></a>分支新建与合并</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.新建分支并切换到该分支上</span></span><br><span class="line">git checkout -b 分支名 </span><br><span class="line"><span class="comment">#等价于下面两条命令</span></span><br><span class="line">git branch 分支名</span><br><span class="line">git checkout 分支名</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.合并</span></span><br><span class="line">git checkout master</span><br><span class="line">git merge 分支名 <span class="comment">#fast-forward 无需解决冲突</span></span><br><span class="line">                <span class="comment">#如果当前master和分支的起点不是同个点，可能会有矛盾需解决</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.删除无用的分支</span></span><br><span class="line">git branch -d 分支名 <span class="comment">#(-D 强制删除，-d无法删除未merge的分支)</span></span><br></pre></td></tr></table></figure><h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><ol><li>分支由本地新建并推送给远程</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git push</span><br><span class="line">git pull <span class="comment">#可缺省后面的仓库名 &lt;远程库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;  </span></span><br><span class="line">                        <span class="comment"># git push是  &lt;本地分支&gt;:&lt;远程分支&gt;  </span></span><br><span class="line"></span><br><span class="line">git checkout mybranch1</span><br><span class="line">git push origin mybranch1</span><br><span class="line">git pull origin mybranch1  <span class="comment">#后面仓库名、分支名不可缺省</span></span><br></pre></td></tr></table></figure><blockquote><p>git pull和push后面有些可以省略，需要<strong>配置</strong>push.default默认行为</p><p>*<strong>建议</strong>分支操作的时候，每次pull和push加上仓库名<origin> &lt;分支名&gt;(本地和远程分支名相同)</origin></p></blockquote><ol><li>分支由远程新建好本地跟踪</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -t(--track) origin/mybranch1 <span class="comment">#克隆远端分支并创建到本地，名与远端同</span></span><br></pre></td></tr></table></figure><p><strong>合并分支与前面相同，git merge</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge mybranch1</span><br><span class="line">git push &lt;origin&gt; &lt;master&gt;</span><br></pre></td></tr></table></figure><p>最后删除无用的分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除远程分支</span></span><br><span class="line">git push origin --delete(-d) mybranch1</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除本地分支</span></span><br><span class="line">git branch -d mybranch1 <span class="comment">#-D强制删除</span></span><br></pre></td></tr></table></figure><h3 id="删除远程分支后本地未同步"><a href="#删除远程分支后本地未同步" class="headerlink" title="删除远程分支后本地未同步"></a>删除远程分支后本地未同步</h3><ul><li>方法1</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch -p 命令</span><br><span class="line"><span class="comment">#命令行解释--prune -p  删除不存在的远程跟踪分支</span></span><br></pre></td></tr></table></figure><ul><li>方法2</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote show origin <span class="comment">#查看远程分支，还有本地分支与之相对应关系等信息。</span></span><br><span class="line">git remote prune origin <span class="comment">#可以删除远程已经不存在的分支</span></span><br></pre></td></tr></table></figure><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
