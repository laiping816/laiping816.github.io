<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Java学习(4)</title>
      <link href="/2018/11/05/Java%E5%AD%A6%E4%B9%A04/"/>
      <url>/2018/11/05/Java%E5%AD%A6%E4%B9%A04/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p>异常处理、File类、IO流</p><br><p>上周好朋友结婚，以及一些琐事，导致脱更。</p></blockquote><p><img src="https://image-link.nos-eastchina1.126.net/java_04"></p><a id="more"></a><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul><li><p>异常继承体系</p><ul><li><p><code>Throwable</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getMessage() <span class="comment">//获取异常信息，返回字符串。</span></span><br><span class="line">toString()   <span class="comment">//获取异常类名和异常信息，返回字符串。</span></span><br><span class="line">printStackTrace()<span class="comment">//获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。</span></span><br></pre></td></tr></table></figure><ul><li><code>Error</code> ：服务器宕机，数据库崩溃</li><li><code>Exception</code><ul><li><code>RuntimeException</code></li><li>编译时异常，在编译阶段必须显示处理</li></ul></li></ul></li></ul></li><li><p><code>JVM</code>异常处理</p><ul><li><code>main</code>发现问题，自己处理，然后继续运行</li><li>自身没有针对的处理方法，交给<code>main</code>的<code>JVM</code>处理<ul><li><code>JVM</code>有一个默认的异常处理机制，并将该异常的名称,异常的信息.异常出现的位置打印在了控制台上,同时将程序停止运行。</li></ul></li></ul></li></ul><h3 id="异常处理格式"><a href="#异常处理格式" class="headerlink" title="异常处理格式"></a>异常处理格式</h3><h4 id="try-catch"><a href="#try-catch" class="headerlink" title="try catch"></a>try catch</h4><ul><li><code>try catch</code></li><li><code>try catch finally</code></li><li><code>try finally</code></li></ul><blockquote><p>jdk7处理多异常</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ArithmeticException | ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="细说Finally"><a href="#细说Finally" class="headerlink" title="细说Finally"></a>细说Finally</h5><ul><li><p>特点</p><ul><li><p>被<code>finally</code>控制的语句体一定会执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">"捕获异常"</span>);</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">//在return执行前，会先去执行finally，最后再彻底返回</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"执行收尾工作"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>特殊情况：在执行到<code>finally</code>之前jvm退出了(比如<code>System.exit(0)</code>)</p></li></ul></li><li><p>作用</p><ul><li>用于释放资源，在IO流操作和数据库操作中会见到</li></ul></li></ul><blockquote><p>面试题</p></blockquote><ol><li><p><code>final</code> <code>finally</code>和 <code>finalize</code>区别</p><p><code>finalize</code>是一个方法，当垃圾回收器确定不存在对该对象的更多引用时，由对象垃圾回收器调用该方法</p></li><li><p>运行顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    x = <span class="number">20</span>;</span><br><span class="line">    System.out.println(<span class="number">1</span>/<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    x = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">return</span> x; <span class="comment">//结果返回30，因为此时，虽然执行finnaly,但此时的x值已经确定</span></span><br><span class="line">&#125; finnaly &#123;</span><br><span class="line">    x = <span class="number">40</span>; <span class="comment">//禁止写return,会覆盖上面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h4><ul><li>定义功能方法时，需要把出现的问题暴露出来让调用者去处理。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"编译时异常"</span>); <span class="comment">//抛出必须处理，编译通不过</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"运行时异常"</span>); <span class="comment">//抛出后可以不处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>和<code>throw</code>区别</p><p><code>throw</code>概述：在功能方法内部出现某种情况，程序不能继续运行，需要进行跳转时，就用<code>throw</code>把异常对象抛出。</p><ul><li><code>throws</code><ul><li>用在方法声明后面，跟的是异常类名</li><li>可以跟多个异常类名，用逗号隔开</li><li>表示抛出异常，由该方法的调用者来处理</li></ul></li><li><code>throw</code><ul><li>用在方法体内，跟的是异常对象名</li><li>只能抛出一个异常对象名</li><li>表示抛出异常，由方法体内的语句处理</li></ul></li></ul></li></ul><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><ul><li><p>缘由</p><ul><li>主要用来通过名字区分到底是什么异常，有针对性解决</li></ul></li><li><p>继承<code>Exception</code>或<code>RuntimeException</code></p></li></ul><h3 id="异常注意事项"><a href="#异常注意事项" class="headerlink" title="异常注意事项"></a>异常注意事项</h3><ul><li>子类重写父类方法时，子类的方法必须抛出相同的异常或父类异常的子类。</li><li>如果父类抛出了多个异常,子类重写父类时,只能抛出相同的异常或者是他的子集,子类不能抛出父类没有的异常</li><li>如果被重写的方法没有异常抛出,那么子类的方法绝对不可以抛出异常,如果子类方法内有异常发生,那么子类只能<code>try</code> 不能<code>throws</code></li></ul><blockquote><p>小案例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    String line = sc.nextLine();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(line);</span><br><span class="line">        System.out.println(Integer.toBinaryString(num));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> BigInteger(line);</span><br><span class="line">System.out.println(<span class="string">"录入错误,您录入的是一个过大整数"</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">new</span> BigDecimal(line);</span><br><span class="line">System.out.println(<span class="string">"录入错误,您录入的是一个小数"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">                System.out.println(<span class="string">"录入错误,您录入的是非法字符"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><ul><li>构造方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File(String pathname) </span><br><span class="line">File(String parent, String child)</span><br><span class="line">    <span class="comment">//根据一个目录和一个子文件/目录得到File对象</span></span><br><span class="line">File(File parent, String child)</span><br><span class="line">    <span class="comment">//根据一个父File对象和一个子文件/目录得到File对象</span></span><br></pre></td></tr></table></figure><h3 id="创建功能"><a href="#创建功能" class="headerlink" title="创建功能"></a>创建功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">createNewFile</span><span class="params">()</span><span class="comment">//创建文件 如果存在这样的文件，就不创建了</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">mkdir</span><span class="params">()</span><span class="comment">//创建文件夹 如果存在这样的文件夹，就不创建了</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">mkdirs</span><span class="params">()</span><span class="comment">//创建多级目录</span></span></span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><p>如果你创建文件或者文件夹忘了写盘符路径，那么，默认在<strong>项目路径</strong>下。</p><h3 id="重命名和删除"><a href="#重命名和删除" class="headerlink" title="重命名和删除"></a>重命名和删除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">renameTo</span><span class="params">(File dest)</span>  <span class="comment">//把文件重命名为指定的文件路径</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">delete</span><span class="params">()</span>  <span class="comment">//删除文件或者文件夹</span></span></span><br></pre></td></tr></table></figure><ul><li>重命名注意事项<ul><li>如果路径名相同，就是改名。</li><li>如果路径名不同，就是改名并剪切。</li></ul></li><li>删除注意事项<ul><li>Java中的删除不走回收站。</li><li>要删除一个文件夹，请注意该文件夹内不能包含文件或者文件夹</li></ul></li></ul><h3 id="判断功能"><a href="#判断功能" class="headerlink" title="判断功能"></a>判断功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDirectory</span><span class="params">()</span><span class="comment">//判断是否是目录</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span><span class="comment">//判断是否是文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span><span class="comment">//判断是否存在</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canRead</span><span class="params">()</span><span class="comment">//判断是否可读  win下默认都可读</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canWrite</span><span class="params">()</span><span class="comment">//判断是否可写</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isHidden</span><span class="params">()</span><span class="comment">//判断是否隐藏</span></span></span><br></pre></td></tr></table></figure><h3 id="获取功能"><a href="#获取功能" class="headerlink" title="获取功能"></a>获取功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getAbsolutePath</span><span class="params">()</span><span class="comment">//获取绝对路径</span></span></span><br><span class="line"><span class="function">String <span class="title">getPath</span><span class="params">()</span><span class="comment">//获取路径  构造方法中传入的</span></span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span><span class="comment">//获取名称</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">length</span><span class="params">()</span><span class="comment">//获取长度。字节数  (目录不行)  </span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">lastModified</span><span class="params">()</span><span class="comment">//获取最后一次的修改时间，毫秒值</span></span></span><br><span class="line"><span class="function">String[] <span class="title">list</span><span class="params">()</span><span class="comment">//获取指定目录下的所有文件或者文件夹的名称数组</span></span></span><br><span class="line"><span class="function">File[] <span class="title">listFiles</span><span class="params">()</span><span class="comment">//获取指定目录下的所有文件或者文件夹的File数组</span></span></span><br></pre></td></tr></table></figure><h3 id="文件名称过滤器"><a href="#文件名称过滤器" class="headerlink" title="文件名称过滤器"></a>文件名称过滤器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] list(FilenameFilter filter)</span><br><span class="line">File[] listFiles(FileFilter filter)</span><br></pre></td></tr></table></figure><p>案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">File dir = <span class="keyword">new</span> File(<span class="string">"path"</span>);</span><br><span class="line">dir.list(<span class="keyword">new</span> FilenameFilter() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//return false;</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(dir, name);</span><br><span class="line">        <span class="keyword">return</span> file.isFile() &amp;&amp; file.getName().endsWith(<span class="string">".jpg"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul><li>弊端:不能调用次数过多,容易导致栈内存溢出<ul><li>好处:不用知道循环次数</li></ul></li></ul><blockquote><p>注意点：</p><ol><li>构造方法不能使用递归调用</li><li>递归调用的返回值不一定(可以有,也可以没有)</li></ol></blockquote><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><ol><li>统计文件夹大小和删除文件夹</li><li>文件夹拷贝(多敲几次)</li><li>层级打印，类似tree的效果</li><li>1000！0个数及尾部0个数（尾部0用递归做）</li><li>约瑟夫环</li></ol><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><ul><li>概念<ul><li>IO流用来处理设备之间的数据传输</li><li>Java对数据的操作是通过流的方式</li><li>Java用于操作流的类都在IO包中</li><li>流按流向分为两种：输入流，输出流。</li><li>流按操作类型分为两种：<ul><li>字节流 : 字节流可以操作任何数据,因为在计算机中任何数据都是以字节的形式存储的</li><li>字符流 : 字符流只能操作纯字符数据，比较方便。</li></ul></li></ul></li><li>IO流常用父类<ul><li>字节流的抽象父类：<ul><li><code>InputStream</code></li><li><code>OutputStream</code></li></ul></li><li>字符流的抽象父类：<ul><li><code>Reader</code></li><li><code>Writer</code>    </li></ul></li></ul></li><li>3.IO程序书写<ul><li>使用前，导入IO包中的类</li><li>使用时，进行IO异常处理</li><li>使用后，释放资源</li></ul></li></ul><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><ul><li><p>FileInputStream</p><ul><li>读取一个字节</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"aaa.txt"</span>);</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">while</span>((b = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure><ul><li>问：<code>read()</code>方法返回值为什么是<code>int</code></li></ul><p>​    每次读取都返回<code>byte</code>,有可能在读到中间的时候遇到111111111</p></li><li><p>FileOutputStream</p><ul><li>写一个字节</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"bbb.txt"</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//bbb文件存在，不存在则创建. 默认覆盖，若要追加则改true</span></span><br><span class="line">fis.write(<span class="number">97</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h4><h5 id="逐字节拷贝"><a href="#逐字节拷贝" class="headerlink" title="逐字节拷贝"></a>逐字节拷贝</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"summer.mp3"</span>);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"copy.mp3"</span>);</span><br><span class="line"><span class="comment">//效率低</span></span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">while</span>((b = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line">fis.close();</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure><h5 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h5><ul><li>整个拷贝</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[fis.available];<span class="comment">//创建与读文件大小一样的数组</span></span><br><span class="line"><span class="comment">//容易内存溢出</span></span><br><span class="line">fis.read(arr);</span><br><span class="line">fos.write(arr);</span><br></pre></td></tr></table></figure><ul><li>小数组拷贝</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len = fis.read(arr)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    fos.write(arr, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="缓冲区拷贝"><a href="#缓冲区拷贝" class="headerlink" title="缓冲区拷贝"></a>缓冲区拷贝</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BufferedInputStream fis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">BufferedInputStream fos = <span class="keyword">new</span> BufferedInputStream(fos);</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">while</span>((b = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">    bos.write(b);</span><br><span class="line">&#125;</span><br><span class="line">bis.close();</span><br><span class="line">bos.close();</span><br></pre></td></tr></table></figure><ul><li><code>BufferedInputStream</code><ul><li>内置了一个缓冲区(数组)</li><li>从中读取一个字节时，<code>BufferedInputStream</code>会<strong>一次性</strong>从文件中读取8192个字节, 存在缓冲区中, 返回给程序一个字节</li><li>程序再次读取时, 就不用找文件了, 直接从缓冲区中获取</li><li>直到缓冲区中所有的都被使用过, 才<strong>重新</strong>从文件中读取8192个</li></ul></li><li><p><code>BufferedOutputStream</code></p><ul><li>也内置了一个缓冲区(数组) 8KB</li><li>程序向流中写出字节时, 不会直接写到文件, 先写到缓冲区中</li><li>直到缓冲区写满, <code>BufferedOutputStream</code>才会把缓冲区中的数据一次性写到文件里</li></ul></li><li><p><code>flush()</code>和<code>close()</code>区别</p><ul><li><code>flush()</code><ul><li>用来刷新缓冲区的,刷新后可以再次写出 </li></ul></li><li><code>close()</code><ul><li>用来关闭流释放资源的的,如果是带缓冲区的流对象的<code>close()</code>方法,不但会关闭流,还会再关闭流之前刷新缓冲区,关闭后不能再写出 </li></ul></li></ul></li></ul><h4 id="读取中文"><a href="#读取中文" class="headerlink" title="读取中文"></a>读取中文</h4><ul><li>字节流读取中文的问题<ul><li>字节流在读中文的时候有可能会读到半个中文,造成乱码 <ul><li>用字符流解决</li><li>也可用内存输出流解决</li></ul></li></ul></li><li>字节流写出中文的问题<ul><li>字节流直接操作的字节,所以写出中文必须将字符串转换成字节数组 </li><li>写出回车换行 <code>write(&quot;\r\n&quot;.getBytes())</code>;</li></ul></li></ul><blockquote><p> 流处理异常代码规范</p></blockquote><ul><li><p>jdk1.6以前</p><p><code>try finally</code>嵌套</p></li><li><p>Jdk1.7</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"aaa.txt"</span>);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"bbb.txt"</span>);</span><br><span class="line">    MyClose mc = <span class="keyword">new</span> MyClose();<span class="comment">//必须实现close方法</span></span><br><span class="line">)&#123;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">while</span>((b = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        fos.write(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>原理</p><p>​    在<code>try()</code>中创建的流对象必须实现了<code>AutoCloseable</code>这个接口,如果实现了,在<code>try</code>后面的<code>{}</code>(读写代码)执行后就会<strong>自动调用</strong>,流对象的<code>close</code>方法将流关掉 。</p></li></ul></li></ul><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><ul><li><p><code>FileReader</code></p><ul><li><code>read()</code>方法可以按照字符大小读取</li></ul></li><li><p><code>FileWriter</code></p><ul><li><code>write()</code>方法可以自动把字符、字符串等转为字节写出</li></ul></li></ul><h4 id="拷贝-1"><a href="#拷贝-1" class="headerlink" title="拷贝"></a>拷贝</h4><ul><li>逐字符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"a.txt"</span>);</span><br><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"b.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line"><span class="keyword">while</span>((ch = fr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">fw.write(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fr.close();</span><br><span class="line">fw.close();<span class="comment">//在Writer类中有个2KB的小缓冲区，若不关流，则会存在于缓冲区</span></span><br></pre></td></tr></table></figure><blockquote><p>用字符流来拷贝</p></blockquote><ol><li><p>文本文件</p><p>因为读取时会把字节转为字符, 写出时还要把字符转回字节。效率低。一般用来普通读写文本文件</p></li><li><p><strong>不能</strong>拷贝非文本文件</p><p>因为在读的时候会将字节转换为字符,在转换过程中,可能找不到对应的字符,就会用?代替,写出的时候会将字符转换成字节写出去如果是?,直接写出,这样写出之后的文件就乱了,看不了</p></li></ol><ul><li><p>小数组拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">char</span>[] arr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>*<span class="number">8</span>];</span><br><span class="line"><span class="keyword">while</span>((len = fr.read(arr)) != -<span class="number">1</span>) &#123;</span><br><span class="line">fw.write(arr, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>带缓冲区拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"aaa.txt"</span>));<span class="comment">//创建字符输入流对象,关联aaa.txt</span></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"bbb.txt"</span>));<span class="comment">//创建字符输出流对象,关联bbb.txt</span></span><br><span class="line"><span class="comment">//其后写法同字节流</span></span><br></pre></td></tr></table></figure><ul><li><code>readLine()</code>和<code>newLine()</code>方法<ul><li><code>BufferedReader</code>的<code>readLine()</code>方法可以读取一行字符(不包含换行符号)</li><li><code>newLine()</code>可以输出一个跨平台的换行符号<code>&quot;\r\n&quot;</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    bw.write(line);</span><br><span class="line">    bw.newLine();<span class="comment">//支持跨平台换行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>LineNumberReader</code>类<ul><li><code>getLineNumber()</code>方法可以获取当前行号</li><li><code>setLineNumber()</code>方法可以设置当前行号</li></ul></li></ul></li></ul><h4 id="指定编码表"><a href="#指定编码表" class="headerlink" title="指定编码表"></a>指定编码表</h4><ul><li><code>InputStreamReader(字节流, 编码表)</code>    将字节流按<strong>指定</strong>编码表转换成字符流</li><li><code>OutputStreamWriter(字节流,编码表)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">    <span class="keyword">new</span> InputStreamReader(</span><br><span class="line">        <span class="keyword">new</span> FileInputStream(<span class="string">"UTF-8.txt"</span>), <span class="string">"UTF-8"</span></span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(</span><br><span class="line">    <span class="keyword">new</span> OutputStreamWriter(</span><br><span class="line">        <span class="keyword">new</span> FileOutputStream(<span class="string">"GBK.txt"</span>), <span class="string">"GBK"</span></span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line"><span class="keyword">while</span>((ch = br.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">    bw.write(ch);</span><br><span class="line">&#125;</span><br><span class="line">br.close();</span><br><span class="line">bw.close();</span><br></pre></td></tr></table></figure><h4 id="小测验"><a href="#小测验" class="headerlink" title="小测验"></a>小测验</h4><p>统计一个文本文件中，各字符出现个数</p><h4 id="装饰设计模式"><a href="#装饰设计模式" class="headerlink" title="装饰设计模式"></a>装饰设计模式</h4><ul><li>优点<ul><li>耦合性不强</li><li>被装饰的类的变化与装饰类的变化无关</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Coder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Coder</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"javase"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeiMaStudent</span> <span class="keyword">implements</span> <span class="title">Coder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.获取到被包装的类的引用</span></span><br><span class="line"><span class="keyword">private</span> Student s;</span><br><span class="line">    <span class="comment">//2.通过构造函数创建对象的时候,传入被包装的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ItcastStudent</span><span class="params">(Student s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.s = s;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//3.对其原有功能进行升级</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">s.code();</span><br><span class="line">System.out.println(<span class="string">"数据库"</span>);</span><br><span class="line">System.out.println(<span class="string">"ssm"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列流"><a href="#序列流" class="headerlink" title="序列流"></a>序列流</h3><ul><li><p>概念</p><p>​    <code>SequenceInputStream</code>可以把多个字节输入流整合成一个, 从序列流中读取数据时, 将从被整合的第一个流开始读, 读完一个之后继续读第二个, 以此类推.</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis1 = <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);</span><br><span class="line">FileInputStream fis2 = <span class="keyword">new</span> FileInputStream(<span class="string">"b.txt"</span>);</span><br><span class="line">FileInputStream fis3 = <span class="keyword">new</span> FileInputStream(<span class="string">"c.txt"</span>);</span><br><span class="line">Vector&lt;InputStream&gt; v = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">v.add(fis1);</span><br><span class="line">v.add(fis2);</span><br><span class="line">v.add(fis3);</span><br><span class="line">Enumeration&lt;InputStream&gt; en = v.elements();<span class="comment">//获取枚举引用</span></span><br><span class="line">SequenceInputStream sis = <span class="keyword">new</span> SequenceInputStream(en);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"d.txt"</span>);</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">while</span>((b = sis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">fos.write(b);</span><br><span class="line">&#125;</span><br><span class="line">sis.close();</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure><h3 id="内存输出流"><a href="#内存输出流" class="headerlink" title="内存输出流"></a>内存输出流</h3><ul><li><p>概念</p><p>​    <code>ByteArrayOutputStream</code>该输出流可以向内存中写数据, 把内存当作一个缓冲区, 写出之后可以一次性获取出所有数据</p></li><li><p>使用方式</p><ul><li>创建：<code>new ByteArrayOutputStream()</code></li><li>写出：<code>write(int)</code>, <code>write(byte[])</code></li><li>获取：<code>toByteArray()</code> <code>toString()</code></li></ul></li></ul><h3 id="对象操作流"><a href="#对象操作流" class="headerlink" title="对象操作流"></a>对象操作流</h3><ul><li><p>概念</p><p>​    <code>ObjectOutputStream</code>该流可以将一个对象写出, 或者读取一个对象到程序中. 也就是执行了序列化和反序列化的操作.</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">23</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">24</span>);</span><br><span class="line"><span class="comment">//无论是字节输出流,还是字符输出流都不能直接写出对象</span></span><br><span class="line"><span class="comment">//将对象写出,序列化</span></span><br><span class="line"><span class="comment">//Person 类必须实现 Serializable 接口，才可实现序列化</span></span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"e.txt"</span>));</span><br><span class="line">oos.writeObject(p1);</span><br><span class="line">oos.writeObject(p2);</span><br><span class="line">oos.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取对象,反序列化</span></span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"e.txt"</span>));</span><br><span class="line">Person p1 = (Person) ois.readObject();</span><br><span class="line">Person p2 = (Person) ois.readObject();</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure><ul><li>优化写法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(p1);</span><br><span class="line">list.add(p2);</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"f.txt"</span>));</span><br><span class="line"><span class="comment">//集合写进去</span></span><br><span class="line">oos.writeObject(list);</span><br><span class="line">oos.close();</span><br><span class="line"></span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"f.txt"</span>));</span><br><span class="line">ArrayList&lt;Person&gt; list = (ArrayList&lt;Person&gt;)ois.readObject();</span><br><span class="line"><span class="comment">//泛型在运行期会被擦除,索引运行期相当于没有泛型</span></span><br><span class="line"><span class="keyword">for</span> (Person person : list) &#123;</span><br><span class="line">    System.out.println(person);</span><br><span class="line">&#125;</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure><ul><li><p>id</p><p>用来识别当前类的版本号，不用必须加。</p></li></ul><h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><ul><li><p>概念</p><p>​    该流可以很方便的将对象的<code>toString()</code>结果输出, 并且自动加上换行, 而且可以使用自动刷出的模式。</p><ul><li><code>PrintStream</code><ul><li><code>System.out</code>, 其默认向控制台输出信息</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PrintStream ps = System.out;</span><br><span class="line">ps.println(<span class="number">97</span>);<span class="comment">//其实底层用的是Integer.toString(x),将x转换为数字字符串打印</span></span><br><span class="line">ps.println(<span class="string">"xxx"</span>);</span><br><span class="line">ps.println(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">23</span>));</span><br><span class="line">Person p = <span class="keyword">null</span>;</span><br><span class="line">ps.println(p); <span class="comment">//如果是null,就返回null,如果不是null,就调用对象的toString()</span></span><br></pre></td></tr></table></figure><ul><li><code>PrintWrite</code><ul><li>自动刷出：<code>PrintWrite(OutputStream out, boolean autoFlush, String encoding)</code>       (自动只针对<code>println()</code>)，所以没什么用</li></ul></li></ul></li><li><p><code>PrintStream</code>和<code>PrintWrite</code>区别</p><p>​         2个类的功能基本相同，<code>PrintStream</code>能做的<code>PrintWriter</code>也都能实现，并且<code>PrintWriter</code>的功能更为强大。但是由于<code>PrintWriter</code>出现的比较晚，较早的<code>System.out</code>使用的是<code>PrintStream</code>来实现的，所以为了兼容就没有废弃<code>PrintStream</code>。 </p><p>​    2个类最大的<strong>差别</strong>是，<code>PrintStream</code>在输出字符，将字符转换为字节时采用的是系统默认的编码格式，这样当数据传输另一个平台，而另一个平台使用另外一个编码格式解码时就会出现问题，存在不可控因素。而<code>PrintWriter</code>可以在传入<code>Writer</code>时可由程序员指定字符转换为字节时的编码格式，这样兼容性和可控性会更好。</p></li></ul><blockquote><p> 打印流只操作数据目的，相当于<strong>只写</strong></p></blockquote><h3 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h3><ul><li><code>System.in</code>是<code>InputStream</code>, 标准输入流, 默认可以从键盘输入读取字节数据</li><li><code>System.out</code>是<code>PrintStream</code>, 标准输出流, 默认可以向Console中输出字符和字节数据</li><li>修改输入流： <code>System.setIn(InputStream)</code>   当跟硬盘文件产生关联时，则需要关闭</li><li>修改输出流：<code>System.setOut(PrintStream)</code></li></ul><h3 id="随机访问流"><a href="#随机访问流" class="headerlink" title="随机访问流"></a>随机访问流</h3><ul><li><p>概述</p><ul><li><code>RandomAccessFile</code>类不属于流，是<code>Object</code>类的子类。但它融合了<code>InputStream</code>和<code>OutputStream</code>的功能。</li><li>支持对随机访问文件的读取和写入。</li></ul></li><li><p>API</p><ul><li><code>read()</code>,<code>write()</code>,<code>seek()</code>   可用于多线程下载</li></ul></li></ul><h3 id="数据输入输出流"><a href="#数据输入输出流" class="headerlink" title="数据输入输出流"></a>数据输入输出流</h3><blockquote><p>用的不多</p></blockquote><ul><li><code>DataInputStream</code>, <code>DataOutputStream</code>可以按照基本数据类型大小读写数据</li><li>例如按<code>Long</code>大小写出一个数字, 写出时该数据占8字节. 读取的时候也可以按照Long类型读取, 一次读取8个字节.</li></ul><h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><ul><li><p>概述</p><ul><li><code>Properties</code>类表示了一个持久的属性集。</li><li><code>Properties</code>可保存在流中或从流中加载。</li><li>属性列表中每个键及其对应值都是一个字符串。 </li></ul></li><li><p>作为Map集合的使用</p><ul><li><code>Object setProperty(String key,String value)</code></li><li><code>String getProperty(String key)</code></li><li><code>Enumeration&lt;String&gt; stringPropertyNames()</code></li></ul></li><li><p>加载和存储</p><ul><li><p><code>load()</code></p></li><li><p><code>store()</code></p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java IO流 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java学习(3)</title>
      <link href="/2018/11/01/Java%E5%AD%A6%E4%B9%A03/"/>
      <url>/2018/11/01/Java%E5%AD%A6%E4%B9%A03/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p>Collection(List、Set)、泛型、迭代器、Map(HashMap、TreeMap)</p></blockquote><p><img src="https://image-link.nos-eastchina1.126.net/java_03"></p><a id="more"></a><h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><ul><li><p>由来</p><ul><li>集合类,能存储任意对象,长度是可以改变的,随着元素的增加而增加,随着元素的减少而减少 </li></ul></li><li><p>和数组区别</p><ul><li><p>difference1</p><ul><li><p>数组既可以存储基本数据类型,又可以存储引用数据类型</p></li><li><p>集合只能存储引用数据类型(对象)集合中也可以存储基本数据类型,但是在存储的时候会自动装箱变成对象</p></li></ul></li><li><p>difference2</p><ul><li>长度，数组定，集合不定灵活。</li></ul></li></ul></li><li><p>继承图</p><p><code>Collection</code>(单列集合的根接口)</p><ul><li>List有序（存取顺序一致）有索引、可存储重复<ul><li><code>ArrayList</code> ：数组实现</li><li><code>LinkList</code> ：链表实现</li><li><code>Vector</code>  : jdk1.0产生</li></ul></li><li>Set无序（存取顺序不一） 无索引、不可存储重复<ul><li><code>HashSet</code> ：哈希算法</li><li><code>TreeSet</code> ：二叉树算法</li></ul></li></ul></li></ul><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><ul><li><p>基本功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span>     <span class="comment">//到添加基本类型的时候，会自动装箱</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li><li><p>带 all 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection c)</span>  <span class="comment">//此处参数为集合，注意和add()区别</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection c)</span> <span class="comment">//删除的是交集</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection c)</span> <span class="comment">//判断调用集合是否包含传入的集合</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection c)</span><span class="comment">//保留取交集，如果调用的集合改变就true，不变就false</span></span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">c.add(<span class="string">"a"</span>);</span><br><span class="line">c.add(<span class="string">"b"</span>);</span><br><span class="line">c.add(<span class="string">"c"</span>);</span><br><span class="line">c.add(<span class="string">"c"</span>);</span><br><span class="line"></span><br><span class="line">Collection c2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">c2.add(<span class="string">"a"</span>);</span><br><span class="line">c2.add(<span class="string">"b"</span>);</span><br><span class="line">c2.add(<span class="string">"c"</span>);</span><br><span class="line">System.out.println(c.retainAll(c2)); <span class="comment">//false</span></span><br><span class="line">System.out.println(c);     <span class="comment">//["a","b","c","c"]</span></span><br></pre></td></tr></table></figure></li><li><p>集合转数组</p><p><code>public &lt;T&gt; T[] toArray(T[] a)</code></p><p>转换后的数组长度：当指定的参数a数组长度大于集合size，则为指定长度，否则为size</p></li></ul><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = c.iterator();<span class="comment">//获取迭代器的引用</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;<span class="comment">//集合中的迭代方法(遍历)</span></span><br><span class="line">System.out.println(it.next());<span class="comment">//注意此处，in.next()返回的是object类引用</span></span><br><span class="line">&#125;<span class="comment">//next方法用一次指针移1次</span></span><br></pre></td></tr></table></figure><h4 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> <span class="comment">//是否有下一个</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span><span class="comment">//是否有前一个 </span></span></span><br><span class="line"><span class="function">Object <span class="title">next</span><span class="params">()</span><span class="comment">//返回下一个元素</span></span></span><br><span class="line"><span class="function">Object <span class="title">previous</span><span class="params">()</span><span class="comment">//返回上一个元素</span></span></span><br></pre></td></tr></table></figure><h4 id="增强for"><a href="#增强for" class="headerlink" title="增强for"></a>增强for</h4><ul><li><p>功能：简化数组和Collection集合的遍历</p></li><li><p>格式：for(元素数据类型 变量 : 数组或者Collection集合) {<br>​        使用变量即可，该变量就是元素<br>​    }</p></li></ul><h4 id="三种迭代器删除"><a href="#三种迭代器删除" class="headerlink" title="三种迭代器删除"></a>三种迭代器删除</h4><ul><li><p>普通for循环,可以删除,但是索引要–</p></li><li><p>迭代器,可以删除,但是必须使用迭代器自身的remove方法,否则会出现并发修改异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法1</span></span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"b"</span>.equals(it.next())) &#123;</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//法2</span></span><br><span class="line"><span class="keyword">for</span>(Iterator&lt;String&gt; it2) = list.iterator(); it2.hasNext();) &#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="string">"b"</span>.equals(it.next())) &#123;</span><br><span class="line">        it2.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>增强for循环不能删除，因为其底层也是用迭代器实现，并发修改异常。</p></li></ul><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul><li><p>由来</p><ul><li>通过Object转型问题引入</li><li>早期的Object类型可以接收任意的对象类型，但是在实际的使用中，会有类型转换的问题。也就存在这隐患，所以Java提供了泛型来解决这个安全问题。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tool t = <span class="keyword">new</span> Tool();<span class="comment">//该类内部有Object类成员变量</span></span><br><span class="line">t.setObj(<span class="keyword">new</span> Student(<span class="string">"张三"</span>));</span><br><span class="line">Worker w = (Worker) t.getObj(); <span class="comment">//编译不会报错</span></span><br><span class="line"><span class="comment">//运行会出错，因为Object是任何类的父类，存在转换出错</span></span><br></pre></td></tr></table></figure></li><li><p>泛型好处</p><ul><li>提高安全性(将运行期的错误转换到编译期) </li><li>省去强转的麻烦</li></ul></li><li><p>泛型基本使用</p><ul><li>&lt;&gt;中放的必须是引用数据类型</li></ul></li><li><p>泛型使用注意事项</p><ul><li>前后的泛型必须一致,或者后面的泛型可以省略不写(1.7的新特性菱形泛型)  </li></ul></li></ul><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getName</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>&lt;T&gt; <span class="keyword">void</span> <span class="title">method</span><span class="params">(T t)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; <span class="keyword">void</span> <span class="title">method</span><span class="params">(T t)</span> </span>;<span class="comment">//静态方法必须申明自己的泛型</span></span><br></pre></td></tr></table></figure><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接,推荐用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">implements</span> <span class="title">Inter</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String s)</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//再泛型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Inter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">     <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h4><ul><li><p>泛型通配符&lt;?&gt;</p><ul><li>任意类型，如果没有明确，那么就是Object以及任意的Java类了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">//当右边不确定的时，左可用?</span></span><br></pre></td></tr></table></figure></li><li><p>? extends E</p><ul><li>固定上边界，E及其子类，放进集合，父类引用指向子类对象。</li><li>本质：元素添加进集合的时候，用<code>addAll()</code>，此刻的<strong>E为父类</strong>，所以只要是子类都能添加进去</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span></span><br></pre></td></tr></table></figure></li><li><p>? super E</p><ul><li>固定下边界，父类引用指向子类对象。</li><li>子类对象调用父类<code>compare</code>方法，此刻的<strong>E为子类</strong>，所以只要父类的compare方法都可以拿来用。</li></ul></li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul><li><p>特有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,E element)</span> <span class="comment">//0 &lt;= index &lt;= size </span></span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>ListIterator</code> add() </p><p>处理并发修改异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ListIterator lit = list.listIterator(); <span class="comment">//获取迭代器(List集合特有的)</span></span><br><span class="line">lit.add(内容);</span><br><span class="line"><span class="keyword">while</span>(lit.hasNext()) &#123;</span><br><span class="line">    it.next();</span><br><span class="line">lit.add(<span class="string">"迭代器边查询边加入内容"</span>); <span class="comment">//此处若用集合中的add()会发生并发修改异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Arrays.asList()</code></p><p>数组转集合虽然不能增加或减少元素，但可以用集合思想操作数组，可用集合API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">List&lt;<span class="keyword">int</span>[]&gt; list = Arrays.asList(arr);<span class="comment">//基本数据类型数据转换，会将整个数组当做一个对象转换</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><ul><li>去除重复元素<ul><li>调用<code>contains</code>或者<code>remove</code>方法，<strong>注意</strong>其内部实现都依赖<code>equals</code>方法</li></ul></li></ul><h4 id="LinkList"><a href="#LinkList" class="headerlink" title="LinkList"></a>LinkList</h4><ul><li><p>特有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span>及<span class="title">addLast</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function">E <span class="title">getFirst</span><span class="params">()</span>及<span class="title">getLast</span><span class="params">()</span></span></span><br><span class="line"><span class="function">E <span class="title">removeFirst</span><span class="params">()</span>及<span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span></span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><ul><li><p><code>Vector</code>类概述</p></li><li><p><code>Vector</code>类特有功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addElement</span><span class="params">(E obj)</span></span></span><br><span class="line"><span class="function">E <span class="title">elementAt</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">Enumeration <span class="title">elements</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li><li><p>案例演示    </p><ul><li><p><code>Vector</code>的迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vector v = <span class="keyword">new</span> Vector();<span class="comment">//创建集合对象,List的子类</span></span><br><span class="line">v.addElement(<span class="string">"a"</span>);</span><br><span class="line">v.addElement(<span class="string">"b"</span>);</span><br><span class="line"><span class="comment">//Vector迭代</span></span><br><span class="line">Enumeration en = v.elements();<span class="comment">//获取枚举</span></span><br><span class="line"><span class="keyword">while</span>(en.hasMoreElements()) &#123;<span class="comment">//判断集合中是否有元素</span></span><br><span class="line">System.out.println(en.nextElement());<span class="comment">//获取集合中的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p> List的三个子类特点</p><ul><li><code>ArrayList</code>:<ul><li>底层数据结构是数组，查询快，增删慢。</li><li>线程不安全，效率高。</li></ul></li><li><code>Vector</code>:<ul><li>底层数据结构是数组，查询快，增删慢。</li><li>线程安全，效率低。</li></ul></li><li><code>LinkedList</code><ul><li>底层数据结构是链表，查询慢，增删快。</li><li>线程不安全，效率高。</li></ul></li></ul></blockquote><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>无索引，不可重复，无序（存取不一致）</p><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><ul><li><p>存储自定义对象保证元素<strong>唯一性</strong></p><ul><li><p>案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;Person&gt; hs = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">hs.add(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">23</span>)); </span><br><span class="line">hs.add(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">23</span>)); <span class="comment">//当添加不成功的时候返回false</span></span><br><span class="line">hs.add(<span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">23</span>));</span><br><span class="line">hs.add(<span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">23</span>));</span><br><span class="line">hs.add(<span class="keyword">new</span> Person(<span class="string">"王五"</span>, <span class="number">23</span>));</span><br><span class="line"><span class="comment">//结果都添加进去了，并未唯一，原因？？？</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>原理</p><ul><li>我们使用<code>Set</code>集合都是需要去掉重复元素的, 如果在存储的时候逐个<code>equals()</code>比较, 效率较低,哈希算法提高了去重复的效率, 降低了使用<code>equals()</code>方法的次数</li><li>当<code>HashSet</code>调用<code>add()</code>方法存储对象的时候, 先调用对象的<code>hashCode()</code>方法得到一个哈希值, 然后在集合中查找是否有哈希值相同的对象。不相同，则直接添加进集合（桶结构），如果相同，则调用<code>equals()</code>方法。</li></ul></li><li><p>将自定义类的对象存入<code>HashSet</code>去重复</p><ul><li>类中必须重写<code>hashCode()</code>和<code>equals()</code>方法</li><li><code>hashCode()</code>: 属性相同的对象返回值必须相同, 属性不同的返回值尽量不同(提高效率)</li><li><code>equals()</code>: 属性相同返回<code>true</code>, 属性不同返回<code>false</code>,返回<code>false</code>的时候存储</li></ul></li></ul><h5 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h5><ul><li>特点<ul><li>底层是链表实现，是<code>Set</code>集合中唯一一个能保证存取一致的集合对象</li><li>是<code>HashSet</code>子类，所以保证元素唯一性原理和父类同。</li></ul></li></ul><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><ul><li><p>特点</p><p>TreeSet集合是用来对象元素进行<strong>排序</strong>的,同样他也可以保证元素的唯一</p></li><li><p>原理</p><ul><li><p>自然排序(<code>Comparable</code>)</p><ul><li><code>TreeSet</code>类的<code>add()</code>方法中会把存入的对象提升为<code>Comparable</code>类型</li><li>调用对象的<code>compareTo()</code>方法和集合中的对象比较</li><li>根据<code>compareTo()</code>方法返回的结果进行存储</li></ul><blockquote><p>二叉树结构存储</p><ol><li><p>第一个数据进来<code>compareTo</code>方法返回0</p></li><li><p>之后数据根据<code>compareTo</code>方法结果，小的存左边（负数），大的右边（正数），相等就不存（0）</p></li></ol></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> length = <span class="keyword">this</span>.name.length() - o.name.length();</span><br><span class="line">        <span class="comment">//比较长度为主要条件</span></span><br><span class="line"><span class="keyword">int</span> num = length == <span class="number">0</span> ? <span class="keyword">this</span>.name.compareTo(o.name) : length;</span><br><span class="line">        <span class="comment">//比较内容为次要条件</span></span><br><span class="line"><span class="keyword">return</span> num == <span class="number">0</span> ? <span class="keyword">this</span>.age - o.age : num;</span><br><span class="line">        <span class="comment">//比较年龄为次要条件</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>比较器顺序(<code>Comparator</code>)</p><ul><li>创建<code>TreeSet</code>的时候可以制定 一个<code>Comparator</code><ul><li>TreeSet(Comparator&lt;? super E&gt; comparator)</li></ul></li><li>如果传入了<code>Comparator</code>的子类对象, 那么<code>TreeSet</code>就会按照比较器中的顺序排序</li><li><code>add()</code>方法内部会自动调用<code>Comparator</code>接口中<code>compare()</code>方法排序</li><li>调用的对象是<code>compare</code>方法的第一个参数,集合中的对象是<code>compare</code>方法的第二个参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;String&gt; ts = <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = s1.compareTo(s2);<span class="comment">//比较内容为主要条件</span></span><br><span class="line"><span class="keyword">return</span> num == <span class="number">0</span> ? <span class="number">1</span> : num;<span class="comment">//保留重复</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul><li><code>Map</code>接口概述<ul><li>查看API可以知道：<ul><li>将键映射到值的对象</li><li>一个映射不能包含重复的键</li><li>每个键最多只能映射到一个值</li></ul></li></ul></li><li><p><code>Map</code>接口和<code>Collection</code>接口的不同</p><ul><li><code>Map</code>是<strong>双列</strong>的，<code>Collection</code>是<strong>单列</strong>的(其实也是双列，只不过value是个常量对象)</li><li><code>Map</code>的键唯一，<code>Collection</code>的子体系<code>Set</code>是唯一的</li><li><code>Map</code>集合的数据结构值针对键有效，跟值无关；<code>Collection</code>集合的数据结构是针对元素有效</li></ul></li><li><p>常用API</p><ul><li>添加功能<ul><li><code>V put(K key,V value)</code>:添加元素。<ul><li>如果键是第一次存储，就直接存储元素，返回null</li><li>如果键不是第一次存在，就用值把以前的值替换掉，返回以前的值</li></ul></li></ul></li><li>删除功能<ul><li><code>void clear()</code>:移除所有的键值对元素</li><li><code>V remove(Object key)</code>：根据键删除键值对元素，并把值返回</li></ul></li><li>判断功能<ul><li><code>boolean containsKey(Object key)</code>：判断集合是否包含指定的键</li><li><code>boolean containsValue(Object value)</code>:判断集合是否包含指定的值</li><li><code>boolean isEmpty()</code>：判断集合是否为空</li></ul></li><li>获取功能<ul><li><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>:</li><li><code>V get(Object key)</code>:根据键获取值</li><li><code>Set&lt;K&gt; keySet()</code>:获取集合中所有键的集合</li><li><code>Collection&lt;V&gt; values()</code>:获取集合中所有值的集合</li></ul></li><li>e:长度功能<ul><li><code>int size()</code>：返回集合中的键值对的个数</li></ul></li></ul></li><li><p><code>Map</code>集合的遍历</p><ul><li><p>键找值</p><ul><li>获取所有键的集合</li><li>遍历键的集合，获取到每一个键</li><li>根据键找值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Set&lt;String&gt; keySet = hm.keySet();//获取集合中所有的键</span></span><br><span class="line"><span class="comment">Iterator&lt;String&gt; it = keySet.iterator();//获取迭代器</span></span><br><span class="line"><span class="comment">while(it.hasNext()) &#123;//判断单列集合中是否有元素</span></span><br><span class="line"><span class="comment">String key = it.next();//获取集合中的每一个元素,其实就是双列集合中的键</span></span><br><span class="line"><span class="comment">Integer value = hm.get(key);//根据键获取值</span></span><br><span class="line"><span class="comment">System.out.println(key + "=" + value);//打印键值对</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String key : hm.keySet()) &#123;  <span class="comment">//增强for循环迭代双列集合第一种方式</span></span><br><span class="line">System.out.println(key + <span class="string">"="</span> + hm.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>键值对对象找键和值</p><ul><li>获取所有键值对对象的集合</li><li>遍历键值对对象的集合，获取到每一个键值对对象</li><li>根据键值对对象找键和值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = hm.entrySet();</span><br><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; it = entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">    <span class="comment">//直接用Entry注意import静态内部类</span></span><br><span class="line">Entry&lt;String, Integer&gt; en = it.next();<span class="comment">//获取键值对对象</span></span><br><span class="line">String key = en.getKey();<span class="comment">//根据键值对对象获取键</span></span><br><span class="line">Integer value = en.getValue();<span class="comment">//根据键值对对象获取值</span></span><br><span class="line">System.out.println(key + <span class="string">"="</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Entry&lt;String,Integer&gt; en : hm.entrySet()) &#123;</span><br><span class="line">System.out.println(en.getKey() + <span class="string">"="</span> + en.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ul><li><p>原理</p><p>等同于<code>HashSet</code>，添加自定义类的时候，需要重写自定义类对应<code>hashCode()</code>和<code>equals()</code>方法</p></li><li><p>和<code>HashTable</code>区别</p><ul><li>Hashtable是JDK1.0版本出现的,是线程安全的,效率低,HashMap是JDK1.2版本出现的,是线程不安全的,效率高</li><li>Hashtable不可以存储null键和null值,HashMap可以存储null键和null值</li></ul></li></ul><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><ul><li>保证了存取一致</li></ul><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><ul><li><p>原理</p><p>等同于<code>TreeSet</code>，添加自定义类的时候，需要重写比较方法，两种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> TreeMap&lt;Student,Integer&gt; tm = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> num = o1.name.compareTo(o2.name);<span class="comment">//按照姓名比较</span></span><br><span class="line">         <span class="keyword">return</span> num == <span class="number">0</span> ? Integer.compare(o1.age, o2.age) : num;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br><span class="line">tm.put(<span class="keyword">new</span> Student(<span class="number">24</span>,<span class="string">"lp"</span>),<span class="number">56</span>);</span><br><span class="line">tm.put(<span class="keyword">new</span> Student(<span class="number">20</span>,<span class="string">"lp"</span>),<span class="number">23</span>);</span><br><span class="line">System.out.println(tm);</span><br></pre></td></tr></table></figure></li></ul><h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><ul><li><p>常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;T&gt; <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;?&gt; list,T key)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;T&gt; T <span class="title">max</span><span class="params">(Collection&lt;?&gt; coll)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List&lt;?&gt; list)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List&lt;?&gt; list)</span></span></span><br></pre></td></tr></table></figure></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p><code>Collection</code></p><ul><li><p><code>Lis</code>t(存取有序,有索引,可以重复)</p><ul><li><p><code>ArrayList</code></p><p> 底层是数组实现的,线程不安全,查找和修改快,增和删比较慢</p><ul><li><code>LinkedList</code></li></ul><p>底层是链表实现的,线程不安全,增和删比较快,查找和修改比较慢</p><ul><li><code>Vector</code></li></ul><p>底层是数组实现的,线程安全的,无论增删改查都慢</p></li></ul><blockquote><ol><li><p>如果查找和修改多,用<code>ArrayList</code></p></li><li><p>如果增和删多,用<code>LinkedList</code></p></li><li><p>如果都多,用<code>ArrayList</code></p></li></ol></blockquote><ul><li><p><code>Set</code>(存取无序,无索引,不可以重复)</p><ul><li><p><code>HashSet</code></p><p>底层是哈希算法实现</p><p><code>LinkedHashSet</code></p><ul><li>底层是链表实现,但是也是可以保证元素唯一,和<code>HashSet</code>原理一样</li></ul></li><li><p><code>TreeSet</code></p><p>底层是二叉树算法实现</p></li></ul><blockquote><ol><li>一般在开发的时候不需要对存储的元素排序,所以在开发的时候大多用<code>HashSet</code>，其效率比较高</li><li><code>TreeSet</code>在面试的时候比较多,问你有几种排序方式,和几种排序方式的区别</li></ol></blockquote></li></ul></li><li><p><code>Map</code></p><ul><li><p><code>HashMap</code></p><p>底层是哈希算法,针对键</p><ul><li><p><code>LinkedHashMap</code></p><p>底层是链表,针对键</p></li></ul></li><li><p><code>TreeMap</code></p><p>底层是二叉树算法,针对键</p></li></ul><blockquote><p> 开发中用HashMap比较多</p></blockquote></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合框架 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java学习(2)</title>
      <link href="/2018/10/29/Java%E5%AD%A6%E4%B9%A02/"/>
      <url>/2018/10/29/Java%E5%AD%A6%E4%B9%A02/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p>Object、Scanner、String相关类、Arrays类、包装类、正则表达式、常用类</p></blockquote><p><img src="https://image-link.nos-eastchina1.126.net/java_02"></p><a id="more"></a><h2 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h2><ul><li><p><code>hashCode()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;  <span class="comment">//借助本地系统资源计算hashcode</span></span><br></pre></td></tr></table></figure></li><li><p><code>getClass()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class c = obj.getClass();</span><br><span class="line"><span class="comment">//c这个Class实例对象包含了这个obj实例对象所属类信息</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>toString()</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Object类中实现源码，方法调用前面省略了this</span></span><br><span class="line"><span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode())</span><br></pre></td></tr></table></figure><p>如果直接打印对象的引用，会默认调用<code>toString()</code>方法</p></li><li><p><strong><code>equals(Object obj)</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span> === obj)</span><br></pre></td></tr></table></figure></li></ul><p>所以综上，<strong><code>toString()</code></strong>和<strong><code>equals(Object obj)</code></strong>方法一般子类内都需要重写。</p><h2 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);  <span class="comment">//键盘录入</span></span><br><span class="line"><span class="keyword">if</span>(sc.hashNextInt())&#123;     <span class="comment">//判断键盘是不是int数</span></span><br><span class="line">    <span class="keyword">int</span> i= sc.nextInt();  <span class="comment">//键盘录入整数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意点：当键盘先录取整数再录取字符串会出问题</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i= sc.nextInt();</span><br><span class="line">String line1 = sc.nextLine(); <span class="comment">//键盘录入字符串，遇到\r\n结束，且不录入这2个字符</span></span><br></pre></td></tr></table></figure><p>所以当先录取整数的时候，123\r\n， \r\n会还在缓冲区中，被nextLine()获取成””空串。</p><p>解决办法</p><ul><li>创建两次对象，但浪费空间</li><li>键盘录入都是字符串，都用nextLine()，后字符串转整数</li></ul><h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><p>字面量创建</p><p><code>String str = &quot;abc&quot;</code>;</p><ul><li>字符串字面量”abc”也可以看成是一个字符串对象</li><li>字符串是常量，一旦被赋值，不可更改<ul><li>当str = “def”，此处”abc”在常量池中变成垃圾，并非改变了其值。</li></ul></li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span>[] bytes, <span class="keyword">int</span> index, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span>[] value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span>[] value, <span class="keyword">int</span> index, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span></span>; <span class="comment">//把字符串常量值转成</span></span><br></pre></td></tr></table></figure><h3 id="常见面试"><a href="#常见面试" class="headerlink" title="常见面试"></a>常见面试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>; <span class="comment">//常量池中没这个字符串对象，就创一个，有就直接用</span></span><br><span class="line">String s2 = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//true，引用常量池同一个地址</span></span><br><span class="line">System.out.println(s1.equals(s2));  <span class="comment">//比内容true </span></span><br><span class="line"><span class="comment">//======================================================================</span></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"abc"</span>); <span class="comment">//创建了2个对象，一个在常量池，一个在堆内存（副本）</span></span><br><span class="line">   <span class="comment">//实际s3引用指向堆内存这个对象</span></span><br><span class="line"><span class="comment">//======================================================================</span></span><br><span class="line">String s4 = <span class="string">"a"</span> + <span class="string">"b"</span> + <span class="string">"c"</span>;   <span class="comment">//常量优化机制，实常量池际就是"abc"</span></span><br><span class="line"><span class="comment">//======================================================================</span></span><br><span class="line">String s5 = <span class="string">"ab"</span>;</span><br><span class="line">String s6 = s5 + <span class="string">"c"</span>;   <span class="comment">//此处s5是变量</span></span><br></pre></td></tr></table></figure><blockquote><p>注意点：上面最后一项</p></blockquote><p>​    在Java中<code>+</code>，字符串串联是通过<code>StringBuilder</code>(或<code>StringBuffer</code>)类及其<code>append</code>方法实现。字符串转换通过<code>toString()</code>方法实现。</p><p>​       换言之，底层String和别的数据相加，<strong>先创建</strong>一个<code>StringBuilder</code>对象然后调用<strong><code>append</code></strong>把其他数据添加进来。最后调用<code>toString()</code>转成<code>String</code>对象。</p><h3 id="常见方法API"><a href="#常见方法API" class="headerlink" title="常见方法API"></a>常见方法API</h3><h4 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(object obj)</span></span>; <span class="comment">//区分大小写</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String str)</span></span>; <span class="comment">//忽略大小写</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String str)</span></span>; <span class="comment">//是否包含指定字符串</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String str)</span></span>;<span class="comment">//判断是不是以某指定字符串开头</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String str)</span></span>;<span class="comment">//结尾</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;<span class="comment">//判断字符串是否为空</span></span><br></pre></td></tr></table></figure><blockquote><p> 注意点：””和null的区别</p></blockquote><p><code>&quot;&quot;</code>是字符串常量，同时也是一个<code>String</code>类对象，可以调用其方法</p><p><code>null</code>是空常量，不能调用任何方法，否则会空指针异常</p><h4 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span></span>;</span><br><span class="line"><span class="comment">//lastIndexOf类似</span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>; <span class="comment">//包含头，不包含尾，尾部默认全部end = length()</span></span><br></pre></td></tr></table></figure><h4 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] getBytes();   <span class="comment">//字符串转换为 字节 数组 gbk</span></span><br><span class="line"><span class="keyword">char</span>[] toCharArray(); <span class="comment">//字符串转换为 字符 数组 unicode码表</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span>[] data)</span></span>;<span class="comment">//字符数组转换成字符串,底层是由String构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(Object obj)</span></span>; <span class="comment">//会调用对象的toString()方法</span></span><br><span class="line"><span class="comment">//...任意类型数据（基础、引用）都可以转换</span></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">String <span class="title">concat</span><span class="params">(String str)</span></span>; <span class="comment">//字符串拼接，一般直接用+</span></span><br></pre></td></tr></table></figure><h4 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//替换功能</span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> old, <span class="keyword">char</span> new)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(String old, String new)</span></span>;</span><br><span class="line"><span class="comment">//去除字符串两空格</span></span><br><span class="line"><span class="function">String <span class="title">trim</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//按字典顺序比较两个字符串</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareToIgnoreCase</span><span class="params">(String str)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h2><p><code>String</code>是不可变的字符序列（不可变是指其堆或常量池内容，引用可变）</p><p><code>StringBuffer</code> 是可变的</p><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer();   <span class="comment">//构造一个不带字符的字符串缓冲区，初始容量为16个字符</span></span><br><span class="line">StringBuffer(CharSequence seq);</span><br><span class="line">StringBuffer(<span class="keyword">int</span> capacity);<span class="comment">//不带字符，指定初始容量</span></span><br><span class="line">StringBuffer(String str);<span class="comment">//构造一个字符缓冲区，并将内容初始化为指定字符串内容，16+str长度</span></span><br></pre></td></tr></table></figure><p><code>length()</code>：容器实际字符个数，实际值</p><p><code>capacity()</code>：容器初始容量，理论值</p><h3 id="常用方法API"><a href="#常用方法API" class="headerlink" title="常用方法API"></a>常用方法API</h3><h4 id="添加功能"><a href="#添加功能" class="headerlink" title="添加功能"></a>添加功能</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StringBuffer <span class="title">append</span><span class="params">(String str)</span></span>;<span class="comment">//把任意类型数据添加到缓冲区，并返回缓冲区本身(地址)</span></span><br><span class="line"><span class="comment">//同引用多次调用，影响的是堆上内容，返回的都是同一个地址</span></span><br><span class="line"><span class="function">StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, String str)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="删除功能"><a href="#删除功能" class="headerlink" title="删除功能"></a>删除功能</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StringBuffer <span class="title">deleteCharAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function">StringBuffer <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;<span class="comment">//包含头，不包含尾</span></span><br></pre></td></tr></table></figure><h4 id="替换和反转功能"><a href="#替换和反转功能" class="headerlink" title="替换和反转功能"></a>替换和反转功能</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StringBuffer <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str)</span></span>;</span><br><span class="line"><span class="function">StringBuffer <span class="title">reverse</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="截取功能"><a href="#截取功能" class="headerlink" title="截取功能"></a>截取功能</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="String-相互转换"><a href="#String-相互转换" class="headerlink" title="String 相互转换"></a>String 相互转换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String --&gt; StringBuffer</span><br><span class="line"><span class="comment">//通过构造方法</span></span><br><span class="line"><span class="comment">//通过append()方法</span></span><br><span class="line">StringBuffer --&gt; String</span><br><span class="line"><span class="comment">//通过构造方法</span></span><br><span class="line"><span class="comment">//通过toString()</span></span><br><span class="line"><span class="comment">//通过subString(0,length)</span></span><br></pre></td></tr></table></figure><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>把int数组<code>{1,2,3}</code>转换成字符串<code>[1, 2, 3]</code></p><p>用<code>String</code>相关方法做，或者用<code>StringBuffer</code>做，<strong>用后者更好</strong>，因为前者过程中<strong>堆上</strong>会产生很多垃圾。</p><h3 id="String、StringBuffer、StringBuilder区别"><a href="#String、StringBuffer、StringBuilder区别" class="headerlink" title="String、StringBuffer、StringBuilder区别"></a>String、StringBuffer、StringBuilder区别</h3><ul><li><p>运行速度</p><p><code>StringBuilder</code> &gt; <code>StringBuffer</code> &gt;<code>String</code></p><p>　　<code>String</code>为字符串常量，而<code>StringBuilder</code>和<code>StringBuffer</code>均为字符串变量，即String对象一旦创建之后该对象是<strong>不可更改</strong>的，但后两者的对象是变量，是可以更改的。</p><p>​    正式因为不可改，所以当参数传递的时候，<code>String</code>传递过去等于值传递。</p></li><li><p>线程安全</p><p><code>StringBuilder</code>是线程不安全的，而<code>StringBuffer</code>是线程安全的</p><p><a href="https://www.cnblogs.com/su-feng/p/6659064.html" target="_blank" rel="noopener">参考链接</a></p></li></ul><blockquote><p>总结</p><p>String：适用于<strong>少量</strong>的字符串操作的情况</p><p>StringBuilder：适用于<strong>单线程</strong>下在字符缓冲区进行<strong>大量</strong>操作的情况</p><p>StringBuffer：适用<strong>多线程</strong>下在字符缓冲区进行<strong>大量</strong>操作的情况</p></blockquote><h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><p>冒泡、选择、二分查找（有序），自己写实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] a, intkey)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="变参"><a href="#变参" class="headerlink" title="变参"></a>变参</h3><ul><li><p>格式</p><ul><li><p>修饰符 返回值类型 方法名(数据类型…  变量名){}</p><p><code>public static void print(int ... arr)</code></p></li></ul></li><li><p>注意事项：</p><ul><li>这里的变量其实是一个数组</li><li>如果一个方法有可变参数，并且有多个参数，那么，可变参数肯定是最后一个</li></ul></li></ul><h2 id="基本数据类包装类"><a href="#基本数据类包装类" class="headerlink" title="基本数据类包装类"></a>基本数据类包装类</h2><p>byte    –&gt;    Byte</p><p>short              Short</p><p>int            Integer</p><p>long        Long</p><p>float         Float</p><p>double        Double</p><p>char        Character</p><p>boolean        Boolean</p><h3 id="Integer为例"><a href="#Integer为例" class="headerlink" title="Integer为例"></a>Integer为例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Interger.toBinaryString();</span><br><span class="line">Interger.toOctalString();</span><br><span class="line">Interger.toOHexString();</span><br></pre></td></tr></table></figure><h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer(<span class="keyword">int</span> value);</span><br><span class="line">Integer(String s);</span><br></pre></td></tr></table></figure><h3 id="String-和-int-相互转换"><a href="#String-和-int-相互转换" class="headerlink" title="String 和 int 相互转换"></a>String 和 int 相互转换</h3><ul><li><p><code>int</code> –&gt; <code>Sring</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">法<span class="number">1</span>：和<span class="string">""</span>拼接</span><br><span class="line">法<span class="number">2</span>：<span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">法<span class="number">3</span>：<span class="keyword">int</span> --&gt; Interger --&gt; String(Integer类的toString())</span><br><span class="line">法<span class="number">4</span>：<span class="function"><span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i)</span></span>;(Inter类的静态方法)</span><br></pre></td></tr></table></figure></li><li><p><code>String</code> –&gt; <code>int</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String --&gt; Integer --&gt; <span class="keyword">int</span></span><br><span class="line">   - Integer i = <span class="keyword">new</span> Interger(str)</span><br><span class="line">   - <span class="keyword">int</span> i2 = i.intValue()</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s)</span></span>;</span><br><span class="line"><span class="comment">//基本数据类型包装类，都有parseXxx()转换成基本数据类型</span></span><br><span class="line"><span class="comment">//char不行，需要toCharArray()</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="JDK5特性：自动装箱拆箱"><a href="#JDK5特性：自动装箱拆箱" class="headerlink" title="JDK5特性：自动装箱拆箱"></a>JDK5特性：自动装箱拆箱</h3><p>自动装箱：基本类型转成包装类型   <code>Integer.valueOf</code></p><p>自动拆箱：反之亦然    <code>i.intValue</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">100</span>;  <span class="comment">//隐调用 i = Integer.valueOf(100)</span></span><br><span class="line">i += <span class="number">200</span>;   <span class="comment">//隐调用 Integer.valueOf.(i.intValue() + 200).</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>在使用 Integer x = null 代码会出现空指针异常</p><p>建议先判断是否为null，然后再使用</p></blockquote><h3 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="keyword">new</span> Integer(<span class="number">97</span>);</span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">97</span>);</span><br><span class="line">System.out.println(i1 == i2);  <span class="comment">//false</span></span><br><span class="line">System.out.println(i1.equals(i2));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Integer i3 = <span class="keyword">new</span> Integer(<span class="number">197</span>);</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">197</span>);</span><br><span class="line">System.out.println(i3 == i4);  <span class="comment">//false</span></span><br><span class="line">System.out.println(i3.equals(i4));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Integer i5 = <span class="number">97</span>;  <span class="comment">//自动装箱了</span></span><br><span class="line">Integer i6 = <span class="number">97</span>;</span><br><span class="line">System.out.println(i5 == i6);  <span class="comment">//true</span></span><br><span class="line">System.out.println(i5.equals(i6));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* -128到127是byte取值范围，如果在该范围内，自动装箱就不会创新对象，而是从常量池中获取 </span></span><br><span class="line"><span class="comment">* 如果超过了byte取值范围就会再新创建对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">Integer i7 = <span class="number">197</span>;</span><br><span class="line">Integer i8 = <span class="number">197</span>;</span><br><span class="line">System.out.println(i7 == i8);  <span class="comment">//false</span></span><br><span class="line">System.out.println(i7.equals(i8));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>基于上述最后的分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>在第一次创建`Integer`对象时，自动装箱会用到`IntegerCache`这个内部类，加载该内部类`.class`文件，同时该类内部有`static`代码块，执行后生成`IntegerCache.cache[0-255]`缓存数组并存放于常量池。在jdk1.6后，最大值映射到 `java.lang.Integer.IntegerCache.high`，可以使用 JVM 的启动参数设置最大值。这使我们可以根据应用程序的实际情况灵活地调整来提高性能。</code></pre><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ul><li>描述或匹配一系列符合规则字符串，用来检测注册账号、邮箱，手机号码等。</li><li>调用字符串类方法<code>public boolean matches(String regex)</code></li></ul><h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3><ul><li><p>简单类</p><ul><li>[abc]：   a、b或c （简单类）</li><li>[^abc]：  任何字符，除了a、b或c</li><li>[a-zA-Z] ：a到z 或 A到Z</li><li>[a-d[m-p]]   &lt;=&gt; [a-dm-p]</li><li>[a-z&amp;&amp;[def]]：d、e或、f（交集）</li></ul></li><li><p>预定义字符类</p><ul><li>.      任何字符：</li><li>\d    数字：<code>[0-9]</code>      \表示转义字符，所以需要<code>\\d</code></li><li>\D    非数字：<code>[^0-9]</code></li><li>\s     空白字符：    <code>[\t\n\x0B\f\r]</code></li><li>\S     非空白字符：<code>[^\s]</code></li><li>\w    单词字符：<code>[a-zA-Z_0-9]</code></li><li>\W    非单词字符：<code>[^\w]</code></li></ul></li></ul><h3 id="数量词"><a href="#数量词" class="headerlink" title="数量词"></a>数量词</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X?<span class="comment">//X一次或一次也没有   </span></span><br><span class="line">X*<span class="comment">//零次或多次</span></span><br><span class="line">X+<span class="comment">//一次或多次</span></span><br><span class="line">X&#123;n&#125;<span class="comment">//恰好n次</span></span><br><span class="line">X&#123;n,&#125;<span class="comment">//至少n次</span></span><br><span class="line">X&#123;n,m&#125;<span class="comment">//至少n次，但不超过m次</span></span><br></pre></td></tr></table></figure><h3 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"xyc.你我他.@%$"</span>;   <span class="comment">//xyc..你我他..@%$</span></span><br><span class="line">String[] arr = s.split(<span class="string">"\\."</span>);  </span><br><span class="line"><span class="comment">//arr = ["xyc, "你我他", "@%$"]   结果会有5个,["xyc, "", "你我他", "", "@%$"]</span></span><br></pre></td></tr></table></figure><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p><code>&quot;(.)\\1(.)\\2&quot;</code>        <code>()</code>表示一组，<code>\\1</code>表示第一组又出现1次，<code>\\2</code>表示第二组又出现1次</p><p>练习：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"我....我...我.要...要要...要学......学.编..编编编.编.程.程.程..程"</span>;</span><br><span class="line">String s2 = s.replaceAll(<span class="string">"\\.+"</span>, <span class="string">""</span>);</span><br><span class="line">String s3 = s2.replaceAll(<span class="string">"(.)\\1+"</span>, <span class="string">"$1"</span>); <span class="comment">//$1代表第一组内容</span></span><br></pre></td></tr></table></figure><blockquote><p>注意 </p><p> <code>.?</code>   <code>.*</code>   <code>.+</code>   理解</p></blockquote><h3 id="Pattern-和-Matcher"><a href="#Pattern-和-Matcher" class="headerlink" title="Pattern 和 Matcher"></a>Pattern 和 Matcher</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pattern p = Pattern.compile(<span class="string">"a*b"</span>); <span class="comment">//获取正则表达式</span></span><br><span class="line">Matcher m = p.matcher(<span class="string">"aaaab"</span>);    <span class="comment">//获取匹配器</span></span><br><span class="line"><span class="keyword">boolean</span> b = m.matches();<span class="comment">//看是否能匹配</span></span><br></pre></td></tr></table></figure><p>案例：获取手机号码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"广告词13456473832,广告词18723940579"</span>;</span><br><span class="line">Pattern p = Pattern.compile(<span class="string">"1[3578]\\d&#123;9&#125;"</span>); <span class="comment">//获取正则表达式</span></span><br><span class="line">Matcher m = p.matcher(s);    <span class="comment">//获取匹配器</span></span><br><span class="line"><span class="keyword">while</span>(m.find()) &#123;</span><br><span class="line">    System.out.println(m.group());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><p><code>abs()</code>  <code>ceil()</code>  <code>floor()</code>  <code>round()</code></p><p><code>max()</code>  <code>pow()</code>  <code>random()</code>  <code>sqrt()</code></p><h3 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random(); <span class="comment">//默认系统时间ns值作为种子</span></span><br><span class="line"><span class="keyword">int</span> x = r.nextInt(<span class="number">100</span>);  <span class="comment">//0到100不包括100</span></span><br></pre></td></tr></table></figure><h3 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span></span>; <span class="comment">//运行垃圾回收器  配合重写Object类中finalize()垃圾回收前工作</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>; <span class="comment">//非0状态是异常终止，退出jvm</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">currentTimeMillis</span><span class="params">()</span></span>; <span class="comment">//1970年1月1日到现在ms，可用来计算运行时间</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src, <span class="keyword">int</span> srcPos, Object dest, <span class="keyword">int</span> destPos, <span class="keyword">int</span> length)</span></span>; <span class="comment">//拷贝数组,集合实现底层基础</span></span><br></pre></td></tr></table></figure><h3 id="BigInteger类"><a href="#BigInteger类" class="headerlink" title="BigInteger类"></a>BigInteger类</h3><ul><li><p>概述</p><ul><li>可以让超过Integer范围内的数据进行运算</li></ul></li><li><p>构造方法</p><ul><li><code>public BigInteger(String val)</code></li></ul></li><li><p>成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BigInteger <span class="title">add</span><span class="params">(BigInteger val)</span></span>;</span><br><span class="line"><span class="function">BigInteger <span class="title">subtract</span><span class="params">(BigInteger val)</span></span>;</span><br><span class="line"><span class="function">BigInteger <span class="title">multiply</span><span class="params">(BigInteger val)</span></span>;</span><br><span class="line"><span class="function">BigInteger <span class="title">divide</span><span class="params">(BigInteger val)</span></span>;</span><br><span class="line">BigInteger[] divideAndRemainder(BigInteger val);</span><br></pre></td></tr></table></figure></li></ul><h3 id="BigDecimal类"><a href="#BigDecimal类" class="headerlink" title="BigDecimal类"></a>BigDecimal类</h3><ul><li>概述<ul><li>由于在运算的时候，float类型和double很容易丢失精度，演示案例。<ul><li>2.0 - 1.1  结果是0.8999999……所以需要更精确</li></ul></li><li>不可变的、任意精度的有符号十进制数。</li></ul></li><li><p>构造方法</p><ul><li><code>public BigDecimal(String val)</code>  推荐用字符串，若用<code>double</code>数还会有问题的</li></ul></li><li><p>成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BigDecimal <span class="title">add</span><span class="params">(BigDecimal augend)</span></span>;</span><br><span class="line"><span class="comment">//还有减、乘、除等</span></span><br></pre></td></tr></table></figure></li></ul><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal bd = <span class="keyword">new</span> BigDecimal(<span class="string">"2.0"</span>);</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">BigDecimal bd = BigDecimal.valueOf(<span class="number">2.0</span>);<span class="comment">//底层其实就是调用上面</span></span><br></pre></td></tr></table></figure><h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><ul><li><p>概述</p><p>表示特定瞬间，精确到毫秒</p></li><li><p>构造</p><ul><li><p><code>public Date()</code></p></li><li><p><code>public Date(long date)</code></p></li></ul></li><li><p>成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">long</span> time)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h4><ul><li><p>继承自DateFormat类</p></li><li><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleDateFormat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleDateFormat</span><span class="params">(String pattern)</span></span></span><br></pre></td></tr></table></figure></li><li><p>成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">format</span><span class="params">(Date date)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">parse</span><span class="params">(String source)</span></span></span><br></pre></td></tr></table></figure><p>案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line">SimpleDateFormat sdf = <span class="function">nwe <span class="title">SimpleDateFormat</span><span class="params">(<span class="string">"日期格式"</span>)</span></span>;</span><br><span class="line">sdf.format(d);<span class="comment">//格式化后字符串时间</span></span><br><span class="line"></span><br><span class="line">String str = <span class="string">"2018年10月31日23:54:30"</span>;</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日HH:mm:ss"</span>);</span><br><span class="line">Date d = sdf.parse(str);<span class="comment">//注意处理异常</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><ul><li><p>概述</p><p>​         <code>Calendar</code> 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。</p></li><li><p>成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> field)</span></span></span><br></pre></td></tr></table></figure><p>案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">c.get(Calendar.YEAR);</span><br><span class="line">c.get(Calendar.MONTH);      <span class="comment">//月，从0开始计</span></span><br><span class="line">c.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">c.get(Calendar.DAY_OF_WEEK);<span class="comment">//周日是第一天</span></span><br><span class="line">c.get(Calendar.Year);</span><br></pre></td></tr></table></figure></li><li><p>其他设置方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> field,<span class="keyword">int</span> amount)</span> <span class="comment">//对指定字段进行向前加或后减 (年月日)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> date)</span></span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础语法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java学习(1)</title>
      <link href="/2018/10/28/Java%E5%AD%A6%E4%B9%A01/"/>
      <url>/2018/10/28/Java%E5%AD%A6%E4%B9%A01/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p>本文为学习笔记，内容为己补充之用，非系统性字典。</p></blockquote><p><img src="/2018/10/28/Java学习1/2.jpg" alt=""></p><a id="more"></a><h2 id="Java环境配置"><a href="#Java环境配置" class="headerlink" title="Java环境配置"></a>Java环境配置</h2><ol><li><p>jdk更新，官网下载dmg安装，才能保证在/Libraray/Java/JavaVirturalMachines 中，控制面板更新的不在该路径。</p></li><li><p>设置jdk版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim ~/.bash_profile</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=<span class="string">"/Library/Java/JavaVirturalMachines/版本/Contents/Home"</span></span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure></li><li><p>查看版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/libexec/java_home  -V <span class="comment">#查看当前jdk包，及正在用的jdk</span></span><br><span class="line">java -version   <span class="comment">#jre版本</span></span><br><span class="line">javac -version  <span class="comment">#jdk版本</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="JDK-amp-JRE"><a href="#JDK-amp-JRE" class="headerlink" title="JDK &amp; JRE"></a>JDK &amp; JRE</h2><ul><li><p>JRE ：JVM+类库(Java程序所需的核心类库)，即Java程序<strong>运行</strong>环境。</p></li><li><p>JDK：java的开发工具（javac、jar等）+ JRE，即Java程序<strong>开发</strong>环境</p></li><li>JVM：java实现<strong>跨平台</strong>的最核心的部分。.class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。</li></ul><h2 id="Java语言基础"><a href="#Java语言基础" class="headerlink" title="Java语言基础"></a>Java语言基础</h2><h3 id="变量相加和常量相加区别"><a href="#变量相加和常量相加区别" class="headerlink" title="变量相加和常量相加区别"></a>变量相加和常量相加区别</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1 = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">byte</span> b2 = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">byte</span> b3 = b1 + b2;  <span class="comment">//编译error</span></span><br><span class="line"><span class="comment">//b1和b2是两个变量,变量里面存储的值都是变化的,所以在程序运行中JVM是无法判断里面具体的值</span></span><br><span class="line"><span class="comment">//byte类型的变量在进行运算的时候,会自动类型提升为int类型 ，而int类型数据相加为int类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> b4 = <span class="number">3</span> + <span class="number">4</span>;    <span class="comment">//编译right</span></span><br><span class="line"><span class="comment">//3和4都是常量,java有常量优化机制,就是在编译的的时候直接把3和4的结果赋值给b4了，判断了7在其范围内即可赋值</span></span><br></pre></td></tr></table></figure><h3 id="赋值运算符隐式强制转换"><a href="#赋值运算符隐式强制转换" class="headerlink" title="赋值运算符隐式强制转换"></a>赋值运算符隐式强制转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s=<span class="number">1</span>;s = s+<span class="number">1</span>;<span class="comment">//error</span></span><br><span class="line"><span class="keyword">short</span> s=<span class="number">1</span>;s+=<span class="number">1</span>;  &lt;=&gt;  s = (<span class="keyword">byte</span>)(s + <span class="number">1</span>) <span class="comment">// ++ --同理</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>Java中boolean类型不能通过其他类型隐式或显式转换</strong>(和js有区别)</p><p>&amp;&amp;  || ? :  if() 中表达式必须是严格的关系表达式，即结果必须是true或者false</p></blockquote><h3 id="位异或运算符的特点"><a href="#位异或运算符的特点" class="headerlink" title="位异或运算符的特点"></a>位异或运算符的特点</h3><ul><li>^的特点：一个数据对另一个数据位异或两次，该数本身不变。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">3</span>,b=<span class="number">4</span>;</span><br><span class="line"><span class="comment">//方式1：用位异或实现</span></span><br><span class="line">a = a ^ b;</span><br><span class="line"><span class="comment">// a^b^b=a</span></span><br><span class="line">b = a ^ b;</span><br><span class="line"><span class="comment">// a^b^a=b</span></span><br><span class="line">a = a ^ b;</span><br><span class="line"><span class="comment">// 方式2：一句话搞定</span></span><br><span class="line">b = (a + b) - (a = b);</span><br></pre></td></tr></table></figure><h3 id="switch语法"><a href="#switch语法" class="headerlink" title="switch语法"></a>switch语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)<span class="comment">//byte,short,char,int    枚举(JDK1.5)  String(JDK1.7)</span></span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>：</span><br><span class="line">    <span class="keyword">break</span>；</span><br><span class="line">    <span class="keyword">default</span>：</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ol><li><p>定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;  <span class="comment">//不允许动静结合(动态和静态初始化)[]中不能有数字</span></span><br><span class="line"><span class="keyword">int</span>[] arr2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125; ;</span><br></pre></td></tr></table></figure></li><li><p>二维数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">2</span>][];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[个数];</span><br><span class="line">arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[个数];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] arr = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="面向对象（OOP）"><a href="#面向对象（OOP）" class="headerlink" title="面向对象（OOP）"></a>面向对象（OOP）</h3><p>(Object Oriented Programming)</p><ul><li>特点：抽象、封装、继承、多态</li></ul><h4 id="内存图"><a href="#内存图" class="headerlink" title="内存图"></a>内存图</h4><p>（<a href="https://www.jianshu.com/p/6e2bc593f31c" target="_blank" rel="noopener">https://www.jianshu.com/p/6e2bc593f31c</a>)</p><p><img src="/2018/10/28/Java学习1/1.jpg" alt=""></p><p>对象创建过程步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="number">1</span>.Student.class加载进内存</span><br><span class="line"><span class="number">2</span>.栈内声明一个Student类型引用s</span><br><span class="line"><span class="number">3</span>.在堆内存创建对象,</span><br><span class="line"><span class="number">4</span>.给对象中属性默认初始化值  （基本数据类型为<span class="number">0</span>,<span class="number">0.0</span>,/u0000,<span class="keyword">false</span>，引用数据类型为<span class="keyword">null</span>）</span><br><span class="line"><span class="number">5</span>.属性进行显示初始化</span><br><span class="line"><span class="number">6</span>.构造方法进栈,对对象中的属性赋值,构造方法弹栈</span><br><span class="line"><span class="number">7</span>.将对象的地址值赋值给s</span><br></pre></td></tr></table></figure><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><ul><li>随着类的加载而加载，随着类的消失而消失</li><li>优先于对象存在</li><li>被类的所有对象共享</li></ul><blockquote><p>注意点：</p><ol><li>静态方法中是没有this关键字的，所以静态方法只能访问静态的成员变量和静态的成员方法</li><li>简记：静态只能访问静态</li></ol></blockquote><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><ul><li>代码块概述<ul><li>在Java中，使用{}括起来的代码被称为代码块。</li></ul></li><li>代码块分类<ul><li>根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块(多线程)。</li></ul></li><li>常见代码块的应用<ul><li>局部代码块 <ul><li>在方法中出现；限定变量生命周期，及早释放，提高内存利用率</li></ul></li><li>构造代码块 (初始化块)<ul><li>在类中方法外出现；多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行</li></ul></li><li>静态代码块 <ul><li>在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，并且只执行一次。</li><li>一般用于加载驱动</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Student 静态代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">System.out.println(<span class="string">"Student 构造代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Student 构造方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"Main静态代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"我是main方法"</span>);</span><br><span class="line"></span><br><span class="line">Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">Student s2 = <span class="keyword">new</span> Student();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><blockquote><p>子类只能继承父类所有非私有的成员(成员方法和成员变量)</p><p>子类不能继承父类的构造方法，但是可以通过super去访问父类构造方法。</p></blockquote><ol><li>this 和 super</li></ol><ul><li><p><code>this</code> 和 <code>super</code>都代表什么</p><ul><li><code>this</code>:代表当前对象的引用,谁来调用我,我就代表谁</li><li><code>super</code>:代表当前对象父类的引用</li></ul></li><li><p><code>this</code> 和 <code>super</code>的使用区别</p><ul><li><p>调用成员变量</p><ul><li>this.成员变量 调用本类的成员变量,也可以调用父类的成员变量</li><li>super.成员变量 调用父类的成员变量</li></ul></li><li><p>调用构造方法</p><ul><li><p>this(…)    调用本类的构造方法</p></li><li><p>super(…)    调用父类的构造方法</p><blockquote><p>this()或super()必须放在构造函数第一行</p></blockquote></li></ul></li><li><p>调用成员方法</p><ul><li>this.成员方法 调用本类的成员方法,也可以调用父类的方法</li><li>super.成员方法 调用父类的成员方法</li></ul></li></ul></li></ul><ol start="2"><li>方法重写(覆盖)override</li></ol><ul><li>什么是方法重写<ul><li>重写:子父类出现了一模一样的方法(注意:返回值类型可以是子父类,这个我们学完面向对象讲) </li></ul></li><li><p>方法重写的应用：</p><ul><li>当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法。这样，即沿袭了父类的功能，又定义了子类特有的内容。</li></ul></li><li><p>重写<strong>注意</strong>事项</p><ul><li>子类重写父类方法时，访问权限不能更低<ul><li>最好就一致</li></ul></li><li>父类静态方法，子类也必须通过静态方法进行重写<ul><li>其实这个算不上方法重写，但是现象确实如此，至于为什么算不上方法重写，多态中我会讲解(静态只能覆盖静态)</li></ul></li></ul></li></ul><ol start="3"><li><p><code>final</code></p><ul><li><p>修饰类，类不能被继承</p></li><li><p>修饰变量，变量就变成了常量，只能被赋值一次</p><blockquote><p>基本类型，是值不能被改变         引用类型，是地址值不能被改变,对象中的属性可以改变</p></blockquote></li><li><p>修饰方法，方法不能被重写</p></li></ul></li></ol><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><ol><li><p>前提</p><ul><li>出现继承</li><li>方法重写</li><li>父类引用指向子类对象</li></ul></li><li><p>多态成员访问特点</p><ul><li>成员变量<ul><li>编译看左边（父类），运行看左边（父类）</li></ul></li><li>成员方法<ul><li>编译看左边（父类），运行看右边（子类）</li></ul></li><li>静态方法<ul><li>编译看左边（父类），运行看左边（父类）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        show2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"爱"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"你"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> B();</span><br><span class="line">        a.show();</span><br><span class="line">        </span><br><span class="line">        B b = <span class="keyword">new</span> C();</span><br><span class="line">        b.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><ol><li><p>特点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名 </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> 方法名() &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类或接口</li><li>抽象类不能实例化，可以按照多态子类实例化赋值给抽象类引用</li><li>抽象类子类<ul><li>要么是抽象类</li><li>要么重写抽象类中所有抽象方法</li></ul></li></ul></li><li><p>成员特点</p><ul><li>成员变量：可以变量、常量。abstract不能用来修饰成员变量</li><li>构造方法：存在，用于子类访问父类数据的初始化</li><li>成员方法：可以是抽象、非抽象</li></ul></li><li><font color="red"><code>abstract</code></font>关键字不能与那些共存<ul><li><font color="red"><code>static</code></font>:类型.method()没用意义</li><li><font color="red"><code>final</code></font>：需要让子类去重写</li><li><font color="red"><code>private</code></font>：需要子类可访问并对它重写</li></ul></li></ol><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> 接口名 </span>&#123;    <span class="comment">//接口没有构造方法,所以其成员变量必须初始化</span></span><br><span class="line">    <span class="keyword">int</span> varible = <span class="number">0</span>;     <span class="comment">//默认自带 public static final</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;   <span class="comment">//默认自带 public abstract</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> 接口名 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修饰符小结"><a href="#修饰符小结" class="headerlink" title="修饰符小结"></a>修饰符小结</h4><ul><li><p>修饰符：</p><ul><li>权限修饰符：private , 默认 , protected , public</li><li>状态修饰符：static , final</li><li>抽象修饰符：abstract</li></ul></li><li><p>类：</p><ul><li><p>public , 默认</p></li><li><p>final</p></li><li><p>abstract</p></li></ul></li><li><p>成员变量：</p><ul><li>private , 默认 , protected , public</li><li>static , final</li></ul></li><li><p>构造方法:</p><ul><li>private , 默认 , protected , public</li></ul></li><li><p>成员方法：</p><ul><li>private , 默认 , protected , public</li><li>static , final</li><li>abstract</li></ul></li></ul><h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><ul><li>内部类可以直接访问外部类的成员 via <code>Outer.this</code></li><li>外部类要访问内部类成员，必须创建对象</li></ul><ol><li><p>实名内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">30</span>;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.num);</span><br><span class="line">            System.out.println(Outer.<span class="keyword">this</span>.num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer.Inner oi = <span class="keyword">new</span> Outer().new Inner();<span class="comment">//创建内部类对象</span></span><br><span class="line">        oi.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>静态成员内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Outer.Inner oi = <span class="keyword">new</span> Outer.Inner();</span><br></pre></td></tr></table></figure></li><li><p>局部内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">10</span>;  <span class="comment">//必须为final,如果下面局部内部类要访问的话</span></span><br><span class="line">                                 <span class="comment">//jdk1.8取消了</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                 System.out.println(num); </span><br><span class="line">                <span class="comment">//为什么上面必须为final</span></span><br><span class="line">                <span class="comment">//因为如果是变量，周期随着method结束就没了，而对象可能还未被回收。</span></span><br><span class="line">                <span class="comment">//只有进内存方法区常量池，才能保持生命周期</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner i = <span class="keyword">new</span> Inner();</span><br><span class="line">        i.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>匿名内部类</p><ul><li><p>前提：存在一个类或者接口（可以是抽象类）</p></li><li><p>本质：继承了该类或实现了该接口的子类匿名对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方法1</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> <span class="keyword">implements</span> <span class="title">Inter</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             System.out.println(<span class="string">"num"</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//Inner i = new Inner();</span></span><br><span class="line">        <span class="comment">//i.print();</span></span><br><span class="line">     <span class="comment">//方法2   匿名内部类实现及实例化</span></span><br><span class="line">        <span class="comment">//写法1</span></span><br><span class="line">        <span class="keyword">new</span> Inter() &#123;    <span class="comment">//固定格式，实现Inter接口 或者继承这个类</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//重写抽象方法</span></span><br><span class="line">        &#125;.print();</span><br><span class="line">        <span class="comment">//写法2推荐，</span></span><br><span class="line">        <span class="comment">// 弊端：但该方法无法调用子类特有的方法，因为编译看的左边(父类)无法通过</span></span><br><span class="line">        <span class="comment">// 原因：如果要调用子类，必须向下强转成子类对象引用，然而是匿名，无法强转</span></span><br><span class="line">        Inter i = <span class="keyword">new</span> Inter()&#123;     <span class="comment">//Inter父类对象引用，new出来的是子类对象，多态</span></span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//重写抽象方法</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>工程中应用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">        p.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PersonDemo pd = <span class="keyword">new</span> PersonDemo();</span><br><span class="line">        pd.method(<span class="keyword">new</span> Person()&#123; <span class="comment">//匿名内部类当参数传递，利用了多态，匿名子对象</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">               System.out.println(<span class="string">"匿名内部类方法重写"</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础语法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Welcome</title>
      <link href="/2018/10/12/welcome/"/>
      <url>/2018/10/12/welcome/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p>坚 持 <br>每 周 更 新 一 篇 博 文</p></blockquote><p><img src="https://image-link.nos-eastchina1.126.net/welcome"></p><a id="more"></a>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>CSS — 层叠样式表</title>
      <link href="/2018/06/25/CSS%20%E2%80%94%20%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/"/>
      <url>/2018/06/25/CSS%20%E2%80%94%20%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="常见属性"><a href="#常见属性" class="headerlink" title="常见属性"></a>常见属性</h2><h3 id="文字属性"><a href="#文字属性" class="headerlink" title="文字属性"></a>文字属性</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="comment">/*1.规定文字样式的属性*/</span></span><br><span class="line">    <span class="attribute">font-style</span>:italic  (normal);</span><br><span class="line">    <span class="comment">/*2.规定文字粗细的属性*/</span></span><br><span class="line">    <span class="attribute">font-weight</span>: bold;   <span class="comment">/*单词取值：bold 加粗  bolder更粗  数字取值：100-900之间整百数字*/</span></span><br><span class="line">    <span class="comment">/*3.规定文字大小的属性*/</span></span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="comment">/*4.规定文字字体的属性*/</span></span><br><span class="line">    <span class="attribute">font-family</span>:<span class="string">"微软雅黑"</span>,<span class="string">"备选字体"</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*简写style weight size family*/</span></span><br><span class="line">    <span class="attribute">font</span>:italic bold <span class="number">10px</span> <span class="string">"楷体"</span>; <span class="comment">/*size和family不能省略，且一定要放最后*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>关于字体：</li></ul><blockquote><ol><li><p>如果取值是中文要用引号，且字体必须是用户电脑上已安装的字体。</p></li><li><p>英文不可以处理中文，中文可以处理英文</p><p>  “Times New Roman”,”微软雅黑”可以单独处理英文和中文字体</p></li></ol></blockquote><h3 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="comment">/*1.文本装饰属性*/</span></span><br><span class="line">    text-decoration: underline;(line-through,overline,none去掉超链接下划线)</span><br><span class="line">    <span class="comment">/*2.水平对齐的属性*/</span></span><br><span class="line">    <span class="selector-tag">text-aligh</span>: <span class="selector-tag">center</span> (<span class="selector-tag">right</span>,<span class="selector-tag">left</span>);</span><br><span class="line">    <span class="comment">/*3.缩进的属性*/</span></span><br><span class="line">    <span class="selector-tag">text-indent</span>: 2<span class="selector-tag">em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="颜色属性"><a href="#颜色属性" class="headerlink" title="颜色属性"></a>颜色属性</h3><p>color：</p><ol><li>英文单词：</li><li>rgb</li><li>rgba：rgba(255,0,0,a) a取值为0~1，表示透明度</li><li>十六进制：#FF0000</li><li>十六进制缩写：#F00，每两位都一样可简写</li></ol><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    background-color;</span><br><span class="line">    <span class="selector-tag">background-image</span><span class="selector-pseudo">:url()</span>;</span><br><span class="line">    <span class="selector-tag">background-repeat</span><span class="selector-pseudo">:repeat</span> <span class="comment">/*图片平铺方式*/</span> </span><br><span class="line">          <span class="selector-tag">no-repeat</span></span><br><span class="line">              <span class="selector-tag">repeat-x</span></span><br><span class="line">                    <span class="selector-tag">repeat-y</span>;</span><br><span class="line">    <span class="selector-tag">background-position</span><span class="selector-pseudo">:left</span>    <span class="selector-tag">top</span>;   (<span class="selector-tag">x</span>,<span class="selector-tag">y</span>)不平铺</span><br><span class="line">                        <span class="selector-tag">center</span>  <span class="selector-tag">center</span></span><br><span class="line">                        <span class="selector-tag">right</span>   <span class="selector-tag">bottom</span></span><br><span class="line">                        100<span class="selector-tag">px</span>   200<span class="selector-tag">px</span>  (可为负，则移出，精灵图切图用)</span><br><span class="line">    <span class="selector-tag">background-attachment</span>: <span class="selector-tag">scroll</span> (<span class="selector-tag">fixed</span>);</span><br><span class="line"><span class="comment">/*缩写，任意属性都可以省略*/</span></span><br><span class="line">    <span class="selector-tag">background</span>：背景颜色 图片 平铺 关联 定位</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>背景图片和插入图片的区别</p></blockquote><ul><li>bg不会占用位置，插入会</li><li>背景图片好定位，插入无定位属性，不好控制</li><li>插入图片语义强，要被搜索引擎收录，推荐用插入</li></ul><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><p> p{}</p><h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h3><p>形式:    #id{}，id唯一</p><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><p>  .classname{}</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class="类名1 类名2"&gt;文本&lt;/p&gt;</span><br></pre></td></tr></table></figure><h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><p>标签1 标签2…标签n{}一代代找下去</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>(<span class="selector-tag">id</span>和<span class="selector-tag">calss</span>均可)   <span class="selector-tag">p</span>&#123;&#125;<span class="comment">/*后代不仅仅是儿子，孙子全是*/</span></span><br><span class="line">&lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="子选择器"><a href="#子选择器" class="headerlink" title="子选择器"></a>子选择器</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&gt;<span class="selector-tag">p</span>&#123;&#125;   <span class="comment">/*只找子一代*/</span></span><br><span class="line">&lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h3><p>选择器1选择器2{}</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.para1</span>&#123;&#125;<span class="comment">/*开发用的不多*/</span></span><br><span class="line">&lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;p class="para1"&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h3><p>选择器1，选择器2{}</p><h3 id="兄弟选择器"><a href="#兄弟选择器" class="headerlink" title="兄弟选择器"></a>兄弟选择器</h3><ul><li><p>相邻兄弟选择器CSS2：给指定选择器1后紧跟那个选择器2选中标签（<strong>1</strong>个）设值</p><p>（不能隔开，必须同级相邻上下）</p><p>选择器1+选择器2{}  eg: <code>div+h1{}</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;h1&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure></li><li><p>通用兄弟选择器CSS3</p><p>选择器1~选择器2      无论隔不隔开均可（可多个）</p></li></ul><h3 id="序选择器"><a href="#序选择器" class="headerlink" title="序选择器"></a>序选择器</h3><p>（CSS3）</p><ul><li><p>同级第几个</p><p>p:first-child{}  若第一个标签不是p则无效</p><p>  :last-child{}   :nth-child(n){}  :nth-last-child(n){} </p><p>  :only-child{}  子标签只有一个标签</p><ul><li>:nth-child(odd)奇数</li><li>:nth-child(xn+y)用户自定义</li></ul></li><li><p>同级同类第几个</p><p>p:first-of-type{} 只要同级下面仍有p仍有效</p></li></ul><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><p>p[class]  p[id]  input[type=password]</p><ul><li><p>属性的取值以什么开头</p><p>[attribute|=value] css2 有局限value字符必须-隔开</p><p>[attribute^=value] css3</p></li><li><p>属性的取值以什么结尾</p><p>[attribute$=value] css3</p></li><li><p>属性取值是否包含某个特定的值</p><p>[attribute~=value] css2</p><p>[attribute*=value] css3</p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[class = box]</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class="box"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h3><p>*{} 一般不用，测试时可用于全局初始化。</p><h2 id="CSS三大特性"><a href="#CSS三大特性" class="headerlink" title="CSS三大特性"></a>CSS三大特性</h2><h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><ul><li>只有以color/font-/text-/line开头的属性才可以继承</li><li>所有后代均可继承</li><li>特殊性<ul><li><a>文字颜色和下划线不能继承</a></li><li>h标签文字大小无法继承</li></ul></li></ul><p>body{}</p><h3 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h3><p>CSS处理冲突，多个选择器选中同个标签，又设置了相同属性。</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><ul><li><p>是否直接选中（间接选中指代继承）</p><p> 间接选中，就近原则。</p></li><li><p>是否是相同选择器</p><p>都是直接选中，都是同类型选择器，谁写在后面就执行谁的</p></li><li><p>是否不同选择器</p><p>如果是直接选中，并且是不同类型</p><p>id&gt;类&gt;标签&gt;通配符&gt;继承&gt;浏览器默认</p></li></ul><blockquote><p>Important 只能用于直接选中，不能用于间接选中，提至最高</p></blockquote><p><code>*{color:red !important;}</code></p><blockquote><p>优先级权重（直接选中时才计算）</p></blockquote><p><strong>权重：</strong>多个后代选择器时，id个数多最高，类名数目次之，标签数目…若还是同，谁写在后面听谁</p><h2 id="CSS显示模式"><a href="#CSS显示模式" class="headerlink" title="CSS显示模式"></a>CSS显示模式</h2><h3 id="div和span标签"><a href="#div和span标签" class="headerlink" title="div和span标签"></a>div和span标签</h3><ol><li>div一般用于配合CSS完成网页基本布局</li><li>span用于配合CSS修改网页中一些局部信息</li><li>div和span区别？<ul><li>div会单独占一行，span为行内</li><li>div是容器级标签，而span是文本级<ul><li>容器级中可以嵌套所有其他标签</li><li>文本级中只能嵌套文字/超链接/图片</li></ul></li></ul></li></ol><h3 id="显示模式"><a href="#显示模式" class="headerlink" title="显示模式"></a>显示模式</h3><p>CSS中将标签分两类，块级和行内元素</p><p>区别：</p><ul><li><p>块级</p><ul><li>独占一行</li><li>if 没设置width，那么默认和父元素一样宽</li><li>if 设置了height，那么就按照设置来显示，默认为<strong>0px</strong>，会被内容撑起来，(浮动不可以)</li><li>要想使其在父级元素中水平居中，只能用<code>margin:0 auto;</code></li></ul></li><li><p>行内</p><ul><li>不会独占一行</li><li>如果没有设置宽度，那么默认和内容一样宽</li><li>行内元素不能设置width和height</li><li>父级  <code>text-align:center;</code>可使其水平居中  </li></ul></li><li><p>行内块级元素</p><p>不独占一行也能设置width和height： <img></p></li></ul><h3 id="显示模式转换"><a href="#显示模式转换" class="headerlink" title="显示模式转换"></a>显示模式转换</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    display: inline; (行内)</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">span</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: block；（块级）(inline-block 行内块级)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><ul><li><p>边框属性</p><ul><li><p>连写（同时设置四条边的边框）</p><p>border: 边框的宽度  样式  颜色;</p></li><li><p>连写（分别设置四条边的边框）</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">border-top</span>:<span class="number">1px</span> solid red;</span><br><span class="line">border-right;</span><br><span class="line"><span class="selector-tag">border-bottom</span>;</span><br><span class="line"><span class="selector-tag">border-left</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border-width</span>:上 右 下 左;</span><br><span class="line">    <span class="attribute">border-style</span>:上 右 下 左;</span><br><span class="line">    <span class="attribute">border-color</span>:上 右 下 左;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    上 右 下  =&gt;   左=右</span></span><br><span class="line"><span class="comment">    上 右    =&gt;   左=右  下=上</span></span><br><span class="line"><span class="comment">    上      =&gt;   右下左 = 上</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>注意点：</p></blockquote><ol><li>连写中颜色可以省略，默认为黑</li><li>样式不能省略，省略后看不到边框</li><li>宽度可以省略</li></ol></li></ul><h3 id="内边距"><a href="#内边距" class="headerlink" title="内边距"></a>内边距</h3><p>边框和内容之间的间距</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">padding-top</span>:;</span><br><span class="line">    <span class="attribute">padding-right</span>:;</span><br><span class="line">    <span class="attribute">padding-bottom</span>:;</span><br><span class="line">    <span class="attribute">padding-left</span>:;    <span class="comment">/*会影响标签本身的大小*/</span></span><br><span class="line">    <span class="attribute">padding</span>:;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  1.增加了padding后元素的宽高也会发生变化</span></span><br><span class="line"><span class="comment">  2.如果增加了padding后仍想保持元素即盒子（不包括margin)的宽高，那就必须减去内容的宽高</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h3><p>标签与标签之间的间距</p><p>margin-top (right bottom left)</p><p><strong>*</strong>    外边距在水平方向不会出现合并现象即（正常叠加），只有<strong>垂直方向</strong>会有合并的现象。谁大听谁的。</p><blockquote><ul><li>内容大小:         content</li><li>元素大小:         content、padding、boder</li><li>元素空间大小  content、padding、boder、margin</li></ul></blockquote><h3 id="box-sizing属性"><a href="#box-sizing属性" class="headerlink" title="box-sizing属性"></a>box-sizing属性</h3><ol><li>css3中新增的属性，该属性可以保证盒子新增padding和border后，盒子元素的高度和宽度不变</li><li>通过改变内容宽高来实现整体元素不变的</li><li>box-sizing：<ul><li>content-box    元素的宽高 = 边框 + 内边距 +内容宽高</li><li>border-box      width/height的宽高, 修改padding和border，元素大小不变</li></ul></li></ol><blockquote><p>注意点</p><ul><li>如果两个盒子是嵌套关系，那么设置了里面一个盒子的margin-top，外面一个盒子也会被顶下来</li><li>如果外面盒子不想被顶下来，那么可以给外面的盒子添加一个边框属性</li><li>企业开发中，一般如果需要控制嵌套父子盒子之间的距离，首先考虑用padding，margin本质用于控制兄弟之间的间隙</li></ul></blockquote><p><code>margin:0 auto</code>：只对水平方向居中有效，对垂直无效。让盒子水平居中。</p><p>​                盒子中内容居中要使用<code>text-align</code></p><h3 id="行高和盒子高度"><a href="#行高和盒子高度" class="headerlink" title="行高和盒子高度"></a>行高和盒子高度</h3><p>line-height设置行高，当line-height = height（内容的高度），保证一行文字在盒子中垂直居中。多行垂直居中只能靠padding</p><h3 id="居中小结"><a href="#居中小结" class="headerlink" title="居中小结"></a>居中小结</h3><p>水平方向：盒子居中   <code>margin:0 auto</code></p><p>​                   内容居中   <code>text-align:center</code>   包括文本，图像，以及行内、行内块级元素</p><p>垂直方向：单行文字居中   <code>line-height: 外面大盒子内容高度</code></p><p>​                    盒子、多行文字居中，靠padding设置</p><h2 id="网页布局"><a href="#网页布局" class="headerlink" title="网页布局"></a>网页布局</h2><p>盒模型：IE盒子模型（舍弃）和W3C盒子模型</p><p>​        标准 W3C 盒子模型的范围包括 margin,border,padding,content,并且 content 部分不包含其他部分。</p><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><h4 id="布局方式"><a href="#布局方式" class="headerlink" title="布局方式"></a>布局方式</h4><ul><li><p>标准流（文档流/普通流）</p><ul><li>浏览器默认排版方式</li><li>在CSS中元素分为3类：块级/行内/行内块级</li><li>标准流垂直、水平排版</li></ul></li><li><p>浮动流</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box1</span>&#123;</span><br><span class="line">    float:left ;(right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>浮动流是一种“半脱离标准流”排版方式 </p></li><li><p>只能水平排版，只能设置某个元素在父元素下左对齐或右对齐</p><ul><li><p>注意点 </p><p>无居中对齐，且<code>margin: 0  auto</code>无法设置水平居中</p></li></ul></li></ul><blockquote><p>特点</p></blockquote><ol><li>浮动流不区分块级/行内/行内块级，均可水平排版</li><li>所有元素均可设置宽高</li><li>综上所述，类似标准流的行内块级</li></ol></li><li><p>定位流</p></li></ul><h4 id="浮动元素脱标"><a href="#浮动元素脱标" class="headerlink" title="浮动元素脱标"></a>浮动元素脱标</h4><p>脱标：脱离标准流</p><p>当某一个元素浮动之后，那么这个元素看上去就像被从标准流中删除一样。</p><p>影响：</p><p>若前一个元素浮动了，而后一个元素没有浮动，那么此时前一个元素就会盖住后一个元素</p><h4 id="浮动排序规则"><a href="#浮动排序规则" class="headerlink" title="浮动排序规则"></a>浮动排序规则</h4><ol><li>相同方向上的浮动元素，先浮动会显示在前，后浮在后</li><li>不同方向上浮动元素，左浮找左浮，右浮找右浮</li><li>浮动元素浮动之后的位置，由浮动元素浮动之前在标准流中的位置来确定</li></ol><h4 id="浮动贴靠现象"><a href="#浮动贴靠现象" class="headerlink" title="浮动贴靠现象"></a>浮动贴靠现象</h4><p>当父元素的width足够放下所有浮动元素时，会并列显示一行；</p><p>但当后面的浮动元素放不下一行的时候，就会往前一个元素贴靠，直到贴到父元素的最左（右）边，这时，无论放不放的下，都会贴靠。</p><h4 id="浮动字围现象"><a href="#浮动字围现象" class="headerlink" title="浮动字围现象"></a>浮动字围现象</h4><p>内容文本级标签会给浮动元素让出位置。浮动元素不会盖住内容。</p><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><h4 id="浮动高度问题"><a href="#浮动高度问题" class="headerlink" title="浮动高度问题"></a>浮动高度问题</h4><ol><li>在标准流中内容高度可以撑起父元素盒子高度</li><li>浮动中不可以</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">p&#123;</span><br><span class="line"> float:left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>文本1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>文本2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>文本3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>文本4<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>文本5<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>文本6<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">文本123456会显示在同一行</span><br></pre></td></tr></table></figure><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>方法1：给父元素设置盒子高度（一般不用）</p><p>方法2：clear属性 （一般也不用，因为设置不了margin）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    clear:none;     left right both inherit</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*常用both，当前元素浮动（或者非浮动元素）另起一行，不追随前面一个浮动元素*/</span></span><br></pre></td></tr></table></figure><blockquote><p>注意点</p><p>当你给某个元素添加了clear属性后，那么这个属性的margin就会失效</p></blockquote><p>方法3：</p><ul><li><p>外墙法</p><p>在两个盒子中间添加一个 div 块级元素，给这个标签添加clear属性</p><p>此时，可以给下面的盒子设置margin-top，但是不能给第一个盒子设置margin-bottom。</p></li><li><p>内墙法</p><p>在第一个盒子中最后面，添加div块级元素，给它加clear，此时，即可以给第一个加margin-bottom，也可以给第2个加margin-top。</p></li></ul><blockquote><p> 外墙法和内墙法区别：</p><p>内墙法能撑起第一个盒子的高度，而外墙法不行。</p><p>且这2种方法都要额外加div，无语义，阅读差，所以不常用。</p></blockquote><p>方法4：</p><p>伪元素选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div::before&#123;           &lt;after&gt;</span><br><span class="line">    <span class="selector-tag">content</span><span class="selector-pseudo">:""</span>;</span><br><span class="line">    <span class="selector-tag">visibility</span><span class="selector-pseudo">:hidden</span>;  <span class="comment">/*可以隐藏伪元素*/</span></span><br><span class="line">    <span class="selector-tag">display</span><span class="selector-pseudo">:block</span>;</span><br><span class="line">    <span class="selector-tag">clear</span><span class="selector-pseudo">:both</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 注意</p><p>伪元素选择器为了兼容IE6，需要在父级样式中添加<code>*zoom:1</code></p></blockquote><p>方法5：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">overflow</span>:hidden;&#125;  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.可清除超出容器的文本内容</span></span><br><span class="line"><span class="comment">2.可清除浮动</span></span><br><span class="line"><span class="comment">3.如果2个盒子是嵌套关系，可以让里面的盒子设置margin-top，外面的盒子不会被顶下来，而不用设置boader属性</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="定位流"><a href="#定位流" class="headerlink" title="定位流"></a>定位流</h3><h4 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h4><p>相对于自己以前在标准流中的位置来移动，不影响其他元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    top:;        [bottom]</span><br><span class="line">    <span class="selector-tag">right</span>:;      <span class="selector-attr">[left]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意点</p><ul><li>相对定位是不脱离标准流，继续在标准流中占用空间</li><li>在相对定位中同一个方向上的定位属性只能使用一个。 left right只能选其一 top bottom也是</li><li>相对定位中区别块级/行内/行内块级 </li><li>当设置其margin/padding属性，会影响其标准流布局。*故而，先在标准流中确定布局，在考虑其相对流的位置</li></ul></blockquote><p>使用场景：</p><ul><li>用于对元素进行微调</li><li>配合后面学习绝对定位来使用</li></ul><h4 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h4><p>绝对定位就是相对于body来定位</p><blockquote><p>注意点1：</p><ul><li>绝对定位的元素是脱离标准流的</li><li>不区分块级/元素/行内块级，   和浮动很像，抽离出来，单独定位</li></ul></blockquote><p>绝对定位-参考点：</p><pre><code> 1. 默认下所有的绝对定位元素，无论有无祖先元素，都会以body作为参考点    2. 如果一个绝对定位的元素有祖先元素，并且祖先元素也是定位流，那么这个绝对定位的元素就会以定位流的祖先元素作为参考点 - 只要是这个绝对定位元素的祖先元素均可 - 定位流指   绝对/相对/固定 定位 - 只有 静态定位 不行3. 如果一个绝对定位的元素有祖先元素，并且祖先元素也是定位流，而且祖先元素中有多个元素都是定位流，那么这个绝对定位的元素以离它最近的那个定位流祖先元素为参考点。   简言：就近原则 </code></pre><blockquote><p>注意点2：</p><ul><li>如果一个绝对定位的元素是以body作为参考点，其实以网页首屏的宽高作为参考点，而不是以整个网页的宽高作为参考点。 </li><li>一个绝对定位的元素会忽略祖先元素的padding</li></ul></blockquote><p>子绝父相</p><p>​     企业中不单独用绝对定位，因为以body参考有Bug；也不单独用相对定位。</p><p>​    而是采用子元素用绝对定位，父元素用相对定位。</p><p>绝对定位水平居中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">300px</span>;  <span class="comment">/*若为100%宽度始终为浏览器宽度*/</span></span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -元素宽度的一半 -<span class="number">150px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h4><ol><li><p>脱离标准流，不占用标准流空间。</p></li><li><p>行内块级</p><p>固定定位类似背景的关联方式，背景定位可以让bg图片不随滚动条滚动而滚动</p></li></ol><p>而固定定位可让某个盒子不随着滚动条滚动而滚动。</p><h4 id="静态定位"><a href="#静态定位" class="headerlink" title="静态定位"></a>静态定位</h4><p>默认就是静态定位</p><h4 id="定位流z-index"><a href="#定位流z-index" class="headerlink" title="定位流z-index"></a>定位流z-index</h4><p>默认情况下，所有的元素都有一个默认的z-index属性，取值为0。</p><p>z-index的作用是专门用于控制定位流元素的覆盖关系</p><ol><li>默认，定位流的元素会盖住标准流的元素</li><li>默认，定位流的元素后面编写会盖住前面编写的</li><li>如果设置了z-index，谁的z-index大，谁就显示在上面。</li></ol><blockquote><p>注意点</p><p>从父现象</p><ul><li>若父元素都没设置z-index，则直接比较子元素的z-index</li><li>若父元素设置了，则子元素的z-index就会失效，听从父元素z-index比较大小</li></ul></blockquote><h2 id="过渡模块"><a href="#过渡模块" class="headerlink" title="过渡模块"></a>过渡模块</h2><h3 id="a标签伪类选择器"><a href="#a标签伪类选择器" class="headerlink" title="a标签伪类选择器"></a>a标签伪类选择器</h3><p>a标签4种状态</p><ul><li>从未被访问      a:link</li><li>被访问过          a:visited</li><li>鼠标悬停          a:hover</li><li>鼠标长按          a:active</li></ul><blockquote><p>顺序不能错</p></blockquote><p>过渡要素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:red;</span><br><span class="line">    <span class="attribute">transition-property</span>: width,background-color;</span><br><span class="line">    <span class="attribute">transition-duration</span>: <span class="number">5s</span>,<span class="number">5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="过渡模块属性"><a href="#过渡模块属性" class="headerlink" title="过渡模块属性"></a>过渡模块属性</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">transition-property</span>:;</span><br><span class="line">    <span class="attribute">transition-duration</span>:;</span><br><span class="line">    tansition-timing-function:linear;   &lt;ease,ease-in,ease-out,ease-in-out&gt;</span><br><span class="line">    <span class="selector-tag">tansition-delay</span>:;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>transition</code>连写：</p><blockquote><p>注意点</p><ul><li>可以分开定义，用<code>,</code>隔开</li><li>连写时可以省略后面2个参数，因为前2者已能满足过渡要素</li><li>如果所用属性运动速度/延迟时间/持续时间都一样，可简写为<code>tansition:all 0s;</code></li></ul></blockquote><p>eg:弹性效果   手风琴效果</p><h2 id="2D转换模块"><a href="#2D转换模块" class="headerlink" title="2D转换模块"></a>2D转换模块</h2><h3 id="2D形变属性"><a href="#2D形变属性" class="headerlink" title="2D形变属性"></a>2D形变属性</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    transform:rotate(45deg);  /*旋转,默认为Z轴*/ rotateX  rotateY  rotateZ</span><br><span class="line">    <span class="selector-tag">transform</span><span class="selector-pseudo">:translate(</span>水平<span class="selector-tag">px</span>,垂直<span class="selector-tag">px</span>); <span class="comment">/*平移*/</span></span><br><span class="line">    <span class="selector-tag">transform</span><span class="selector-pseudo">:scale(1.5</span>,1);   <span class="comment">/*水平缩放倍数，垂直缩放倍数*/</span></span><br><span class="line">    <span class="selector-tag">transform</span><span class="selector-pseudo">:rotate(45deg)</span>  <span class="selector-tag">translate</span>(水平<span class="selector-tag">px</span>,垂直<span class="selector-tag">px</span>);  <span class="comment">/*综合，属性按照先后顺序，会修改坐标系*/</span></span><br><span class="line">    <span class="selector-tag">transform-origin</span><span class="selector-pseudo">:center(50</span>%) <span class="selector-tag">center</span>(50%); <span class="comment">/*形变中心点，默认为自身中心*/</span>  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">perspective</span><span class="selector-pseudo">:100px</span>;   <span class="comment">/*透视属性，近大远小*/</span> 必须添加到父元素上</span><br></pre></td></tr></table></figure><h3 id="盒子和文字阴影"><a href="#盒子和文字阴影" class="headerlink" title="盒子和文字阴影"></a>盒子和文字阴影</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="built_in">h-shadow</span>(水平偏移)  px可为负</span><br><span class="line">         v-shadow </span><br><span class="line">         <span class="built_in">blur</span>(模糊度)    px</span><br><span class="line">        <span class="built_in">spread</span>(阴影扩展,原本的阴影四周扩展)     px</span><br><span class="line">        color <span class="comment">/*默认颜色由盒子内容颜色决定*/</span></span><br><span class="line">        <span class="built_in">inset</span>(内外阴影，默认为外);</span><br><span class="line">&#125;</span><br><span class="line">文字偏移没有  内外阴影和阴影扩展</span><br></pre></td></tr></table></figure><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    display:none; /*不显示*/ 无法配合动画</span><br><span class="line">    <span class="selector-tag">opacity</span><span class="selector-pseudo">:0</span>~1; <span class="comment">/*透明度*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动画模块"><a href="#动画模块" class="headerlink" title="动画模块"></a>动画模块</h2><p>过渡和动画的异同</p><ul><li>不同：过渡必须人为，动画不需要</li><li>相同：<ul><li>都是给元素添加动画</li><li>都需要满足三要素</li></ul></li></ul><h3 id="动画三要素"><a href="#动画三要素" class="headerlink" title="动画三要素"></a>动画三要素</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="comment">/*1.需要执行的动画*/</span></span><br><span class="line">    <span class="attribute">animation-name</span>:lp;</span><br><span class="line">    <span class="comment">/*动画持续时长*/</span></span><br><span class="line">    <span class="attribute">animation-duration</span>:<span class="number">3s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*需要创建一个名称为lp的动画*/</span></span><br><span class="line">@<span class="keyword">keyframes</span> lp&#123;</span><br><span class="line">    <span class="selector-tag">from</span>&#123;</span><br><span class="line">        <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">to</span>&#123;</span><br><span class="line">        <span class="attribute">margin</span>:<span class="number">0</span> auto;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动画其他属性"><a href="#动画其他属性" class="headerlink" title="动画其他属性"></a>动画其他属性</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="comment">/*动画延迟多久开始执行*/</span></span><br><span class="line">    <span class="attribute">animation-delay</span>:<span class="number">2s</span>;</span><br><span class="line">    <span class="comment">/*动画执行过程速度曲线*/</span></span><br><span class="line">    <span class="attribute">animation-timing-function</span>:linear;</span><br><span class="line">    <span class="comment">/*动画需要执行几次*/</span></span><br><span class="line">    <span class="attribute">animation-iteration-count</span>:<span class="number">3</span>;</span><br><span class="line">    <span class="comment">/*是否需要执行往返动画*/</span></span><br><span class="line">    <span class="attribute">animation-direction</span>:alternate;</span><br><span class="line">                取值：  normal 默认，执行完一次后回到启动继续执行下一次</span><br><span class="line">                  <span class="selector-tag">alternate</span> 往返动画</span><br><span class="line">    <span class="selector-tag">animation-play-state</span><span class="selector-pseudo">:running</span>; </span><br><span class="line">    取值：  <span class="selector-tag">running</span> 默认</span><br><span class="line">       <span class="selector-tag">paused</span> 暂停动画</span><br><span class="line">    <span class="selector-tag">animation-fill-mode</span>：<span class="selector-tag">none</span></span><br><span class="line">    取值：  <span class="selector-tag">none</span> 默认，不做任何改变</span><br><span class="line">       <span class="selector-tag">forwards</span> 让元素结束状态保持最后一帧样式</span><br><span class="line">       <span class="selector-tag">backwards</span> 让元素等待状态时显示动画第一帧的样式即0%</span><br><span class="line">       <span class="selector-tag">both</span> 上面2个叠加</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> lp&#123;</span><br><span class="line">   <span class="comment">/*时间片变化*/</span></span><br><span class="line">    0%&#123;     </span><br><span class="line">        <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    25%&#123;</span><br><span class="line">        <span class="attribute">margin</span>:<span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3D转换模块"><a href="#3D转换模块" class="headerlink" title="3D转换模块"></a>3D转换模块</h2><p>默认，所有元素都是2D呈现，如何让元素呈3D？</p><p>和透视一样，想看到某个元素的3D效果，只需要给其<strong>父</strong>元素添加一个<code>transform-style</code>属性，设置其值为<code>preserve-3d</code>。</p><h2 id="背景相关"><a href="#背景相关" class="headerlink" title="背景相关"></a>背景相关</h2><h3 id="背景尺寸"><a href="#背景尺寸" class="headerlink" title="背景尺寸"></a>背景尺寸</h3><p>背景尺寸属性是css3中新增属性，专门用来设置背景图片大小</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">"img/logo.png"</span>) no-repeat;</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">150px</span> <span class="number">100px</span>;  <span class="comment">/*宽度  高度*/</span></span><br><span class="line">                     30% 50%;      /*盒宽百分比  高*/</span><br><span class="line">                     <span class="selector-tag">auto</span> 100<span class="selector-tag">px</span>;   <span class="comment">/*宽度等比拉伸  高度*/</span></span><br><span class="line">                     100<span class="selector-tag">px</span> <span class="selector-tag">auto</span>;   <span class="comment">/*宽度  高度等比拉伸*/</span></span><br><span class="line">                     <span class="selector-tag">cover</span>;    <span class="comment">/*等比拉伸覆盖整个盒子，不留空*/</span></span><br><span class="line">                     <span class="selector-tag">contain</span>;    <span class="comment">/*等比拉伸覆盖整个盒子，一旦宽或高遇到盒子边缘就停止，会留空*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="comment">/*背景图片起始位置*/</span></span><br><span class="line">    background-origin:padding-box;  默认</span><br><span class="line">      <span class="selector-tag">border-box</span>;</span><br><span class="line">      <span class="selector-tag">content-box</span>;</span><br><span class="line">    <span class="comment">/*背景绘制区域属性，指定从哪个区域开始绘制背景*/</span></span><br><span class="line">    <span class="selector-tag">background-clip</span><span class="selector-pseudo">:border-box</span> 默认</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多重背景图片"><a href="#多重背景图片" class="headerlink" title="多重背景图片"></a>多重背景图片</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">"img/1.png"</span>) no-repeat left top,</span><br><span class="line">       <span class="built_in">url</span>(<span class="string">"img/2.png"</span>) no-repeat right top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多张用<code>,</code>隔开，先添加的会盖住后添加</p><p>最好分开写</p><h2 id="CSS书写格式"><a href="#CSS书写格式" class="headerlink" title="CSS书写格式"></a>CSS书写格式</h2><p>外链样式和导入样式区别：</p><ul><li><p>外链 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>导入</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">".css"</span>;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul><p>@import是CSS2.1推出，有兼容性问题</p><p>外链显示，会先加载CSS，再加载结构。而导入会先加载结构，可能体验会不好。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git 操作小结</title>
      <link href="/2018/06/24/git%E6%93%8D%E4%BD%9C%E5%B0%8F%E7%BB%93/"/>
      <url>/2018/06/24/git%E6%93%8D%E4%BD%9C%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="git提交代码"><a href="#git提交代码" class="headerlink" title="git提交代码"></a>git提交代码</h2><ol><li>可以先pull的情况</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#该方法适合远端代码和你当前的(包括未add或者已add未commit)进行比较</span></span><br><span class="line">git pull  <span class="comment">#若无冲突，可直接merge</span></span><br><span class="line">git commit -a -m <span class="string">"message"</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><ol start="2"><li>无法先pull（即存在冲突）方案一：推荐</li></ol><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git stash <span class="comment">#把当前的所有修改暂存下来，此时status会恢复到最初干净的状态</span></span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line">git stash pop <span class="comment">#把暂存区的修改恢复出来，并且冲突的地方会标记出来，待手动修改</span></span><br><span class="line">git stash apply stash@&#123;0&#125; <span class="comment">#上面这样恢复若无冲突和自动删除stash记录，而这个不会</span></span><br><span class="line"></span><br><span class="line">git commit -a -m <span class="string">"message"</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>附加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git stash list <span class="comment">#查看暂存的内容列表(包含在哪条分支上的暂存)</span></span><br><span class="line"><span class="comment">#如果使用git stash pop 不加名，则恢复最近一条记录，哪怕是mybranch上的内容也会被恢复到master。(若无冲突，会吧list中记录删除，若冲突则需冲动删除)</span></span><br><span class="line">git stash clear <span class="comment">#清空所有内容</span></span><br><span class="line">git stash drop stash@&#123;0&#125;<span class="comment">#删除第一个队列，不加默认删除编号为0</span></span><br></pre></td></tr></table></figure><ol start="3"><li>无法先pull（即存在冲突）方案二（缺点：需要提交2次，有时并不想提交）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m <span class="string">"messgae1"</span></span><br><span class="line">git pull <span class="comment">#此时冲突处会标记出来，手动解决冲突</span></span><br><span class="line">git commit -a -m <span class="string">"messgae2"</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h2 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --all <span class="comment">#查看所有分支情况，包括本地和远端</span></span><br></pre></td></tr></table></figure><p>无论在主分支，或者其他分支上修改了东西，但是未commit，切换分支时，会<strong>仍然存在</strong>。</p><p>因此，在切换分支的时候，最好commit再切换，或者git stash下来。</p><h3 id="分支新建与合并"><a href="#分支新建与合并" class="headerlink" title="分支新建与合并"></a>分支新建与合并</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.新建分支并切换到该分支上</span></span><br><span class="line">git checkout -b 分支名 </span><br><span class="line"><span class="comment">#等价于下面两条命令</span></span><br><span class="line">git branch 分支名</span><br><span class="line">git checkout 分支名</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.合并</span></span><br><span class="line">git checkout master</span><br><span class="line">git merge 分支名 <span class="comment">#fast-forward 无需解决冲突</span></span><br><span class="line">                <span class="comment">#如果当前master和分支的起点不是同个点，可能会有矛盾需解决</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.删除无用的分支</span></span><br><span class="line">git branch -d 分支名 <span class="comment">#(-D 强制删除，-d无法删除未merge的分支)</span></span><br></pre></td></tr></table></figure><h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><ol><li>分支由本地新建并推送给远程</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git push</span><br><span class="line">git pull <span class="comment">#可缺省后面的仓库名 &lt;远程库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;  </span></span><br><span class="line">                        <span class="comment"># git push是  &lt;本地分支&gt;:&lt;远程分支&gt;  </span></span><br><span class="line"></span><br><span class="line">git checkout mybranch1</span><br><span class="line">git push origin mybranch1</span><br><span class="line">git pull origin mybranch1  <span class="comment">#后面仓库名、分支名不可缺省</span></span><br></pre></td></tr></table></figure><blockquote><p>git pull和push后面有些可以省略，需要<strong>配置</strong>push.default默认行为</p><p>*<strong>建议</strong>分支操作的时候，每次pull和push加上仓库名<origin> &lt;分支名&gt;(本地和远程分支名相同)</origin></p></blockquote><ol start="2"><li>分支由远程新建好本地跟踪</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -t(--track) origin/mybranch1 <span class="comment">#克隆远端分支并创建到本地，名与远端同</span></span><br></pre></td></tr></table></figure><p><strong>合并分支与前面相同，git merge</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge mybranch1</span><br><span class="line">git push &lt;origin&gt; &lt;master&gt;</span><br></pre></td></tr></table></figure><p>最后删除无用的分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除远程分支</span></span><br><span class="line">git push origin --delete(-d) mybranch1</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除本地分支</span></span><br><span class="line">git branch -d mybranch1 <span class="comment">#-D强制删除</span></span><br></pre></td></tr></table></figure><h3 id="删除远程分支后本地未同步"><a href="#删除远程分支后本地未同步" class="headerlink" title="删除远程分支后本地未同步"></a>删除远程分支后本地未同步</h3><ul><li>方法1</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch -p 命令</span><br><span class="line"><span class="comment">#命令行解释--prune -p  删除不存在的远程跟踪分支</span></span><br></pre></td></tr></table></figure><ul><li>方法2</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote show origin <span class="comment">#查看远程分支，还有本地分支与之相对应关系等信息。</span></span><br><span class="line">git remote prune origin <span class="comment">#可以删除远程已经不存在的分支</span></span><br></pre></td></tr></table></figure><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
