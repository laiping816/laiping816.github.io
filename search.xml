<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>JavaWeb基础学习(2)</title>
      <link href="/2019/01/07/JavaWeb%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A02/"/>
      <url>/2019/01/07/JavaWeb%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A02/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p>MVC、事务、连接池、Ajax、监听器、过滤器、动态代理、注解</p></blockquote><p><img src="https://image-link.nos-eastchina1.126.net/javaweb_02"></p><a id="more"></a><h1 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h1><p><code>JavaBean</code>：一个普通类（实体bean）,包含3个标准</p><ol><li>无参构造</li><li>私有属性</li><li>公共的getter和setter方法</li></ol><h2 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h2><p>JSP + Servlet + JavaBean</p><p>MVC:开发模式 </p><p>M：模型     <code>JavaBean</code></p><p>V：视图        <code>JSP</code></p><p>C：控制器    <code>Servlet</code></p><h2 id="分层思想"><a href="#分层思想" class="headerlink" title="分层思想"></a>分层思想</h2><p>强内聚、弱耦合</p><p><img src="/2019/01/07/JavaWeb基础学习2/分层.png" alt=""></p><h1 id="事务与连接池"><a href="#事务与连接池" class="headerlink" title="事务与连接池"></a>事务与连接池</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务指逻辑上的一组操作，组成这组操作的各个单元，要么全部成功，要么全部不成功。</p><h3 id="mysql事务"><a href="#mysql事务" class="headerlink" title="mysql事务"></a>mysql事务</h3><ol><li>mysql引擎支持事务</li><li>默认自动提交事务。(<strong>每条</strong>语句都处在<strong>单独</strong>的事务中)</li><li>手动控制事务<ul><li>开启：<code>start transaction | begin</code></li><li>提交：<code>commit</code></li><li>回滚：<code>rollback</code></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    conn.setAutoCommit(<span class="keyword">false</span>); <span class="comment">//1.相当于begin</span></span><br><span class="line">...<span class="comment">//2.做一些数据库操作</span></span><br><span class="line">conn.commit(); <span class="comment">//3.提交事务commit</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conn.rollback(); <span class="comment">//4.出异常，回滚rollback事务   </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    关闭资源</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h3><ul><li><p>原子性</p><ul><li>指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 </li></ul></li><li><p>一致性</p><ul><li>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。转账前和转账后的总金额不变。</li></ul></li><li><p>隔离性</p><ul><li>事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。</li></ul></li><li><p>持久性</p><ul><li>指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</li></ul></li></ul><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ul><li><p>赃读</p><ul><li>指一个事务读取了另一个事务未提交的数据。（<strong>绝对要避免</strong>）</li></ul></li><li><p>不可重复读</p><ul><li>在一个事务内读取表中的某一行数据，多次读取结果不同。一个事务读取到了另一个事务提交后的数据。（update）</li></ul></li><li><p>虚读（幻读）</p><ul><li>是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。 (insert)</li></ul></li></ul><p>设置事务的隔离级别：</p><p> 1、<code>READ UNCOMMITTED</code>: 赃读、不可重复读、虚读都有可能发生。</p><p> 2、<code>READ COMMITTED</code>: 避免赃读。不可重复读、虚读都有可能发生。（oracle默认的）</p><p> 4、<code>REPEATABLE READ</code>:避免赃读、不可重复读。虚读有可能发生。（mysql默认）</p><p> 8、<code>SERIALIZABLE</code>: 避免赃读、不可重复读、虚读。  (<strong>相当于锁住资源</strong>)</p><p>级别越高，性能越低，数据越安全</p><p>查看事务：<code>SELECT @@transaction_isolation;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDBC中控制事务隔离级别</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置隔离级别：必须在开启事务之前。</span></span><br><span class="line">Connection.setTransactionIsolation(<span class="keyword">int</span> level);</span><br><span class="line"><span class="comment">//可用宏</span></span><br><span class="line">TRANSACTION_READ_UNCOMMITTED <span class="comment">//可脏读</span></span><br><span class="line">TRANSACTION_READ_COMMITTED  <span class="comment">//不可脏读</span></span><br><span class="line">TRANSACTION_REPEATABLE_READ <span class="comment">//不可脏读、重复读</span></span><br><span class="line">TRANSACTION_SERIALIZABLE  <span class="comment">//不可脏读、重复读和虚读</span></span><br></pre></td></tr></table></figure><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="/2019/01/07/JavaWeb基础学习2/连接池原理.jpg" alt=""></p><p>目的：解决建立数据库连接耗费资源和时间很多的问题，提高性能。</p><h3 id="模拟连接池"><a href="#模拟连接池" class="headerlink" title="模拟连接池"></a>模拟连接池</h3><p>自定义数据库连接池要实现<code>javax.sql.DataSource</code>接口，一个标准，防五花八门。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDataSource</span> <span class="keyword">implements</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于默认的<code>Connection</code>接口的<code>close()</code>方法直接关闭，而在连接池中不允许关闭</p><p>解决方法</p><ul><li>装饰设计模式：包装<code>Connection</code>，直接写<code>MyConnection</code></li><li>先用适配器包装一遍，再写自己的包装类<code>MyConnection</code></li></ul><h3 id="常用数据源配置"><a href="#常用数据源配置" class="headerlink" title="常用数据源配置"></a>常用数据源配置</h3><h4 id="DPCP"><a href="#DPCP" class="headerlink" title="DPCP"></a>DPCP</h4><h4 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h4><h1 id="DBUtils"><a href="#DBUtils" class="headerlink" title="DBUtils"></a>DBUtils</h1><p>DBUtils封装了对JDBC的操作，简化了JDBC操作。可以少写代码。</p><ol><li><p>对于数据表的<strong>读操作</strong>，他可以把结果转换成List，Array，Set等java集合，便于程序员操作；</p></li><li><p>对于数据表的<strong>写操作</strong>，也变得很简单（只需写sql语句）</p></li><li><p>可以使用数据源，使用JNDI，数据库连接池等技术来优化性能–重用已经构建好的数据库连接对象</p></li></ol><h2 id="核心对象"><a href="#核心对象" class="headerlink" title="核心对象"></a>核心对象</h2><ul><li><code>QueryRunner</code> 类<ul><li>提供对sql语句操作的API<ul><li><code>query()</code>：执行select</li><li><code>update()</code>：执行insert update delete</li><li><code>batch()</code>：批处理</li></ul></li></ul></li><li><code>ResultSetHandler</code>：接口<ul><li>用于定义select操作后，怎样封装结果集</li><li><code>ArrayHandler</code>：取1条记录。把该条记录的每列值封装到一个数组中<code>Object[]</code></li><li><code>ArrayListHandler</code>：取多条记录</li><li><code>ColumnListHandler</code>：取某一列的数据，封装到List中</li><li><code>KeyedHandler</code>：取多条记录</li><li><code>MapHandler</code>：取1条记录。把当前记录的列名和列值放到一个Map中</li><li><code>MapListHandler</code>：取多条记录。把每条记录封装到一个Map中，再把Map封装到List中</li><li><code>ScalarHandler</code>：取单行单列数据</li><li><code>BeanHandler</code></li><li><code>BeanListHandler</code> </li></ul></li><li><code>DbUtils</code>类（用的不多）<ul><li>它就是一个工具类,定义了关闭资源与事务处理的方法</li></ul></li></ul><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ol><li>导入jar包</li><li>创建<code>QueryRunner</code>对象</li><li>使用<code>query</code>方法执行<code>select</code>语句</li><li>使用<code>ResultSetHandler</code>封装结果集 (<code>BeanListHandler</code>)</li><li>使用<code>DbUtils</code>类释放资源</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QueryRunner qr = <span class="keyword">new</span> QueryRunner(C3P0Util.getDataSource());</span><br><span class="line">List&lt;User&gt; list = qr.query(<span class="string">"select * from users"</span>, <span class="keyword">new</span> BeanListHandler&lt;User&gt;(User.class));</span><br></pre></td></tr></table></figure><p>##事务控制</p><p>模拟<code>ThreadLocal</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Runnable,Object&gt; container = <span class="keyword">new</span> HashMap&lt;Runnable,Object&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object value)</span></span>&#123;</span><br><span class="line">        container.put(Thread.currentThread(),value);<span class="comment">//用当前线程作为key</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> container.get(Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">        container.remove(Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p>(Asynchronous JavaScript And XML)</p><p> = DHTML(html4.0) + XHR</p><p><strong>只刷新局部页面的技术</strong></p><ul><li>JavaScript：更新局部的网页</li><li>XML：一般用于请求数据和响应数据的封装</li><li><code>XMLHttpRequest</code>对象：发送请求到服务器并获得返回结果</li><li>CSS：美化页面样式</li><li>异步：发送请求后不等返回结果，由回调函数处理结果</li></ul><h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h2><ol><li>方法</li></ol><ul><li><code>open(method,URL,async)</code> <ul><li>get|post</li><li>url?name=fyd</li><li>true |false   (默认true，异步)</li></ul></li><li><code>send(content)</code><ul><li>发送请求。 可带参数或null</li></ul></li><li><code>setRequestHeader(header,value)</code><ul><li>请求消息头</li></ul></li></ul><ol start="2"><li>属性</li></ol><ul><li><p>readyState：类型short；只读  </p><p> (XMLHttpRequest的状态信息)</p><ul><li><p>0     XMLHttpRequest对象没有完成初始化</p><ul><li>刚刚创建</li></ul></li><li><p>1     对象<strong>开始</strong>发送请求</p><ul><li>调用了open方法，但还没有调用send方法。请求还没有发出</li></ul></li><li><p>2     请求<strong>发送完成</strong></p><ul><li>send方法已经调用，数据已经提交到服务器，但没有任何响应</li></ul></li><li><p>3      <strong>开始读取响应，还没有结束</strong></p><ul><li>收到了所有的响应消息头，但正文还没有完全收到</li></ul></li><li><p>4       对象读取<strong>响应结束</strong></p><ul><li>一切都收到了</li></ul></li></ul></li><li><p>responseText：类型String；只读</p></li><li><p>responseXML：类型Document；只读</p></li><li><p>status：类型short；只读</p><ul><li>200   正常</li><li>400   无法找到请求的资源</li><li>403   没有访问权限</li><li>404   访问的资源不存在</li><li>500   服务器内部错误</li></ul></li></ul><ol start="3"><li>事件处理器</li></ol><ul><li>onreadystatechange(当状态码变动调用，回调的功能)</li></ul><h1 id="Listener-amp-Filter"><a href="#Listener-amp-Filter" class="headerlink" title="Listener &amp; Filter"></a>Listener &amp; Filter</h1><h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><ol><li><p>什么是监听器</p><p> Javaweb中的监听器是用于监听web常见对象<code>HttpServletRequest</code>,<code>HttpSession</code>,<code>ServletContext</code></p></li><li><p>监听器的作用</p><ul><li>监听web对象创建与销毁.</li><li>监听web对象的属性变化</li><li>监听session绑定javaBean操作.</li></ul></li><li><p>监听机制相关概念</p><ul><li>事件—-一件事情</li><li>事件源—产生这件事情的源头</li><li>注册监听—将监听器与事件绑定，当事件产生时，监听器可以知道，并进行处理。-</li><li>监听器—对某件事情进行处理监听的一个对象</li></ul></li></ol><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>Javaweb中的过滤器可以拦截所有访问web资源的请求或响应操作。</p><h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><ol><li><p>jdk提供一个Proxy类可以直接给实现接口类的对象直接生成代理对象。</p></li><li><p>cglib  (spring学习)</p></li></ol><h2 id="AOP编程思想"><a href="#AOP编程思想" class="headerlink" title="AOP编程思想"></a>AOP编程思想</h2><ul><li>业务方法日后会很多，会有很多重复的代码</li><li>已经存在很多的方法，并没有考虑到事务的问题，现在要求加上</li></ul><p><img src="/2019/01/07/JavaWeb基础学习2/aop.jpg" alt=""></p><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="JDK三个基本注解"><a href="#JDK三个基本注解" class="headerlink" title="JDK三个基本注解"></a>JDK三个基本注解</h2><ul><li><p><code>@Override</code>：检查子类确实是覆盖了父类的方法。</p></li><li><p><code>@Deprecated</code>：说明已经过时了。</p></li><li><p><code>@SuppressWarnings({ &quot;unused&quot;, &quot;deprecation&quot; })</code>：抑制程序中的警告。unused警告的类型。{}数组。all抑制所有警告。</p></li></ul><h2 id="自定义注解语法"><a href="#自定义注解语法" class="headerlink" title="自定义注解语法"></a>自定义注解语法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注解它的本质就是一个接口，这个接口需要继承 Annotation接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyAnnotation</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">annotation</span>.<span class="title">Annotation</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span>  <span class="keyword">default</span> -1</span>;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">Class <span class="title">clazz</span><span class="params">()</span> <span class="keyword">default</span> Object.class</span>;</span><br><span class="line">    String[] value(); <span class="comment">//赋值可一个字符串，相当于一个元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseAnnotation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@MyAnnotation</span>(age=<span class="number">26</span>,name=<span class="string">"lp"</span>,value=<span class="string">"fyd"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>注解中的成员</p><ul><li>本质接口，接口中为属性方法</li></ul></li><li><p>注解属性类型</p><ul><li>基本类型</li><li>String</li><li>枚举类型</li><li>注解类型</li><li>Class类型</li><li>以上类型的一维数组类型</li></ul></li><li><p>注解的反射<strong>重点</strong></p><ol><li>反射注解类</li></ol><p><code>java.lang.reflect.AnnotatedElement:</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;T extends Annotation&gt; <span class="function">T <span class="title">getAnnotation</span><span class="params">(Class&lt;T&gt; annotationType)</span></span></span><br><span class="line"><span class="function"><span class="comment">//得到指定类型的注解引用。没有返回null。</span></span></span><br><span class="line"><span class="function">Annotation[] <span class="title">getAnnotations</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//得到所有的注解，包含从父类继承下来的。</span></span></span><br><span class="line"><span class="function">Annotation[] <span class="title">getDeclaredAnnotations</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//得到自己身上的注解。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAnnotationPresent</span><span class="params">(Class&lt;? extends Annotation&gt; annotationType)</span></span></span><br><span class="line"><span class="function"><span class="comment">//判断指定的注解有没有</span></span></span><br></pre></td></tr></table></figure><p><code>Class</code>、<code>Method</code>、<code>Field</code>、<code>Constructor</code>等实现了<code>AnnotatedElement</code>接口.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class.isAnnotationPresent(MyTest.class)</span><br><span class="line"><span class="comment">//判断类上面有没有@MyTest注解；</span></span><br><span class="line">Method.isAnnotationPresent(MyTest.class)</span><br><span class="line"><span class="comment">//判断方法上面有没有@MyTest注解。</span></span><br></pre></td></tr></table></figure><ol start="2"><li>反射注解中的属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = MyClass.class;</span><br><span class="line">Method methods = clazz.getMethods();</span><br><span class="line"><span class="keyword">for</span> (Method m:methods) &#123;</span><br><span class="line">    MyTest myTest = m.getAnnotation(MyTest.class);</span><br><span class="line">    <span class="keyword">if</span> (myTest != <span class="keyword">null</span>) &#123; <span class="comment">//方法上面有MyTest注解</span></span><br><span class="line">        <span class="comment">//获取注解的timeout属性</span></span><br><span class="line">        <span class="keyword">long</span> time = myTest.timeout(); <span class="comment">// -1或者大于0的值</span></span><br><span class="line">        <span class="keyword">if</span> (time &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//不需要测试效率</span></span><br><span class="line">            m.invoke(clazz.newInstance(), <span class="keyword">null</span>);<span class="comment">//执行方法</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//需要测试效率</span></span><br><span class="line">            <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">            m.invoke(clazz.newInstance(), <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">long</span> costTime = System.nanoTime() - startTime;</span><br><span class="line">            <span class="keyword">if</span> (costTime &gt; time) &#123;</span><br><span class="line">                System.out.println(m.getName()+<span class="string">"超时"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>自定义的注解的存活范围（生命周期）：默认是CLASS。</p><p><img src="/2019/01/07/JavaWeb基础学习2/生命周期.jpg" alt=""></p><p>只能用在注解上的注解叫做元注解。（即：用于修饰注解的注解）</p><ul><li><p><code>@Retention</code>：作用。改变自定义的注解的存活范围。</p><ul><li>RetentionPolicy宏对象:<ul><li>SOURCE</li><li>CLASS</li><li>RUNTIME</li></ul></li></ul></li><li><p><code>@Target</code>：作用。指定该注解能用在什么地方。</p><ul><li>ElementType:<ul><li>TYPE</li><li>METHOD</li><li>FIELD</li><li>ANNOTATION_TYPE</li></ul></li></ul></li><li><p><code>@Documented</code>：作用，使用了@MyTest的注解的类，如果@MyTest注解上面有<code>@Documented</code>注解，那么使用了@MyTest的注解的类的API文档中会出现@MyTest的身影。</p></li><li><p><code>@Inherited</code>：作用，说明该注解可以被继承下去</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mysql</title>
      <link href="/2018/12/23/MySQL/"/>
      <url>/2018/12/23/MySQL/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p>Mysql、JDBC</p></blockquote><p><img src="https://image-link.nos-eastchina1.126.net/mysql"></p><a id="more"></a><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><ul><li><p>常用命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p passwd -P 端口号 -h 服务器地址  </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">VERSION</span>();</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">NOW</span>();</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>();</span><br></pre></td></tr></table></figure><ul><li>关键字与函数名全部大写</li><li>数据库名、表名、字段名全部小写</li></ul></li></ul><h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><ul><li><p>数据定义语言（Data Definition Language）</p><ul><li><p>用来定义数据库对象：库、表、列等；</p></li><li><p><code>CREATE、 ALTER、DROP</code></p></li></ul></li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li>创建</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> &#123;<span class="keyword">DATABASE</span> | <span class="keyword">SCHEMA</span>&#125; [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] db_name</span><br><span class="line">[<span class="keyword">DEFAULT</span>] <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> [=] charset_name;  </span><br><span class="line"><span class="comment">/* if not 不直接报错，把错误加到warining中 */</span></span><br></pre></td></tr></table></figure><ul><li>查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*查看当前数据库服务器中的所有数据库*/</span></span><br><span class="line"><span class="keyword">SHOW</span> &#123;<span class="keyword">DATABASES</span> | SCHEMAS&#125; [<span class="keyword">LIKE</span> <span class="string">'pattern'</span> | <span class="keyword">WHERE</span> expr];</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">WARNINGS</span>;</span><br><span class="line"><span class="comment">/*显示数据库创建时指令*/</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> db_name;</span><br></pre></td></tr></table></figure><ul><li>修改</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*改编码方式*/</span></span><br><span class="line"><span class="keyword">ALTER</span> &#123;<span class="keyword">DATABASE</span> | <span class="keyword">SCHEMA</span>&#125; [db_name] [<span class="keyword">DEFAULT</span>] <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> [=] charset_name;</span><br></pre></td></tr></table></figure><ul><li>删除</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> &#123;<span class="keyword">DATABASE</span> | <span class="keyword">SCHEMA</span>&#125; [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] db_name;</span><br></pre></td></tr></table></figure><h3 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h3><p><code>USE db_name;</code></p><p><code>SELECT DATABASE();</code>   查看当前使用的数据库</p><ul><li>创建</li></ul><h4 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h4><ul><li><p>主键约束(<code>PRIMARY KEY</code>)</p><ul><li>每张表只能存在一个主键</li><li>主键保证记录唯一性</li><li>主键自动为NOT NULL    </li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*方法1*/</span></span><br><span class="line">Id int primary key,</span><br><span class="line"><span class="comment">/*方法2：可联合主键*/</span></span><br><span class="line">id int,</span><br><span class="line">Name varchar(50),</span><br><span class="line">Primary key(id)</span><br><span class="line"><span class="comment">/*方法3：创建后修改*/</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">ADD</span>  PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure></li><li><p>唯一约束(<code>UNIQUE KEY</code>)</p><ul><li>可以存在多个唯一约束</li><li>可保记录唯一性</li><li>字段可为NULL</li></ul></li><li><p>默认约束（ <code>DEFAULT</code>）</p><p><code>sex ENUM(&#39;1&#39;, &#39;2&#39;, &#39;3&#39;) DEFAULT &#39;3&#39;</code></p></li><li><p>非空约束（<code>NOT NULL</code>）</p></li><li><p>外键约束（一般不用物理外键，而用逻辑外键）</p><p>保持数据一致性，完整性。实现1对1，1对多的关系。</p><p><code>FOREIGN KEY (pid) REFERENCES tb_name (id) ON {DELETE|UPDATE} 操作</code></p><ul><li>要求<ul><li>父表和子表必须为相同存储引擎，禁止用临时表</li><li>数据表的存储引擎只是为InnoDB</li><li>外键列和参照列必须具有相似数据类型。其中数字的长度或是否有符号位必须相同；而字符的长度则可以不同。</li><li>外键列和参照列必须创建索引。如果外键列不存在索引，MySQL会自动创建</li></ul></li><li>参照操作<ul><li>CASCADE：父表删除或更新且自动删除或者更新字表中匹配行</li><li>SET NULL：父表删除或更新行，并设置字表中外键列为NULL。字表不为NOT NULL </li><li>RESTRICT：拒绝对父表的删除或更新操作</li><li>NOT ACTION：标准SQL关键字，在MySQL中同RESTRICT</li></ul></li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] table_name (</span><br><span class="line">    column_name data_type </span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span>, <span class="comment">/*自动编号，必须为主键*/</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*查数据库中表*/</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLES</span> [<span class="keyword">FROM</span> db_name] [<span class="keyword">LIKE</span> <span class="string">'pattern'</span> | <span class="keyword">WHERE</span> expr];</span><br><span class="line"><span class="comment">/*查某表所有列*/</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">COLUMNS</span> <span class="keyword">FROM</span> tb_name;</span><br><span class="line"><span class="comment">/*查某表索引*/</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEXES</span> <span class="keyword">FROM</span> tb_name\G;</span><br></pre></td></tr></table></figure><ul><li>修改</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*添加单列*/</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb_name <span class="keyword">ADD</span>  col_name column_def [FRIST | <span class="keyword">AFTER</span> col_name]</span><br><span class="line"></span><br><span class="line"><span class="comment">/*添加多列*/</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb_name <span class="keyword">ADD</span>  (col_name column_def, ...)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*添加约束*/</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb_name <span class="keyword">ADD</span>  PRIMARY <span class="keyword">KEY</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">/*添加删除默认约束*/</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb_name <span class="keyword">ALTER</span>  col_name &#123;<span class="keyword">SET</span> <span class="keyword">DEFAULT</span> 默认值/<span class="keyword">DROP</span> <span class="keyword">DEFAULT</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>删除</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*删列*/</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">DROP</span> col_name1,<span class="keyword">DROP</span> col_name2;</span><br></pre></td></tr></table></figure><h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><ul><li><p>数据操作语言（Data Manipulation Language）</p><ul><li><p>用来定义数据库记录（数据）   </p></li><li><p><code>INSERT、 UPDATE、 DELETE</code></p></li></ul></li><li><p>插入记录</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> tbl_name [(col_name,...)] <span class="keyword">VALUES</span>(val1,...),(val2);</span><br><span class="line"><span class="comment">/*默认值用DEFAULT或者在字段名中省略对应*/</span></span><br><span class="line"><span class="keyword">INSERT</span> tb1_name <span class="keyword">SET</span> col_name=&#123;expr|<span class="keyword">DEFAULT</span>&#125;,...;<span class="comment">/*可用子查询*/</span></span><br></pre></td></tr></table></figure><ul><li>删除记录</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tb_name <span class="keyword">WHERE</span> 条件</span><br></pre></td></tr></table></figure><ul><li>更新记录</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">SET</span> col_name = <span class="keyword">DEFAULT</span> | 表达式 [<span class="keyword">WHERE</span> 条件];</span><br></pre></td></tr></table></figure><h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><ul><li>数据查询语言<ul><li><code>SELECT</code></li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> selection_list <span class="comment">/*要查询的列名称*/</span></span><br><span class="line"><span class="keyword">FROM</span> table_list <span class="comment">/*要查询的表名称*/</span></span><br><span class="line"><span class="keyword">WHERE</span> condition <span class="comment">/*行条件*/</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> grouping_columns <span class="comment">/*对结果分组*/</span></span><br><span class="line"><span class="keyword">HAVING</span> condition <span class="comment">/*分组后的行条件*/</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> sorting_columns <span class="comment">/*对结果分组*/</span></span><br><span class="line"><span class="keyword">LIMIT</span> offset_start, <span class="keyword">row_count</span> <span class="comment">/*结果限定*/</span></span><br></pre></td></tr></table></figure><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><ul><li>=、!=、&lt;&gt;、&lt;、&lt;=、&gt;、&gt;=；</li><li>BETWEEN…AND； </li><li>IN(set)；</li><li>IS NULL； IS NOT NULL</li><li>AND；</li><li>OR；</li><li>NOT； </li></ul><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><ul><li>通配符: <ul><li><code>_</code>：任意一个字符</li><li><code>%</code>：任意0~n个字符</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*查询姓名中第2个字母为“i”的学生记录*/</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stu <span class="keyword">WHERE</span> sname <span class="keyword">LIKE</span> <span class="string">'_i%'</span>;</span><br></pre></td></tr></table></figure><h3 id="字段控制查询"><a href="#字段控制查询" class="headerlink" title="字段控制查询"></a>字段控制查询</h3><ul><li><p>去重</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> sal <span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure></li><li><p>加法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*查询出来结果会多一列求和结果*/</span></span><br><span class="line"><span class="keyword">SELECT</span> *,sal+comm <span class="keyword">FROM</span> emp;</span><br><span class="line"><span class="comment">/*IFNULL把NULL转换为数值*/</span></span><br><span class="line"><span class="keyword">SELECT</span> *,sal+<span class="keyword">IFNULL</span>(comm,<span class="number">0</span>) <span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure></li><li><p>给列起别名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *, sal+<span class="keyword">IFNULL</span>(comm,<span class="number">0</span>) <span class="keyword">AS</span> total <span class="keyword">FROM</span> emp;</span><br><span class="line"><span class="comment">/*AS可以省略*/</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stu <span class="keyword">ORDER</span> <span class="keyword">BY</span> sage [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>];</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">ORDER</span> <span class="keyword">BY</span> sal <span class="keyword">DESC</span>,empno <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>聚合函数是用来做纵向运算的函数：</p><ul><li><p><code>COUNT()</code>：统计指定列不为NULL的记录行数；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*查询emp表中记录数：*/</span> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> cnt <span class="keyword">FROM</span> emp;</span><br><span class="line"><span class="comment">/*查询emp表中有佣金的人数：*/</span> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(comm) cnt <span class="keyword">FROM</span> emp;</span><br><span class="line"><span class="comment">/*查询有佣金的人数，有领导的人数：*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(comm), <span class="keyword">COUNT</span>(mgr) <span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure></li><li><p><code>MAX()</code>：计算指定列的最大值，如果指定列是字符串类型，那么使用字符串排序运算；</p></li><li><p><code>MIN()</code>：计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*查询最高工资和最低工资：*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(sal), <span class="keyword">MIN</span>(sal) <span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure></li><li><p><code>SUM()</code>：计算指定列的数值和，如果指定列类型不是数值类型，那么计算结果为0；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*查询所有雇员月薪和，以及所有雇员佣金和*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(sal), <span class="keyword">SUM</span>(comm) <span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure></li><li><p><code>AVG()</code>：计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为0；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*统计所有员工平均工资：*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(sal) <span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure></li></ul><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><ul><li><p>普通分组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*查询每个部门的部门编号和每个部门的工资和：*/</span></span><br><span class="line"><span class="keyword">SELECT</span> deptno, <span class="keyword">SUM</span>(sal) </span><br><span class="line"><span class="keyword">FROM</span> emp </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno;</span><br><span class="line"><span class="comment">/*凡和聚合函数同时出现的列名，一定要写在group by 之后*/</span></span><br></pre></td></tr></table></figure></li><li><p><code>HAVING</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*查询工资总和大于9000的部门编号以及工资和：*/</span></span><br><span class="line"><span class="keyword">SELECT</span> deptno, <span class="keyword">SUM</span>(sal)</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">SUM</span>(sal) &gt; <span class="number">9000</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意点</p></blockquote><p>having与where的区别:</p><ol><li><p><code>having</code>是在分组后对数据进行过滤.</p><p><code>where</code>是在分组前对数据进行过滤​        </p></li><li><p><code>having</code>后面可以使用聚合函数(统计函数)</p></li></ol><p>​         <code>where</code>后面不可以使用聚合函数。</p><p><code>WHERE</code>是对分组前记录的条件，如果某行记录没有满足WHERE子句的条件，那么这行记录不会参加分组；而<code>HAVING</code>是对分组后数据的约束。</p></li></ul><h3 id="LIMIT（特有）"><a href="#LIMIT（特有）" class="headerlink" title="LIMIT（特有）"></a>LIMIT（特有）</h3><ul><li>LIMIT用来限定查询结果的起始行，以及总行数。（作分页用）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*查询5行记录，起始行从0开始*/</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">LIMIT</span> <span class="number">0</span>, <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><ul><li><p>合并结果集；UNION 、  UNION ALL</p></li><li><p>连接查询</p><ul><li>内连接  [INNER] JOIN  ON </li><li>外连接  OUTER JOIN ON<ul><li>左外连接 LEFT [OUTER] JOIN</li><li>右外连接 RIGHT [OUTER] JOIN</li><li>全外连接（MySQL不支持）FULL JOIN</li></ul></li><li>自然连接  NATURAL JOIN</li></ul></li><li>子查询</li></ul><h3 id="合并结果集"><a href="#合并结果集" class="headerlink" title="合并结果集"></a>合并结果集</h3><ul><li><p>作用</p><ul><li>合并结果集就是把两个select语句的查询结果合并到一起！</li></ul></li><li><p>两种方式</p><ul><li><p>UNION：去除重复记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t2；</span><br></pre></td></tr></table></figure></li><li><p>UNION ALL：不去除重复记录</p></li></ul></li></ul><blockquote><p>要求：</p></blockquote><p><strong>要被合并的两个结果：列数、列类型必须相同，列名可不同。</strong></p><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>连接查询会产生笛卡尔积</p><p><strong>使用主外键关系做为条件来去除无用信息</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp,dept <span class="keyword">WHERE</span> emp.deptno=dept.deptno</span><br></pre></td></tr></table></figure><ul><li>内连接<ul><li>特点：查询结果必须满足条件。</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> emp e </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> dept d <span class="comment">/*MySQL默认的连接方式就是内连接*/</span></span><br><span class="line"><span class="keyword">ON</span> e.deptno=d.deptno;</span><br></pre></td></tr></table></figure><ul><li>外连接(左、右连接)<ul><li>特点：查询出的结果存在不满足条件的可能(不满足条件的显示NULL。)。</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*左连接*/</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp e </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> dept d </span><br><span class="line"><span class="keyword">ON</span> e.deptno=d.deptno;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*右连接*/</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp e </span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> dept d </span><br><span class="line"><span class="keyword">ON</span> e.deptno=d.deptno;</span><br></pre></td></tr></table></figure><h3 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h3><p>连接查询会产生无用笛卡尔积，我们通常使用主外键关系等式来去除它。而自然连接无需你去给出主外键等式，它会自动找到这一等式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> dept;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">NATURAL</span> <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> dept;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">NATURAL</span> <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> dept;</span><br></pre></td></tr></table></figure><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><ul><li><p>出现位置</p><ul><li><p>where后，作为条为被查询的一条件的一部分；</p></li><li><p>from后，作表；</p></li></ul></li><li><p>当子查询出现在where后作为条件时，还可以使用如下关键字：</p><ul><li><p>any</p></li><li><p>all</p></li></ul></li><li><p>子查询结果集的形式：</p><ul><li>单行单列（用于条件）</li><li>单行多列（用于条件）</li><li>多行单列（用于条件）</li><li>多行多列（用于表）</li></ul></li></ul><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p>自己连接自己，起别名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*求7369员工编号、姓名、经理编号和经理姓名*/</span></span><br><span class="line"><span class="keyword">SELECT</span> e1.empno , e1.ename,e2.mgr,e2.ename </span><br><span class="line"><span class="keyword">FROM</span> emp e1, emp e2 </span><br><span class="line"><span class="keyword">WHERE</span> e1.mgr = e2.empno <span class="keyword">AND</span> e1.empno = <span class="number">7369</span>;</span><br></pre></td></tr></table></figure><h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><ul><li>操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//1、注册驱动</span></span><br><span class="line">DriverManager.registerDriver(<span class="keyword">new</span> com.mysql.jdbc.Driver());</span><br><span class="line"><span class="comment">//2、创建连接</span></span><br><span class="line">Connection conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/test"</span>, <span class="string">"root"</span>, <span class="string">""</span>);</span><br><span class="line"><span class="comment">//3、得到操作db的sql语句的对象Statement</span></span><br><span class="line">Statement stmt = conn.createStatement();</span><br><span class="line"><span class="comment">//4、执行sql</span></span><br><span class="line">ResultSet rs = stmt.executeQuery(<span class="string">"select * from emp limit 0, 1"</span>);</span><br><span class="line"><span class="comment">//5、处理结果</span></span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">    System.out.println(rs.getObject(<span class="number">1</span>));<span class="comment">//结果某行第一列</span></span><br><span class="line">    System.out.println(rs.getObject(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6、关闭资源</span></span><br><span class="line">rs.close();</span><br><span class="line">stmt.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure><h2 id="常用类和接口"><a href="#常用类和接口" class="headerlink" title="常用类和接口"></a>常用类和接口</h2><h3 id="java-sql-Drivermanager类"><a href="#java-sql-Drivermanager类" class="headerlink" title="java.sql.Drivermanager类"></a>java.sql.Drivermanager类</h3><ul><li><p>创建连接</p></li><li><p>注册驱动</p><p><code>DriverManager.registerDriver(new com.mysql.jdbc.Driver());</code>不建议使用</p><ul><li>导致驱动被注册2次（<code>com.mysql.jdbc.Driver</code>中有静态代码块注册驱动）</li><li>强烈依赖数据库的驱动jar</li></ul><blockquote><p>推荐使用</p></blockquote><p><code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code>//直接加载这个Class</p></li></ul><h3 id="java-sql-Connection接口："><a href="#java-sql-Connection接口：" class="headerlink" title="java.sql.Connection接口："></a>java.sql.Connection接口：</h3><ul><li>一个连接</li></ul><p><code>Statement createStatement();</code> //创建操作sql语句的对象</p><h3 id="java-sql-Statement接口"><a href="#java-sql-Statement接口" class="headerlink" title="java.sql.Statement接口"></a>java.sql.Statement接口</h3><ul><li>操作sql语句，并返回相应结果的对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ResultSet  <span class="title">executeQuery</span><span class="params">(String sql)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//根据查询语句返回结果集。只能执行select语句。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">(String sql)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//根据执行的DML（insert update delete）语句，返回受影响的行数。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(String sql)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//此方法可以执行任意sql语句。返回boolean值，表示是否返回ResultSet结果集。仅当执行select语句，且有返回结果时返回true, 其它语句都返回false;</span></span></span><br></pre></td></tr></table></figure><h3 id="java-sql-ResultSet接口"><a href="#java-sql-ResultSet接口" class="headerlink" title="java.sql.ResultSet接口"></a>java.sql.ResultSet接口</h3><ul><li>结果集（客户端存表数据的对象）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">getObject</span><span class="params">(<span class="keyword">int</span> columnIndex)</span></span>;<span class="comment">//根据序号取值，索引从1开始</span></span><br><span class="line"><span class="function">Object <span class="title">getObject</span><span class="params">(String ColomnName)</span></span>; <span class="comment">//根据列名取值。</span></span><br></pre></td></tr></table></figure><ul><li><p>将结果集中的数据封装到javaBean中</p><ul><li><p>java的数据类型与数据库中的类型的关系</p><p>byte               tityint</p><p>short             smallint</p><p>int                  int</p><p>long             bigint</p><p>float             float</p><p>double            double</p><p>String            char varchar </p><p>Date             date</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span><span class="comment">//将光标从当前位置向下移动一行</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">(<span class="keyword">int</span> colIndex)</span><span class="comment">//以int形式获取ResultSet结果集当前行指定列号值</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">(String colLabel)</span><span class="comment">//以int形式获取ResultSet结果集当前行指定列名值</span></span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">getFloat</span><span class="params">(String colLabel)</span></span></span><br><span class="line"><span class="function">String <span class="title">getString</span><span class="params">(String colLabel)</span>  </span></span><br><span class="line"><span class="function">Date <span class="title">getDate</span><span class="params">(String columnName)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>可移动游标</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">previous</span><span class="params">()</span></span>;<span class="comment">//将光标移动到此 ResultSet 对象的上一行。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">absolute</span><span class="params">(<span class="keyword">int</span> row)</span></span>;<span class="comment">//参数是当前行的索引，从1开始。根据行的索引定位移动的指定索引行。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterLast</span><span class="params">()</span></span>;<span class="comment">//将光标移动到末尾，正好位于最后一行之后。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">beforeFirst</span><span class="params">()</span></span>;<span class="comment">//将光标移动到开头，正好位于第一行之前。</span></span><br></pre></td></tr></table></figure><h3 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  ...  </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rs.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//stmt、conn同rs</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><ul><li><p>SQL注入问题：<code>preparedStatement</code></p><p>preparedStatement：预编译对象， 是Statement对象的子类。</p><ul><li>特点<ul><li>性能要高，会把sql语句先编译</li><li>sql语句中的参数会发生变化，过滤掉用户输入的关键字</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"select * from users where name? and password=?"</span>;</span><br><span class="line">ps = conn.prepareStatement(sql); </span><br><span class="line"><span class="comment">//给预编译sql赋值</span></span><br><span class="line">ps.setString(<span class="number">1</span>, name); <span class="comment">//1代表sql语句第一个？</span></span><br><span class="line">ps.setString(<span class="number">2</span>, password);</span><br><span class="line">ps.executeQuery();</span><br></pre></td></tr></table></figure></li><li><p>DBUtils</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        加载驱动</span><br><span class="line">    &#125;</span><br><span class="line">    方法：获取连接</span><br><span class="line">    方法：关闭资源</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Insert</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stmt = conn.prepareStatement(<span class="string">"INSERT INTO users VALUES(?,?,?,?,?)"</span>);</span><br><span class="line"><span class="keyword">int</span> i = stmt.executeUpdate();</span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">"success"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Update</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stmt = conn.prepareStatement(<span class="string">"UPDATE users SET NAME=?,PASSWORD=?,email=? WHERE id=?"</span>);</span><br><span class="line">stmt.setString(<span class="number">1</span>, <span class="string">"fyd"</span>);</span><br><span class="line">stmt.setString(<span class="number">2</span>, <span class="string">"208"</span>);</span><br><span class="line">stmt.setString(<span class="number">3</span>, <span class="string">"lp@163.com"</span>);</span><br><span class="line">stmt.setInt(<span class="number">4</span>, <span class="number">1206</span>);</span><br><span class="line"><span class="keyword">int</span> i = stmt.executeUpdate();</span><br></pre></td></tr></table></figure></li><li><p>Delete</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stmt = conn.createStatement();</span><br><span class="line"><span class="keyword">int</span> i = stmt.executeUpdate(<span class="string">"DELETE FROM users WHERE id=4"</span>);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaWeb基础学习(1)</title>
      <link href="/2018/12/10/JavaWeb%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A01/"/>
      <url>/2018/12/10/JavaWeb%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A01/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p>XML语言、Tomcat服务器、Servlet、JSP简介</p></blockquote><p><img src="https://image-link.nos-eastchina1.126.net/javaweb_01"></p><a id="more"></a><h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><ol><li>概述</li></ol><ul><li>可扩展：所有的标签都是自定义的。  </li><li><p>功能：数据存储</p><ul><li>配置文件</li><li>数据传输</li></ul></li><li><p>html与xml区别：</p><ul><li>html语法松散，xml语法严格</li><li>html做页面展示，xml做<strong>数据存储</strong></li><li>html所有标签都是预定义的，xml所有标签都是自定义的</li></ul></li></ul><ol start="2"><li>语法</li></ol><ul><li><p>文档声明：</p><ul><li>必须写在xml文档的第一行。</li><li>写法：<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</code></li><li>属性：    <ul><li>version：版本号 固定值 1.0</li><li>encoding:指定文档的码表。默认值为 iso-8859-1</li><li>standalone：指定文档是否独立  yes 或 no</li></ul></li></ul></li><li><p>元素：xml文档中的标签</p><ul><li><p>文档中必须有且只能有一个根元素</p></li><li><p>元素需要正确闭合。<code>&lt;body&gt;&lt;/body&gt; &lt;br/&gt;</code></p></li><li>元素需要正确嵌套</li><li>元素名称要遵守：<ul><li>元素名称区分大小写</li><li>数字不能开头</li></ul></li></ul></li><li><p>文本：</p><ul><li>转义字符：<code>&amp;gt;</code>  等价于&gt;</li><li>CDATA: 里边的数据会原样显示<ul><li><code>&lt;![CDATA[ 数据内容 ]]&gt;</code></li></ul></li></ul></li><li><p>属性：</p><ul><li>属性值必须用引号引起来。单双引号都行</li></ul></li><li><p>注释：</p><!-- --></li><li><p>处理指令：现在基本不用<br><code>&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;1.css&quot;?&gt;</code></p></li></ul><ol start="3"><li><p>xml约束</p><p>1）、dtd:</p><ul><li>内部dtd：在xml内部定义dtd(了解，一般不自己写)</li></ul></li></ol><ul><li><p>外部dtd：在外部文件中定义dtd<br>​    * 本地dtd文件：<code>&lt;!DOCTYPE students SYSTEM  &quot;student.dtd&quot;&gt;</code></p><ul><li>网络dtd文件：<code>&lt;!DOCTYPE students PUBLIC &quot;名称空间&quot;  &quot;student.dtd&quot;&gt;</code></li></ul><p>2）、schema:</p></li><li><p>导入xsd约束文档：</p><ul><li>编写根标签</li><li>引入实例名称空间 <code>xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</code></li><li>引入名称空间 <code>xsi:schemaLocation=&quot;localhost/xml student.xsd&quot;</code></li><li>引入默认的名称空间</li></ul></li></ul><ol start="4"><li>xml解析<ul><li>DOM4J解析</li><li>XPATH(专用于查询)</li></ul></li></ol><h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><ul><li><p>javaEE规范：</p><ul><li>13种技术的总称。<code>Servelet/Jsp</code>、<code>JDBC</code>、<code>JNDI</code>、<code>JTA</code>…</li></ul></li><li><p>常见服务器</p><ul><li><p>WebLogic、WebSphereAS、JbossAS，都支持javaEE规范</p></li><li><p>轻量级Tomcat，支持<code>Servelet/Jsp</code>规范</p></li></ul></li></ul><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><ul><li><p>目录</p><p><img src="/2018/12/10/JavaWeb基础学习1/目录介绍.jpg" alt=""></p></li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul><li><p>请求</p><p><img src="/2018/12/10/JavaWeb基础学习1/request.png" alt=""></p><ul><li><p>请求消息行</p><p><code>GET  /index.html?name=lp&amp;pwd=fyd  HTTP/1.1</code></p></li><li><p>请求消息头</p><ul><li>Accept:浏览器可接受的MIME类型(能接收的文件类型)</li><li>Accept-Encoding:浏览器能够进行解码的数据编码方式</li><li>……</li></ul></li><li><p>消息正文</p><p><code>name=lp&amp;pwd=fyd</code></p></li></ul></li><li><p>响应</p><ul><li><p>响应消息行</p><p><code>HTTP/1.1   200   OK</code></p><p>协议/版本   响应状态码  对响应码的描述（一切正常）</p><ul><li><p>200(正常)  一切正常</p></li><li><p>302/307(临时重定向)</p></li><li><p>304(未修改)</p><ul><li>表示客户机缓存的版本是最新的，客户机可以继续使用它，无需到服务器请求。</li></ul></li><li><p>404(找不到)  服务器上不存在客户机所请求的资源。</p></li><li><p>500(服务器内部错误)</p></li></ul></li><li><p>响应消息头</p></li><li><p>响应正文</p></li></ul></li></ul><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>​    servlet 是运行在 Web 服务器中的小型 Java 程序（即：服务器端的小应用程序）<strong>无须手动new</strong>。servlet 通常通过 HTTP（超文本传输协议）接收和响应来自 Web 客户端的请求。</p><ul><li>写一个Java类，实现servlet</li><li>修改web.xml文件，给servlet提供一个可访问的URI地址</li></ul><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><ol><li><p>浏览器   <code>:8080/myWebApp/demo</code></p></li><li><p>tomcat   找到<code>myWebApp</code></p></li><li><p>web.xml  找到<code>/demo</code>后</p></li><li><p>通过<code>&lt;servlet-name&gt;</code>找到对应的<code>.class</code>并实例化(单实例)</p><p>(<code>&lt;load-on-startup&gt;</code>可以启动就实例化，数字表示优先级)</p></li><li><p>调用<code>init()</code></p></li><li><p>调用<code>service()</code>，多线程（来一次请求调用一次）</p></li><li><p>把信息响应给客户端 </p></li><li><p>直到<code>myWebApp</code>被卸载调用<code>destroy()</code></p></li></ol><h3 id="三种创建方式"><a href="#三种创建方式" class="headerlink" title="三种创建方式"></a>三种创建方式</h3><ul><li>实现<code>javax.servlet.Servlet</code>接口</li><li><p>继承<code>javax.servet.GenericServlet</code>类     (适配器模式)</p></li><li><p>继承<code>javax.servlet.http.HttpServlet</code>类（模板方法设计模式）开发使用</p></li></ul><blockquote><p>注意点</p></blockquote><p>如果<code>&lt;url-pattern&gt;</code>的值是/，表示执行默认映射，所有资源都是servlet</p><h3 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h3><p><img src="/2018/12/10/JavaWeb基础学习1/Servlet核心类.jpg" alt=""></p><h3 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h3><ul><li>获取servlet配置信息<ul><li>法1：重写<code>init</code>方法，获取<code>ServletConfig</code>对象</li><li>法2：通过<code>getServletConfig()</code>方法获取对象</li><li>法3：直接调用父类<code>getInitParameter(key)</code>方法，因为子类没重写该方法this或者super均可。</li></ul></li></ul><blockquote><p><strong>深入分析</strong></p></blockquote><ol><li><code>HttpServlet</code>继承了<code>GenericServlet</code>默认的<code>init(ServletConfig config)</code>方法</li><li><p>该方法实现了抽象类<code>GenericServlet</code>中私有的<code>ServletConfig config</code>的赋值</p></li><li><p>使得<code>HttpServlet</code>的this调用<code>getInitParameter</code>方法能获取到配置信息。</p></li><li><p>所以如果重写了init方法，就会导致this调用失败</p></li></ol><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><p><code>this.getServletContext()</code>代表整个应用。</p><p>一个webApp__只有一个__ServletContext对象（无论多少个用户共用一个），单实例</p><ul><li><p>域对象</p><ul><li>使多个<code>Servlet</code>共享数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name,object value)</span></span>;</span><br><span class="line"><span class="comment">//向ServletContext对象的map中添加数据</span></span><br><span class="line"><span class="function">Object <span class="title">getAttribute</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="comment">//从ServletContext对象的map中取数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rmoveAttribute</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="comment">//根据name去移除数据</span></span><br></pre></td></tr></table></figure></li><li><p>获取全局配置信息</p><p>web.xml（必须是全局，也就是在servlet标签外部的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;UTF-8&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br><span class="line">String encoding = sc.getInitParmeter(<span class="string">"encoding"</span>);</span><br></pre></td></tr></table></figure></li><li><p>获取资源路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc.getRealPath(<span class="string">"/WEB-INF/classes/包名/文件名"</span>);</span><br><span class="line">sc.getRealPath(<span class="string">"/index.jsp"</span>)</span><br></pre></td></tr></table></figure></li><li><p>实现servlet转发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ServletContext sc = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">RequstDispatcher rd = sc.getRequstDispatcher(<span class="string">"/servlet/new"</span>);</span><br><span class="line"><span class="comment">//不需要再加App名的路径,只是app内部的servlet转发</span></span><br><span class="line">rd.forward(request, response);</span><br></pre></td></tr></table></figure></li></ul><h3 id="Req-amp-Res"><a href="#Req-amp-Res" class="headerlink" title="Req &amp; Res"></a>Req &amp; Res</h3><ol><li><code>HttpServletResponse</code></li></ol><ul><li><p>响应行</p></li><li><p>响应头</p><ul><li><p>不缓存</p><p><code>response.setHeader(&quot;cache-control&quot;, &quot;no-cache&quot;)</code></p><p><code>response.setDateHeader(&quot;expires&quot;,0);</code></p></li><li><p>刷新</p><p><code>response.setHeader(&quot;refresh&quot;, &quot;3;url=...&quot;)</code>3秒后刷新到新页面</p></li><li><p>下载文件</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String filename = URLEncoder.encode(文件名, <span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">//告知客户端下载文件</span></span><br><span class="line">response.setHeader(<span class="string">"content-disposition"</span>, <span class="string">"attachment;filename="</span>+filename);</span><br><span class="line">response.setHeader(<span class="string">"content-type"</span>, <span class="string">"image/jpeg"</span>);</span><br></pre></td></tr></table></figure></li><li><p>响应正文</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">response.setCharacterEncoding(<span class="string">"UTF-8"</span>);<span class="comment">//服务器编码</span></span><br><span class="line">response.setHeader(<span class="string">"content-type"</span>, <span class="string">"text/html;charset=UTF-8"</span>);<span class="comment">//告诉浏览器应使用编码</span></span><br><span class="line">response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>)<span class="comment">//一步到位</span></span><br><span class="line"></span><br><span class="line">response.getWriter().write();</span><br><span class="line">response.getOutputStream().write(<span class="string">"str"</span>.getBytes());</span><br></pre></td></tr></table></figure></li><li><p>请求重定向</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">response.setStatus(<span class="number">302</span>);</span><br><span class="line">response.setHeader(<span class="string">"location"</span>, <span class="string">"/myApp/servlet/className"</span>);</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">response.sendRedirect(<span class="string">"/myApp/servlet/className"</span>); </span><br><span class="line"><span class="comment">//重定向之后的代码会继续执行再跳转，可以加个return</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意点</p><ol><li><p><code>getOutputStream</code>和<code>getWriter</code>互相排斥，只能用其一</p></li><li><p>底层分别对应<code>ServletOutputStream</code>和<code>PrintWriter</code></p></li><li>Servlet程序向两个输出流对象写入的数据将被Servlet引擎从<code>response</code>里获取，再将这些当响应消息正文，与行和头组合输出到客户端</li><li>Servlet的<code>service</code>方法结束后，引擎将检查输出流对象是否调用过<code>close()</code>，若未关闭则由引擎来关闭</li></ol></blockquote><ol start="2"><li>HttpServletRequest</li></ol><ul><li>请求行</li></ul><p><code>Get  http://localhost:8080/myApp/servlet/main?username=lp  http/1.1</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getMethod</span><span class="params">()</span></span>; <span class="comment">//获得请求方式 GET</span></span><br><span class="line"><span class="function">String <span class="title">getRequestURL</span><span class="params">()</span></span>;<span class="comment">//返回客户端发出请求时的完整URL。</span></span><br><span class="line"><span class="function">String <span class="title">getRequestURI</span><span class="params">()</span></span>; <span class="comment">//返回请求行中的资源名部分。</span></span><br><span class="line"><span class="function">String <span class="title">getContextPath</span><span class="params">()</span></span>; <span class="comment">//当前应用的虚拟目录    /my (重要)</span></span><br><span class="line"><span class="function">String <span class="title">getQueryString</span><span class="params">()</span> </span>; <span class="comment">//返回请求行中的参数部分   username=lp</span></span><br></pre></td></tr></table></figure><ul><li>请求消息头</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getHeader</span><span class="params">(String name)</span>  <span class="comment">//根据头名称得到头信息值</span></span></span><br><span class="line"><span class="function">Enumeration <span class="title">getHeaderNames</span><span class="params">()</span>  <span class="comment">//得到所有头信息name</span></span></span><br><span class="line"><span class="function">Enumeration <span class="title">getHeaders</span><span class="params">(String name)</span><span class="comment">//根据头名称得到相同名称头信息值</span></span></span><br></pre></td></tr></table></figure><ul><li>请求正文</li></ul><blockquote><p>切记：告诉服务端解析请求的编码方式</p></blockquote><p><code>req.setCharacterEncoding(&quot;UTF-8&quot;);</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> name=<span class="string">"username"</span> /&gt;</span><br><span class="line"><span class="function">String <span class="title">getParameter</span><span class="params">(name)</span> <span class="comment">//根据表单中name属性的名，获取value</span></span></span><br><span class="line"><span class="function">String <span class="title">getParameterValues</span><span class="params">(String name)</span><span class="comment">//专业为复选框取取提供的方法</span></span></span><br><span class="line"><span class="function">Enumeration <span class="title">getParameterNames</span><span class="params">()</span> <span class="comment">//得到表单提交的所有name的方法 </span></span></span><br><span class="line"><span class="function">Map&lt;String, String[]&gt; getParameterMap </span></span><br><span class="line"><span class="function"><span class="comment">//到表单提交的所有值的方法  (做框架用)非常实用</span></span></span><br><span class="line"><span class="function">getInputStream  <span class="comment">//以字节流的方式得到所有表单数据</span></span></span><br></pre></td></tr></table></figure><ul><li>请求转发</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">req.setAttribute(<span class="string">"newKey"</span>, <span class="string">"newData"</span>);<span class="comment">//2次包装，转发</span></span><br><span class="line">req.getAttribute(<span class="string">"newKey"</span>);<span class="comment">//必须set过的，表单提交的无法获取</span></span><br><span class="line">req.removeAttribute(<span class="string">"newKey"</span>);        </span><br><span class="line">req.getRequstDispatcher(<span class="string">"/servlet/new"</span>).foward(req, resp);</span><br><span class="line"><span class="comment">//转发处理完会回来继续执行原servlet未执行的语句</span></span><br><span class="line">    <span class="comment">//请求包含</span></span><br><span class="line">req.getRequstDispatcher(<span class="string">"/servlet/new"</span>).include(req, resp);</span><br><span class="line"><span class="comment">//与转发的区别</span></span><br><span class="line"><span class="number">1</span>.如果Aservlet请求BServlet那么A中最好不要在添加响应体，否则导致的结果即是两种，但是添加响应头是可以的（就是“留头不留体”）</span><br><span class="line"><span class="number">1</span>）数据被清空，不会发送到客户端。</span><br><span class="line"><span class="number">2</span>）数据已提交但是在转发时出现异常。</span><br></pre></td></tr></table></figure><blockquote><p>转发和包含的区别</p></blockquote><ul><li><p>转发</p><p>如果Aservlet请求BServlet那么A中最好不要在添加响应体，否则导致的结果即是两种，但是添加响应头是可以的（就是“<strong>留头不留体</strong>”）</p><ul><li>数据被清空，不会发送到客户端。</li><li>数据已提交但是在转发时出现异常。</li></ul></li><li><p>包含</p><p><strong>留头又留体</strong>，由两个Servlet共同完成响应。</p></li></ul><blockquote><p>转发和重定向的区别</p></blockquote><ul><li><p>转发</p><ul><li>转发request 由服务器执行</li><li>客户端只发送一次请求</li><li>地址栏不变</li><li>转发能传递数据</li><li>转发不可跳转其他应用，只能在本应用下的资源</li><li>转发也是一个域对象（当前应用，多个servlet共享）</li><li>要么是Get要么是Post</li></ul></li><li><p>重定向</p><ul><li>重定向response 由客户端执行</li><li>客户端发送2次请求</li><li>地址栏会变</li><li>不能传递数据</li><li>可跳转到其他应用</li><li>一定是Get</li></ul></li></ul><h3 id="Cookie-amp-Session"><a href="#Cookie-amp-Session" class="headerlink" title="Cookie&amp;Session"></a>Cookie&amp;Session</h3><ol><li><p>Cookie</p><p>由于Cookie数据是由客户端来保存和携带的，所以称之为<strong>客户端技术</strong></p></li></ol><ul><li>小案例：上次访问时间</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">req.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">resp.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">PrintWriter out = resp.getWriter();</span><br><span class="line"><span class="comment">//获取当前path下的所有Cookie</span></span><br><span class="line">Cookie[] cookies = req.getCookies();</span><br><span class="line"><span class="keyword">if</span>(cookies != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Cookie ck : cookies) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"lastTime"</span>.equals(ck.getName())) &#123;</span><br><span class="line">            out.print(<span class="string">"上次访问时间为："</span> + <span class="keyword">new</span>                   Date(Long.parseLong(ck.getValue())).toLocaleString());</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置Cookie</span></span><br><span class="line">Cookie ck = <span class="keyword">new</span> Cookie(<span class="string">"lastTime"</span>, System.currentTimeMillis()+<span class="string">""</span>);</span><br><span class="line"><span class="comment">//持久化5min存到磁盘</span></span><br><span class="line">ck.setMaxAge(<span class="number">60</span>*<span class="number">5</span>); </span><br><span class="line">ck.setPath(<span class="string">"/myApp"</span>);</span><br><span class="line">ck.setPath(req.getContextPath())<span class="comment">//同上，当前App下共享Cookie</span></span><br><span class="line">ck.setPath(<span class="string">"/"</span>) <span class="comment">//直接把服务器上的所有应用共享Cookie</span></span><br><span class="line">resp.addCookie(ck);</span><br></pre></td></tr></table></figure><ul><li><p>属性</p><ul><li><p>name：名称不能唯一确定一个Cookie。因为路径可能不同。</p></li><li><p>value：能存中文。注意考虑编码的一致性</p></li><li><p>path：默认值是写Cookie的那个程序的访问路径</p><p><code>http://localhost:8080/myApp/servlet/ck1</code>写的Cookie</p><ul><li>path就是：<code>/myApp/servlet/</code></li><li>客户端在访问服务器另外资源时，根据访问的路径来决定是否带着Cookie到服务器</li><li>当前访问的路径如果是以Cookie的path开头的路径，浏览器就带。否则不带。例如<code>/myApp/servlet/1path/2path</code>可访问，而<code>/myApp/</code>不行，可以通过<code>setPath()</code>方式解决。</li></ul></li><li><p>maxAge：Cookie的缓存时间。默认是-1（默认存在浏览器的内存中）。单位是秒。</p><ul><li><p>负数：cookie的数据存在浏览器缓存中</p></li><li><p>0：删除。路径要保持一致，否则可能删错人。</p></li><li><p>正数：缓存（持久化到磁盘上）的时间</p></li></ul></li></ul></li><li><p>相关细节</p><ul><li><p>一个Cookie只能标识一种信息</p></li><li><p>浏览器一般只允许存放300个Cookie，每个站点最多存放20个，每个限制为4KB</p></li><li><p>如果创建了一个Cookie，并将它发送到浏览器</p><ul><li><p>默认情况下是一个会话级别的（即存储在浏览器内存中），用户退出浏览器则被删除。</p></li><li><p>若希望持久化存储到磁盘，则需要使用<code>maxAge</code>。</p></li></ul></li><li><p>删除Cookie时，path必须一致，否则无法删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cookie ck = <span class="keyword">new</span> Cookie(<span class="string">"lastTime"</span>, <span class="string">""</span>);</span><br><span class="line">ck.setPath(<span class="string">"/myApp"</span>);</span><br><span class="line">ck.setMaxAge(<span class="number">0</span>); </span><br><span class="line">resp.addCookie(ck);</span><br></pre></td></tr></table></figure></li></ul></li></ul><ol start="2"><li><p>Session</p><p>​    服务器为每个用户浏览器创一个Session对象，<strong>一个浏览器独占一个Session</strong>。因此，在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的Session。当用户浏览器访问当前App下其他程序，获取该Session。</p></li></ol><ul><li><p>特点</p><ul><li>同一个会话下<strong>，可以使一个应用的</strong>多个资源共享数据</li><li>cookie客户端技术，只能存字符串。HttpSession服务器端的技术，它可以存对象。</li></ul></li><li><p>原理</p><ul><li>服务器获取名称为<code>JSESSIONID</code>的Cookie的值。</li><li>若无该Cookie，创建一个新的HttpSession对象，分配一个唯一的<code>SessionID</code>，并保存在B的cookie中<code>JSESSIONID:1023</code>。</li><li>有这样的Cookie，获取cookie的值（即HttpSession对象的值），从服务器的内存中根据ID找那个HttpSession对象</li></ul></li><li><p>常用API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name,Object value)</span></span>;</span><br><span class="line"><span class="function">Object <span class="title">getAttribute</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String name)</span></span>;</span><br><span class="line">HttpSession.getId():</span><br><span class="line">setMaxInactiveInterval(<span class="keyword">int</span> interval)  设置session的存活时间</span><br><span class="line">invalidate() 使此会话无效</span><br></pre></td></tr></table></figure></li><li><p>状态</p><ul><li><p>创建</p></li><li><p>销毁</p><ul><li>强制：<code>invalidate()</code></li><li><p>超时：<code>setMaxInactiveInterval</code>（默认30min）</p></li><li><p>xml中设置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置有效时间min --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>1<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>序列化</p><p>​    当内存溢出，服务器重启等，tomcat会把HttpSession持久化到本地，记得对应类要实现<code>serializable</code>接口（钝化-搁置）    </p><p>​    等重启后（活化-激活）</p></li></ul></li></ul><blockquote><p>当禁用cookie</p></blockquote><ol><li><p><code>request.getSession();</code>必须写。</p></li><li><p><code>response.encodeURL(String url);</code></p><p>返回的url： <code>http://url;JSESSIONID=111</code></p></li></ol><h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><p>JSP__本质__就是Servlet。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol><li><p>浏览器访问jsp页面，服务器是如何调用执行jsp页面？（Servlet）</p><ul><li><p>tomcat定位到<code>/myWebApp</code>项目</p></li><li><p>服务器把<code>index.jsp</code>转译成<code>index_jsp.java</code>，继而编译成<code>.class</code>文件</p><p>（故而第二次访问会快很多，由于已经编译好）</p></li></ul></li><li><p>web服务器在执行jsp页面时，如何把页面中html发送给客户端，以及执行Java代码？</p><ul><li>在转译后的<code>.java</code>文件，<code>out.write(&quot;&lt;html&gt;\r\n&quot;)</code>，就像原生返回字符串一样返回。</li><li>java代码原样执行</li></ul></li></ol><h3 id="编写原则"><a href="#编写原则" class="headerlink" title="编写原则"></a>编写原则</h3><ul><li><p>Servlet：重点编写java代码逻辑 （获取表单数据、处理业务逻辑、分发转向）</p></li><li><p>JSP：代码显示模板。重点在于显示数据</p></li></ul><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul><li><p>模板元素即html</p></li><li><p>脚本</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;% code %&gt;</span><br><span class="line">&lt;%=<span class="number">2</span>+<span class="number">3</span>%&gt; 等价于 out.print(<span class="number">2</span>+<span class="number">3</span>)</span><br><span class="line">&lt;%! %&gt; 表示在类中定义全局成员，和静态块</span><br><span class="line"></span><br><span class="line">&lt;%-- 被注释内容 --%&gt; 安全，省流量</span><br><span class="line">&lt;!--html注释 --&gt;  用户看的到不安全</span><br></pre></td></tr></table></figure></li><li><p>3指令 (告诉jsp引擎如何处理jsp页面中其余部分)</p><ul><li>page</li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span>  pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br></pre></td></tr></table></figure><ul><li><p>include</p><ul><li><p>静态包含</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ include file=<span class="string">"/include/header.jsp"</span> %&gt;</span><br></pre></td></tr></table></figure></li><li><p>动态包含</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include page="/include/header.jsp"&gt;&lt;/jsp:include&gt;</span><br></pre></td></tr></table></figure><blockquote><p>区别：翻译的时间段不同</p></blockquote><p>前者：在翻译时就把两个文件合并</p><p>后者：不会合并文件，当代码执行到include时，才包含另一个文件的内容。</p><p>原则：能用静的就不用动的。</p></li></ul></li><li><p>tablib</p><p>作用：在JSP页面中导入JSTL标签库。替换jsp中的java代码片段。</p></li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> prefix=<span class="string">"别名"</span> %&gt;</span><br></pre></td></tr></table></figure></li><li><p>6个动作</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include &gt; 动态包含</span><br><span class="line">&lt;jsp:forward&gt; 请求转发</span><br><span class="line">&lt;jsp:param&gt; 设置请求参数</span><br><span class="line"></span><br><span class="line">&lt;jsp:useBean&gt; 创建一个对象</span><br><span class="line">&lt;jsp:setProperty&gt; 给指定的对象属性赋值</span><br><span class="line">&lt;jsp:getProperty&gt; 取出指定对象的属性值</span><br></pre></td></tr></table></figure></li><li><p>9大内置对象</p><p> 在&lt;%=%&gt; &lt;% %&gt;内部直接使用的对象</p></li></ul><table><thead><tr><th style="text-align:left">对象名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left">request</td><td>javax.servlet.http.HttpServletRequest</td><td></td></tr><tr><td style="text-align:left">response</td><td>…HttpServletResponse</td><td></td></tr><tr><td style="text-align:left">session</td><td>…HttpSession</td><td>由session=”true”开关</td></tr><tr><td style="text-align:left">application</td><td>javax.servlet.ServletContext</td><td></td></tr><tr><td style="text-align:left">exception</td><td>java.lang.Throwable</td><td>由isErrorPage=”false”开关</td></tr><tr><td style="text-align:left">page</td><td>java.lang.Object当前对象this</td><td>当前servlet实例</td></tr><tr><td style="text-align:left">config</td><td>javax.servlet.ServletConfig</td><td></td></tr><tr><td style="text-align:left">out</td><td>javax.servlet.jsp.JspWriter</td><td>printWriter对象</td></tr><tr><td style="text-align:left">pageContext</td><td>javax.servlet.jsp.PageContext</td></tr></tbody></table><p>pageContext(重要)</p><ol><li><p>本身也是一个域对象：它可以操作其它三个域对象（request session application）的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">findAttribute(String name); </span><br><span class="line"><span class="comment">//自动从page request session application依次查找，找到了就取值，结束查找。</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><p><code>PageContext</code> :  存放的数据在当前页面有效。开发时使用较少。</p></li><li><p><code>ServletRequest</code>: 存放的数据在一次请求（转发）内有效。使用非常多。</p></li><li><p><code>HttpSession</code>: 存放的数据在一次会话中有效。使用的比较多。如：存放用户的登录信息，购物车功能。</p></li><li><p><code>ServletContext</code>: 存放的数据在整个应用范围内都有效。因为范围太大，应尽量少用。</p></li></ul><ol><li><p>它可以创建其它的8个隐式对象</p><p>在普通类中可以通过PageContext获取其他JSP隐式对象。自定义标签时就使用。</p></li><li><p>提供了的简易方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pageContext.forward(<span class="string">"2.jsp"</span>);</span><br><span class="line">pageContext.include(<span class="string">"2.jsp"</span>);</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>附加：简化java代码</p></blockquote><ul><li><p>EL表达式：</p><p>要简化jsp中java代码开发。它不是一种开发语言，是jsp中<strong>获取数据</strong>的一种规范</p></li><li><p>JSTL：JSP标准标签库</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XML语言 </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>shell编程</title>
      <link href="/2018/12/01/Shell/"/>
      <url>/2018/12/01/Shell/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p>bash、变量、shell编程</p></blockquote><p><img src="https://image-link.nos-eastchina1.126.net/shell"></p><a id="more"></a><h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><p>命令行解释器，提供给user一个向Linux内核发送请求以便执行对应任务的工具</p><ul><li><p>分类</p><p>Bourne Shell：sh、ksh、<strong>Bash</strong>、psh、zsh</p><p>C Shell（BSD版的Unix中）：csh、tcsh</p></li><li><p>执行</p><ul><li><p>直接运行</p><p>chmod  755  hello.sh</p><p>./hello.sh</p></li><li><p>Bash调用执行</p><p>bash  hello.sh </p></li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash     (若调用其他语言，这行不要省略)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注释</span></span><br><span class="line">echo -e "\e[1;31m text \e[0m"          </span><br><span class="line"><span class="meta">#</span><span class="bash">31m=红色     32m=绿色    33m=黄色</span></span><br></pre></td></tr></table></figure><h2 id="bash中基本功能"><a href="#bash中基本功能" class="headerlink" title="bash中基本功能"></a>bash中基本功能</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1.别名</span></span><br><span class="line">alias ls='ls --color=auto' </span><br><span class="line"><span class="meta">#</span><span class="bash">设定别名，临时生效  </span></span><br><span class="line"><span class="meta">#</span><span class="bash">永久，写入环境变量配置文件 ~/.bashrc   再souce重新加载配置文件生效，不然要重启</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">2.历史</span></span><br><span class="line">history -c:清空历史命令</span><br><span class="line">-w:把缓存中历史命令写入~/.bash_history</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">3.输出重定向</span></span><br><span class="line">命令 &amp;&gt;文件  #覆盖方式全都写到文件中</span><br><span class="line">命令 &gt;&gt; 文件1  2&gt;&gt;文件2 #正确追加到文件1，错误输出追加到文件2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">4.多命令执行</span></span><br><span class="line">date ; 处理 ; date #可以用来看处理时间  可以配合&amp;&amp; ||</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">5.通配符</span></span><br><span class="line">*  ?  [0-9]   [^0-9]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">6.Bash中其他特殊符号</span></span><br><span class="line">'' #单引号中所有特殊字符都没特殊含义</span><br><span class="line">"" #双引号中，$调用变量   `引用命令  \转义符</span><br><span class="line"><span class="meta">$</span><span class="bash">() &lt;=&gt; `` 等价于反引号执行系统命令   $取变量值</span></span><br></pre></td></tr></table></figure><h2 id="Bash变量与变量分类"><a href="#Bash变量与变量分类" class="headerlink" title="Bash变量与变量分类"></a>Bash变量与变量分类</h2><p>bash中变量存的所有类型（string,number,date等）都是字符串类型</p><h3 id="用户自定义变量"><a href="#用户自定义变量" class="headerlink" title="用户自定义变量"></a>用户自定义变量</h3><ul><li>只在当前shell有效</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name="lai ping"   #  =不能有空格，否则当命令解析错误</span><br><span class="line">name="$name"456   #  变量叠加  name=lai ping456</span><br><span class="line">set  #  查询系统下所有变量  -u  可以用提示，调用未定义的变量，默认无</span><br><span class="line">unset name      # 删除变量</span><br></pre></td></tr></table></figure><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>全局变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export x=1  #设置环境变量</span><br><span class="line">set #查看所有变量(当前shell局部和全局)</span><br><span class="line">env #查看环境变量</span><br></pre></td></tr></table></figure><p>常用环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SHELL:当前</span><br><span class="line">TERM:终端环境</span><br><span class="line">PATH:PATH环境变量  系统查找命令的路径</span><br><span class="line"></span><br><span class="line">PATH="$PATH":/root/sh  #增加PATH变量的值</span><br></pre></td></tr></table></figure><h3 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h3><ul><li>$n：n为数字，0代表命令本身，1-9代表第1到9个参数，10以上参数需要 {10}</li><li>$*：命令行所有参数，把所有参数看做一个整体</li><li>$@：所有参数，把每个参数区分对待，for循环体现区别</li><li>$#：所有参数个数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">num1=$1</span><br><span class="line">num2=$2</span><br><span class="line">sum=$(($num1+$num2))</span><br><span class="line">echo $sum</span><br><span class="line"></span><br><span class="line">./sum.sh 12 2434</span><br></pre></td></tr></table></figure><h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><ul><li>$?：最后一次执行的命令的返回状态。若为0，证明上个命令正确执行</li><li>$$：当前进程的进程号（PID）</li><li>$!：后台运行最后一个进程的进程号</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>declare [+/-] 选项  变量名   </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">declare -i c  #定义c为整型变量 </span><br><span class="line">declare -x MYPATH #等价于 export MYPATH</span><br></pre></td></tr></table></figure><p>$((运算式))</p><p>变量测试在脚本优化时用</p><h2 id="环境变量配置文件"><a href="#环境变量配置文件" class="headerlink" title="环境变量配置文件"></a>环境变量配置文件</h2><ul><li><p>简介</p><ul><li>主要是定义对系统的操作环境生效的系统默认环境变量，如PATH、HISTSIZE、PS1、HOSTNAME等默认环境变量。</li></ul></li><li><p>source 配置文件 或 . 配置文件</p><ul><li>配置文件生效，不用重启</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/profile</span><br><span class="line">/etc/profile.d/*.sh</span><br><span class="line">~/.bash_profile</span><br><span class="line">~/.bashrc  </span><br><span class="line">/etc/bashrc</span><br></pre></td></tr></table></figure><ul><li>登录调用顺序</li></ul><p>/etc/profile →  ~/.bash_profile →  ~/.bashrc →  /etc/bashrc  →  命令提示符</p><p>​           ↓                                    (区分no login 即切换子shell)</p><p>/etc/profile.d/*.sh</p><p>​           ↓</p><p>/etc/profile.d/lang.sh  →   /etc/sysc config/i18n（语言）</p><p>(区分no login就是切换子shell) </p><ul><li>其他配置文件<ul><li>~/.bash_logout：  注销生效</li><li>~/.bash_history：  当前的会在history,注销才写入</li><li>/etc/issue： 本地终端登录信息 issue.net 远程登录</li></ul></li></ul><h2 id="Shell-编程"><a href="#Shell-编程" class="headerlink" title="Shell 编程"></a>Shell 编程</h2><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><ul><li><p>把本来输出到屏幕到重定向到文件</p><ul><li>/dev/stdout  1 正确  </li><li>/dev/stderr   2 错误</li></ul></li><li><p>用来管理错误日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">错误命令  2&gt;&gt;err.log</span><br><span class="line"></span><br><span class="line">命令 &gt;&gt; 文件 2&gt;1&amp; <span class="comment">#追加方式，正确错误都保存到文件</span></span><br><span class="line">命令 &amp;&gt;&gt;文件   <span class="comment">#同上功能</span></span><br><span class="line">    &amp;&gt;/dev/null <span class="comment">#丢弃</span></span><br><span class="line">命令 &gt;&gt;文件1 2&gt;&gt;文件2 <span class="comment">#正确1 错误2</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><ul><li><p>与通配符区别</p><ul><li>正则是文件中匹配符合条件的<strong>字符串</strong>，包含匹配。grep、awk、sed等</li><li>通配符（*, ?）是匹配条件的<strong>文件名</strong>，完全匹配。ls、find、cp</li></ul></li><li><p>常见</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">*  前一个字符匹配0次或任意多次  <span class="string">"a*"</span> 匹配所有，无意义</span><br><span class="line">.    匹配任意一个字符</span><br><span class="line">^匹配行首<span class="string">"^$"</span> 空白行</span><br><span class="line">$匹配行尾</span><br><span class="line">[]一个字符</span><br><span class="line">[^]</span><br><span class="line">\转义 (一部分必须转义才能表示、一部分转义后有特殊含义或功能)</span><br><span class="line">\+      1次或多次</span><br><span class="line">\?零次或一次</span><br><span class="line">\&#123;n\&#125;表示其前面字符恰好n次</span><br><span class="line">\&#123;n,\&#125;</span><br><span class="line">\&#123;n,m\&#125;</span><br></pre></td></tr></table></figure><h3 id="字符截取命令"><a href="#字符截取命令" class="headerlink" title="字符截取命令"></a>字符截取命令</h3><ul><li>cut<ul><li>提取一行中某个字段，与grep搭配使用</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#格式</span></span><br><span class="line">cut -f(列号) 1,3  -d(分隔符,默认是tab) <span class="string">":"</span>    <span class="comment"># 第1列内容:第3列内容</span></span><br><span class="line"><span class="comment">#案例 （提取自添加用户名）</span></span><br><span class="line">cat /etc/passwd | grep /bin/bash | grep -v(取反) root | cut -d <span class="string">":"</span> -f 1</span><br></pre></td></tr></table></figure><ul><li>printf （在awk中用，一般就用cat、echo）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#很像C语言</span></span><br><span class="line">%ns   <span class="comment">#n表示输出几个字符</span></span><br><span class="line">%ni  <span class="comment">#n输出几个数字</span></span><br><span class="line">%m.nf <span class="comment">#m整数位数，n小数位数</span></span><br></pre></td></tr></table></figure><ul><li><p>awk （比cut强大多、复杂）</p></li><li><p>sed（重点★）</p><ul><li>轻量级流编辑器。对数据进行选取、替换、删除、新增的命令</li><li>相比于vi，不光可以修改文件内容，还可以直接修改命令结果</li></ul><p>格式：</p><p>​    <code>sed [option] &#39;[action]&#39; 文件名</code></p><ul><li>option:<ul><li>-n       一般sed命令输出所有数据。此处会把经过sed处理的行输出到屏幕</li><li>-e       允许对输入数据应用多条sed编辑</li><li>-i        用sed的修改结果直接修改读取数据的文件，而不是输出到屏幕        </li></ul></li><li>action:<ul><li>a \       追加， 在当前行后添加一行或多行。添加多行，除最后一行，每行末尾需要用<code>&quot;\&quot;</code>代表数据未完结。</li><li>c \     行替换，用c后面的字符串替换原数据行，替换多行时………同上</li><li>i \     插入，在当期行前插入一行或多行。插入多行………同上</li><li>d     删除，删除指定行</li><li>p    打印，输出指定的行</li><li>s    字串替换，用一个字符串替换另一个字符串。</li></ul></li></ul></li></ul><p>​            格式为<code>&quot;行范围s/旧字串/新字串/g&quot;</code></p><p>​          （ /g表示一行中<strong>所有</strong>匹配到的，不加则为第一次匹配到的）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'2p'</span> file  <span class="comment">#打印输出第2行</span></span><br><span class="line">sed <span class="string">'2,4d'</span> file <span class="comment">#删除第2到4行   $表示最后行</span></span><br><span class="line">sed <span class="string">'/2/d'</span> test.txt     <span class="comment">#sed中正则用/.../中间</span></span><br><span class="line">sed <span class="string">'2a hello'</span> file  <span class="comment">#在第二行后追加hello</span></span><br><span class="line">sed <span class="string">'2i hello\</span></span><br><span class="line"><span class="string">world'</span> file <span class="comment">#在第二行前插入两行数据(hello\nworld)</span></span><br><span class="line">sed <span class="string">'2c no such p'</span> file</span><br><span class="line">sed -i <span class="string">'4s/99/55/g'</span> file     <span class="comment">#把第4行的99改为55</span></span><br><span class="line">sed -e <span class="string">'s/lp//g;s/fyd//g'</span> file <span class="comment">#同时吧"lp"和"fyd"替换为空</span></span><br></pre></td></tr></table></figure><h3 id="字符处理命令"><a href="#字符处理命令" class="headerlink" title="字符处理命令"></a>字符处理命令</h3><ul><li><p>排序命令sort</p><ul><li><p>-f  忽略大小写</p></li><li><p>-n  以数值型进行排序，默认用字符串排序</p></li><li><p>-r   反向排序</p></li><li><p>-t    指定分隔符，默认是制表符</p></li><li><p>-k n[,m] 按照执行的字段范围排序。从第n字段开始，m字段结束（默认到行尾）</p></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort -n -t <span class="string">":"</span> -k 3,3 /etc/passwd <span class="comment">#用:分割后第三个字段按数值大小排序</span></span><br></pre></td></tr></table></figure><ul><li><p>统计命令wc</p><ul><li><p>-l   只统计行数</p></li><li><p>-w 只统计单词数</p></li><li><p>-m 只统计字符数</p></li></ul></li></ul><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><ul><li>符号<code>[]</code></li></ul><ol><li>按照文件类型进行判断</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-d  <span class="comment">#判断该文件是否存在，并且是否为目录</span></span><br><span class="line">-e  <span class="comment">#判断该文件是否存在</span></span><br><span class="line">-f  <span class="comment">#判断该文件是否存在，并且是否为普通文件</span></span><br><span class="line"><span class="built_in">test</span> -e file</span><br><span class="line">[ -e file ]   <span class="comment">#两种方式等价  echo $?判断</span></span><br><span class="line">[ -d file ] &amp;&amp; <span class="built_in">echo</span> <span class="string">'yes'</span> || <span class="built_in">echo</span> <span class="string">"no"</span>  <span class="comment">#不用手工判断</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>判断文件权限</p><ul><li>-r</li><li>-w</li><li>-x</li></ul></li><li><p>两个文件之间进行比较</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">文件1 -nt 文件2 <span class="comment">#判断文件1修改时间是否比文件2新</span></span><br><span class="line">-ot <span class="comment">#比谁旧</span></span><br><span class="line">-ef <span class="comment">#判断Inode号一致，两个文件是否为同一个文件。用于判断硬链接(Inode号一致)</span></span><br></pre></td></tr></table></figure><ol start="4"><li>两个整数之间比较</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-eq=</span><br><span class="line">-ne!=</span><br><span class="line">-gt&gt;</span><br><span class="line">-lt&lt;</span><br><span class="line">-ge&gt;=</span><br><span class="line">-le   &lt;=</span><br></pre></td></tr></table></figure><ol start="5"><li>字符串判断</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-z<span class="comment">#判断字符串是否为空</span></span><br><span class="line">-n<span class="comment">#非空</span></span><br><span class="line">==</span><br><span class="line">!=</span><br></pre></td></tr></table></figure><ol start="6"><li>多重条件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">判断1 -a 判断2<span class="comment">#与</span></span><br><span class="line">-o<span class="comment">#或</span></span><br><span class="line">!<span class="comment">#非</span></span><br></pre></td></tr></table></figure><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 条件判断 ];<span class="keyword">then</span></span><br><span class="line">code</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">或者</span><br><span class="line"><span class="keyword">if</span> [ 条件判断 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">code</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#双分支</span></span><br><span class="line"><span class="keyword">if</span> [ 条件判断 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">success</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    fail</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#多分支</span></span><br><span class="line"><span class="keyword">if</span> [ 条件1 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="keyword">elif</span> [ 条件2 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ul><li><p>案例1 备份</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">date=$(date +\%y\%m\%d) <span class="comment">#百分号必须转义，不然在定时任务中会到其内定含义</span></span><br><span class="line">size=$(du -sh 需要备份的文件夹)</span><br><span class="line"><span class="keyword">if</span> [ -d /tmp/backup ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Date : <span class="variable">$date</span>!"</span> &gt; /tmp/backup/info.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Data size: <span class="variable">$size</span>"</span> &gt;&gt; /tmp/backup/info.txt</span><br><span class="line"><span class="built_in">cd</span> /tmp/backup</span><br><span class="line">tar -zcf  backupDB_<span class="variable">$date</span>.tar.gz  /etc /tmp/backup/info.txt &amp;&gt;/dev/null</span><br><span class="line">rm -rf /tmp/backup/info.txt</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    mkdir /tmp/backup</span><br><span class="line">    同上</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li><li><p>案例2 判断用户输入 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"please input a filename:"</span> -t 3 file <span class="comment">#3s内输入</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$file</span>"</span> ] <span class="comment">#空</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"error, null"</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">elif</span> [ ! -e <span class="string">"<span class="variable">$file</span>"</span> ] <span class="comment">#是否存在</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"file not exist"</span></span><br><span class="line"><span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">elif</span> [ -d <span class="string">"<span class="variable">$file</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"file is a directory"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="case"><a href="#case" class="headerlink" title="case"></a>case</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> $变量名 <span class="keyword">in</span></span><br><span class="line"><span class="string">"值1"</span>)</span><br><span class="line">;;</span><br><span class="line"><span class="string">"值2"</span>)</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><ul><li><p>格式1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量名 <span class="keyword">in</span> 值1 值2 值3...</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">$变量名</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ul><li>案例：批量解压缩</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/lp</span><br><span class="line">ls *.tar.gz &gt; ls.log</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(cat ls.log)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">tar -zxf <span class="variable">$i</span> &amp;&gt;/dev/null</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">rm -rf ~/lp/ls.log</span><br></pre></td></tr></table></figure></li><li><p>格式2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>((初始;条件;))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="comment">#todo:</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="while和until"><a href="#while和until" class="headerlink" title="while和until"></a>while和until</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ 条件 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="comment">#todo:</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">until [ 条件 ]  <span class="comment">#到条件退出循环</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="comment">#todo:</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><h4 id="crontab设置"><a href="#crontab设置" class="headerlink" title="crontab设置"></a>crontab设置</h4><ul><li><p>前提：crond服务默认自启动</p></li><li><p>用法</p><ul><li>-e         编辑定时任务</li><li>-l              查询任务</li><li>-r              删除当前用户所有的任务</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line"><span class="comment">#进入vim编辑工作</span></span><br><span class="line">* * * * * 执行的任务</span><br><span class="line">一小时当中第几分   0-59</span><br><span class="line">一天中第几小时   0-23</span><br><span class="line">一月中第几天    1-31</span><br><span class="line">一年中第几月1-12</span><br><span class="line">一周中星期几0-7(0、7都代表星期日)</span><br><span class="line">* 任何时间</span><br><span class="line">，不连续时间  0 8,12,16 * * * <span class="comment">#每天8、12、16时</span></span><br><span class="line">- 连续时间</span><br><span class="line">*/n每隔多久</span><br></pre></td></tr></table></figure></li></ul><h3 id="单机备份"><a href="#单机备份" class="headerlink" title="单机备份"></a>单机备份</h3><ul><li><p>前提</p><ul><li><code>yum -y install dump</code></li></ul></li><li><p>备份目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dump -oj -f ~/myBakup.dump.bz2  待备份的目录</span><br><span class="line"><span class="comment">#目录只能用0级别完全备份</span></span><br><span class="line"></span><br><span class="line">cat /etc/dumpdatas <span class="comment">#查看备份时间文件</span></span><br></pre></td></tr></table></figure></li><li><p>恢复</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restore -r -f ~/myBakup.dump.bz2  <span class="comment">#恢复到当前目录</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mood</title>
      <link href="/2018/11/26/mood/"/>
      <url>/2018/11/26/mood/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p>最 近 2周 忙 于 英 语 口 语 考 和 机 考😓 <br>也 就 没 更 新 了, 哎 ~! <br>英 语 还 是 蛮 重 要, 终 生 学 习 </p></blockquote>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Java学习(6)</title>
      <link href="/2018/11/25/Java%E5%AD%A6%E4%B9%A06/"/>
      <url>/2018/11/25/Java%E5%AD%A6%E4%B9%A06/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p>反射、枚举、JDK新特性</p></blockquote><p><img src="https://image-link.nos-eastchina1.126.net/java_06"> </p><a id="more"></a><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><ul><li><p>概述</p><ul><li>当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。</li><li>加载 <ul><li>就是指将class文件读入内存，并为之创建一个Class对象。任何类被使用时系统都会建立一个Class对象。</li></ul></li><li>连接<ul><li>验证 是否有正确的内部结构，并和其他类协调一致</li><li>准备 负责为类的静态成员分配内存，并设置默认初始化值</li><li>解析 将类的二进制数据中的符号引用替换为直接引用</li></ul></li><li>初始化 就是我们之前讲过的初始化步骤</li></ul></li><li><p>加载时机</p><ul><li>创建类的实例</li><li>访问类的静态变量，或者为静态变量赋值</li><li>调用类的静态方法</li><li>使用反射方式来强制创建某个类或接口对应的java.lang.Class对象</li><li>初始化某个类的子类</li><li>直接使用java.exe命令来运行某个主类</li></ul></li></ul><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul><li><p>概述</p><ul><li>负责将.class文件加载到内存中，并为之生成对应的<code>Class</code>对象。虽然我们不需要关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行。</li></ul></li><li><p>分类</p><ul><li>Bootstrap ClassLoader 根类加载器</li><li>Extension ClassLoader 扩展类加载器</li><li>Sysetm ClassLoader 系统类加载器</li></ul></li><li><p>作用</p><ul><li>Bootstrap ClassLoader 根类加载器<ul><li>也被称为引导类加载器，负责Java核心类的加载</li><li>比如<code>System</code>,<code>String</code>等。在JDK中JRE的lib目录下rt.jar文件中</li></ul></li><li>Extension ClassLoader 扩展类加载器<ul><li>负责JRE的扩展目录中jar包的加载。</li><li>在JDK中JRE的lib目录下ext目录</li></ul></li><li>Sysetm ClassLoader 系统类加载器<ul><li>负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径</li></ul></li></ul></li></ul><h3 id="反射概述"><a href="#反射概述" class="headerlink" title="反射概述"></a>反射概述</h3><ul><li><p>反射概述</p><ul><li>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；</li><li>对于任意一个对象，都能够调用它的任意一个方法和属性；</li><li>这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</li><li>要想解剖一个类,必须先要获取到该类的字节码文件对象。</li><li>而解剖使用的就是<code>Class</code>类中的方法，所以先要获取到每一个字节码文件对应的<code>Class</code>类型的对象。</li></ul></li><li><p>获取字节码对象三种方式</p><ul><li>a:<code>Object</code>类的<code>getClass()</code>方法,判断两个对象是否是同一个字节码文件</li><li>b:静态属性class,锁对象</li><li>c:<code>Class</code>类中静态方法<code>forName()</code>,读取配置文件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"类名"</span>); <span class="comment">//读配置文件</span></span><br><span class="line">= Person.class; <span class="comment">//当静态方法的锁对象</span></span><br><span class="line">= <span class="keyword">new</span> Person().getClass() <span class="comment">//判断是否是同个字节码对象</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="反射作用"><a href="#反射作用" class="headerlink" title="反射作用"></a>反射作用</h3><ol><li>读取配置文件</li></ol><ul><li><p>实现动态加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"config.properties"</span>));</span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(br.readLine());<span class="comment">//读取配置文件一行内容,获取该类的字节码对象</span></span><br><span class="line">Fruit f = (Fruit) clazz.newInstance();<span class="comment">//通过字节码对象创建实例对象</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><p>获取构造函数</p><ul><li><p>无参</p><ul><li><code>clazz.newInstance();</code>   字节码对象创建实例默认调用无参构造</li></ul></li><li><p>有参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor c = clazz.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">Person p = (Person) c.newInstance(<span class="string">'lp'</span>, <span class="number">24</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>获取成员变量和方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取成员变量</span></span><br><span class="line"><span class="comment">//Filed f = clazz.getFiled("name");直接获取不行，name私有的话</span></span><br><span class="line">Filed f = clazz.getDeclaredField(<span class="string">"name"</span>); <span class="comment">//强制获取</span></span><br><span class="line">f.setAccessible(<span class="keyword">true</span>); <span class="comment">//去除私有权限</span></span><br><span class="line">f.set(p, <span class="string">"fyd"</span>);</span><br><span class="line"><span class="comment">//获取方法</span></span><br><span class="line">Method m = clazz.getMethod(<span class="string">"方法名"</span>);<span class="comment">//无参方法</span></span><br><span class="line">m.invoke(p);</span><br><span class="line">Method m = clazz.getMethod(<span class="string">"方法名"</span>, <span class="keyword">int</span>.class); <span class="comment">//带参方法</span></span><br><span class="line">m.invoke(p);</span><br></pre></td></tr></table></figure></li><li><p>越过泛型检查</p><ul><li>在<code>ArrayList&lt;Integer&gt;</code>的一个对象中如何添加一个字符串？<ul><li>泛型只在编译时有效，运行时被擦除</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">111</span>);</span><br><span class="line">Class clazz = Class.forName(<span class="string">"java.util.ArrayList"</span>);</span><br><span class="line">Method m = clazz.getMethod(<span class="string">"add"</span>, Object.class);</span><br><span class="line">m.invoke(list, <span class="string">"fyd"</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><ul><li>概述<ul><li>通过反射来生成一个代理</li><li>在Java中java.lang.reflect包下提供了一个<code>Proxy</code>类和一个<code>InvocationHandler</code>接口，通过使用这个类和接口就可以生成动态代理对象。JDK提供的代理只能针对<strong>接口</strong>做代理。我们有更强大的代理cglib，Proxy类中的方法创建动态代理类对象</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,Class&lt;?&gt;[]interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">InvocationHandler h)</span></span></span><br><span class="line"><span class="function"><span class="comment">//1.接口</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> interface User </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserImp</span> <span class="keyword">implements</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//System.out.println("权限校验");</span></span><br><span class="line">System.out.println(<span class="string">"添加功能"</span>);</span><br><span class="line"><span class="comment">//System.out.println("日志记录");</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//System.out.println("权限校验");</span></span><br><span class="line">System.out.println(<span class="string">"删除功能"</span>);</span><br><span class="line"><span class="comment">//System.out.println("日志记录");</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.实现代理逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.target = target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"权限校验"</span>);</span><br><span class="line">method.invoke(target, args);<span class="comment">//执行被代理target对象的方法</span></span><br><span class="line">System.out.println(<span class="string">"日志记录"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.最终使用代理</span></span><br><span class="line">MyInvocationHandler m = <span class="keyword">new</span> MyInvocationHandler(ui);</span><br><span class="line">User u = (User)Proxy.newProxyInstance(ui.getClass().getClassLoader(), ui.getClass().getInterfaces(), m);<span class="comment">//生成代理，只能是接口方法哦</span></span><br><span class="line">u.add();</span><br><span class="line">u.delete();</span><br></pre></td></tr></table></figure><h2 id="1-5"><a href="#1-5" class="headerlink" title="1.5"></a>1.5</h2><ul><li>枚举概述<ul><li>是指将变量的值一一列出来,变量的值只限于列举出来的值的范围内。举例：一周只有7天，一年只有12个月等。（单例设计模式的衍生）</li></ul></li></ul><h3 id="枚举自定义"><a href="#枚举自定义" class="headerlink" title="枚举自定义"></a>枚举自定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Week &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> finnal Week MON = <span class="keyword">new</span> Week(<span class="string">"Monday"</span>);</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Week</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name= name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Week2 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> finnal Week2 MON = <span class="keyword">new</span> Week(<span class="string">"Monday"</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"星期一"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Week2</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name= name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//不能通过子类继承的方法来创建，因为这里构造函数私有化了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Week &#123;</span><br><span class="line">    <span class="comment">//MON, TUE, WED; (默认用空参构造创建)  直接打印就是名字MON，无论构造</span></span><br><span class="line">    MON(<span class="string">"星期一"</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"星期一"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,TUE(<span class="string">"星期二"</span>),WED(<span class="string">"星期三"</span>);</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Week</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举常用方法"><a href="#枚举常用方法" class="headerlink" title="枚举常用方法"></a>枚举常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ordinal</span><span class="params">()</span> <span class="comment">//返回枚举常量序数，初始为0</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(E o)</span></span></span><br><span class="line"><span class="function">String <span class="title">name</span><span class="params">()</span> <span class="comment">//获取实例名称</span></span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span> <span class="comment">//不重写，默认就是调用name()</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">valueOf</span><span class="params">(Class&lt;T&gt; type,String name)</span></span>;<span class="comment">//通过字节码文件获取</span></span><br><span class="line">    - Week mon = Week.valueOf(Week.class, <span class="string">"MON"</span>);</span><br><span class="line">T[] values(); <span class="comment">//遍历枚举类</span></span><br><span class="line">    - Week[] arr = Week.values();</span><br></pre></td></tr></table></figure><h2 id="1-7"><a href="#1-7" class="headerlink" title="1.7"></a>1.7</h2><ul><li>二进制字面量: <code>0b110</code></li><li>数字字面量可以出现下划线 100_000_000</li><li><code>switch</code> 语句可以用字符串</li><li>泛型简化,菱形泛型</li><li>异常的多个<code>catch</code>合并,每个异常用或|</li><li><code>try-with-resources</code> 语句(自动关流，需要实现<code>close()</code>方法)</li></ul><h2 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h2><h3 id="新接口特性"><a href="#新接口特性" class="headerlink" title="新接口特性"></a>新接口特性</h3><ul><li>接口中可以定义有方法体的方法,如果是非静态,必须用<code>default</code>修饰    </li><li>如果是静态的就不用了</li></ul><h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><ul><li>函数式编程，类似es6里面的箭头函数的风格</li></ul><ol><li><p>为什么要引入？</p><p>​    解决代码冗余的问题，比如创建线程的时候，传入的<code>Runnable</code>匿名内部类对象，最关心的其实只是<code>run（）</code>方法里面方法体的作用，而非其余那些条条框框。在比如排序时，需要传入的比较器，也一样，匿名对象其实只用一次，而最核心的也只是方法体，而非语法限制框架。故而引入</p></li><li><p>Lambda用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程案例</span></span><br><span class="line"><span class="keyword">new</span> Thread(() ‐&gt; System.out.println(<span class="string">"多线程任务执行！"</span>)).start(); <span class="comment">// 启动线程 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义对象数组排序案例</span></span><br><span class="line">Person[]  array = &#123;p1, p2, p3, p4&#125;;</span><br><span class="line">Arrays.sort(array, (Person a, Person b) ‐&gt; &#123; <span class="keyword">return</span> a.getAge() ‐ b.getAge(); &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通接口案例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        invokeCalc(<span class="number">120</span>, <span class="number">130</span>, (a, b) ‐&gt; a + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeCalc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Calculator calculator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = calculator.calc(a, b); </span><br><span class="line">        System.out.println(<span class="string">"结果是："</span> + result); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意事项</p></li></ol><ul><li><p>使用Lambda必须具有<strong>接口</strong>，且要求接口中有且<strong>仅有一个</strong>抽象方法。 无论是JDK内置的 <code>Runnable</code> 、 <code>Comparator</code>接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。</p></li><li><p>使用Lambda必须具有上下文推断。 也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</p></li></ul><blockquote><p>有且仅有一个抽象方法的接口，称为“函数式接口”。</p></blockquote><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><ol><li><p>为什么要引入？</p><p>​    解决Lambda冗余的场景，何谓冗余？就是如果Lambda中的的方法体，如果别的地方已经实现了，那就不需要重新写方法体（方法体内部也不过是调用别的函数的方法体），所以直接引用过来就行。</p></li><li><p>方法引用</p><p>基本用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Printable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printString</span><span class="params">(Printable data)</span> </span>&#123; </span><br><span class="line">    data.print(<span class="string">"Hello, World!"</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">调用时传入方法引用</span><br><span class="line">printString(System.out::println);</span><br></pre></td></tr></table></figure><ul><li>对象名引用成员方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodRefObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printUpperCase</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(str.toUpperCase()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printString</span><span class="params">(Printable lambda)</span> </span>&#123;</span><br><span class="line">        lambda.print(<span class="string">"Hello"</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        MethodRefObject obj = <span class="keyword">new</span> MethodRefObject();</span><br><span class="line">        printString(obj::printUpperCase); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Lambda表达式： str -&gt; obj.printUpperCase(str)</span></span><br><span class="line">    <span class="comment">//方法引用： obj::printUpperCase</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类名引用静态方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06MethodRef</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> num, Calcable lambda)</span> </span>&#123; </span><br><span class="line">        System.out.println(lambda.calc(num));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        method(‐<span class="number">10</span>, Math::abs); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Lambda表达式： n -&gt; Math.abs(n) </span></span><br><span class="line">    <span class="comment">//方法引用： Math::abs</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>super</code>引用成员方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Greetable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Greetable lambda)</span> </span>&#123;</span><br><span class="line">        lambda.greet(); </span><br><span class="line">        System.out.println(<span class="string">"I'm a woman!"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        method(<span class="keyword">super</span>::sayHello); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Lambda表达式： () -&gt; super.sayHello()</span></span><br><span class="line">    <span class="comment">//方法引用： super::sayHello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>this</code>引用成员方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Richable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Husband</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">marry</span><span class="params">(Richable lambda)</span> </span>&#123; lambda.buy(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buyHouse</span><span class="params">()</span> </span>&#123;System.out.println(<span class="string">"买套房子"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beHappy</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        marry(<span class="keyword">this</span>::buyHouse); </span><br><span class="line">    &#125; </span><br><span class="line">   <span class="comment">//Lambda 表达式： () -&gt; this.buyHouse() </span></span><br><span class="line">   <span class="comment">//方法引用： this::buyHouse</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类构造器引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonBuilder</span> </span>&#123; </span><br><span class="line">    <span class="function">Person <span class="title">buildPerson</span><span class="params">(String name)</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">(String name, PersonBuilder builder)</span></span>&#123; </span><br><span class="line">        System.out.println(builder.buildPerson(name).getName());</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        printName(<span class="string">"lp"</span>, Person::<span class="keyword">new</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Lambda 表达式： name -&gt; new Person(name) </span></span><br><span class="line">    <span class="comment">//方法引用： Person::new</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数组的构造器引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ArrayBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] buildArray(<span class="keyword">int</span> length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] initArray(<span class="keyword">int</span> length, ArrayBuilder builder) &#123;</span><br><span class="line">        <span class="keyword">return</span> builder.buildArray(length); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">int</span>[] array = initArray(<span class="number">10</span>, <span class="keyword">int</span>[]::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Lambda 表达式： length -&gt; new int[length] </span></span><br><span class="line">    <span class="comment">//方法引用： int[]::new</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以和Java 8的Stream API结合，在一定程度上“解决”集合中 toArray 方法的泛 型擦除问题。</p></blockquote></li></ol><h4 id="常用函数式接口"><a href="#常用函数式接口" class="headerlink" title="常用函数式接口"></a>常用函数式接口</h4><ol><li><p>Supplier接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123; <span class="function">T <span class="title">get</span><span class="params">()</span></span>;&#125;</span><br><span class="line"><span class="comment">//获取一个泛型参数指定类型的对象数据</span></span><br></pre></td></tr></table></figure></li><li><p>Consumer接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;<span class="comment">//消费一个指定泛型的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123; </span><br><span class="line">        Objects.requireNonNull(after); </span><br><span class="line">        <span class="keyword">return</span> (T t) ‐&gt; &#123; accept(t); after.accept(t); &#125;; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>备注：</p><p> java.util.Objects 的 requireNonNull 静态方法将会在参数为null时主动抛出 NullPointerException 异常。这省去了重复编写if语句和抛出空指针异常的麻烦。</p></blockquote><pre><code>如果一个方法的参数和返回值全都是 Consumer 类型，那么就可以实现效果：消费一个数据的时候，首先做一个操 作，然后再做一个操作，实现组合。</code></pre><p>​    要想实现组合，需要两个或多个Lambda表达式即可，而 andThen 的语义正是“一步接一步”操作。例如两个步骤组合的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumeString</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Consumer&lt;String&gt; one, Consumer&lt;String&gt; two)</span> </span>&#123; </span><br><span class="line">        one.andThen(two).accept(<span class="string">"Hello"</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        consumeString(</span><br><span class="line">            s ‐&gt; System.out.println(s.toUpperCase()), </span><br><span class="line">            s ‐&gt; System.out.println(s.toLowerCase())</span><br><span class="line">        ); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Predicate接口</p><ul><li><p>用处</p><ul><li>判断逻辑</li></ul></li><li><p>抽象方法<code>boolean test(T t)</code></p></li><li><p>默认方法</p><ul><li><p>and(与)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(other); </span><br><span class="line">    <span class="keyword">return</span> (t) ‐&gt; test(t) &amp;&amp; other.test(t); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用</p><p><code>one.and(two).test(&quot;Helloworld&quot;);</code></p></li><li><p>or(或)</p><p><code>one.or(two).test(&quot;Helloworld&quot;);</code></p></li><li><p>negate(非)</p><p><code>predicate.negate().test(&quot;HelloWorld&quot;);</code></p></li></ul></li></ul></li><li><p>Function接口</p><ul><li><p>定义</p><ul><li>用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。有进有出，所以称为“函数Function”。</li></ul></li><li><p>抽象方法：<code>R apply(T t)</code></p><ul><li>根据类型T的参数获取类型R的结果。使用的场景例如： 将 String 类型转换为 Integer 类型。</li></ul></li><li><p>默认方法</p><ul><li>andThen</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123; </span><br><span class="line">    Objects.requireNonNull(after); </span><br><span class="line">    <span class="keyword">return</span> (T t) ‐&gt; after.apply(apply(t)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>compose    和上面的类似，调用顺序区别</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;V, R&gt; <span class="title">compose</span><span class="params">(Function&lt;? <span class="keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123; </span><br><span class="line">    Objects.requireNonNull(before);</span><br><span class="line">    <span class="keyword">return</span> (V v) ‐&gt; apply(before.apply(v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><blockquote><p>总结：</p></blockquote><ul><li>常用函数式接口当中，方法可以分成两种：<ul><li>延迟方法 ：只是在拼接Lambda函数模型的方法，并不立即执行得到结果。</li><li>终结方法 ：根据拼好的Lambda函数模型，立即执行得到结果值的方法。</li></ul></li></ul><h3 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h3><ul><li><p>为啥引入？</p><ul><li><p>很多工作需要遍历集合，处理后再遍历，再处理在遍历。这样会导致出现很多for循环，而Java 8的<code>Lambda</code>让我们可以更加专注于做什么（What），而不是怎么做（How），那就需要引入新的思想，专注于做，而非使用的语法条条框框。</p></li><li><p>案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">list.add(<span class="string">"lp"</span>); </span><br><span class="line">list.add(<span class="string">"zju"</span>); </span><br><span class="line">list.add(<span class="string">"fyd"</span>);  </span><br><span class="line">list.add(<span class="string">"final"</span>);</span><br><span class="line"></span><br><span class="line">list.stream().filter(s ‐&gt; s.startsWith(<span class="string">"f"</span>)) </span><br><span class="line">    .filter(s ‐&gt; s.length() == <span class="number">3</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"><span class="comment">//很优雅的写法，不用1.8之前，多次循环遍历</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="获取流"><a href="#获取流" class="headerlink" title="获取流"></a>获取流</h4><ul><li><p>根据<code>Collection</code>获取</p><p>​     <code>java.util.Collection</code> 接口中加入了default方法 <code>stream()</code> 用来获取流，所以其所有实现类均可获取流。</p></li><li><p>根据<code>Map</code>获取</p><p>​    <code>java.util.Map</code> 接口不是 <code>Collection</code> 的子接口，且其K-V数据结构不符合流元素的单一特征，所以获取对应的流 需要分key、value或entry等情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Stream&lt;String&gt; keyStream = map.keySet().stream(); </span><br><span class="line">Stream&lt;String&gt; valueStream = map.values().stream();</span><br><span class="line">Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream = map.entrySet().stream();</span><br></pre></td></tr></table></figure></li><li><p>根据数组获取流</p><p>由于数组对象不可能添加默认方法，所以 <code>Stream</code> 接口中提供了静态方法 <code>of</code>，使用很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] array = &#123; <span class="string">"lp"</span>, <span class="string">"fyd"</span> &#125;; </span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(array);</span><br></pre></td></tr></table></figure><blockquote><p>备注： of 方法的参数其实是一个可变参数，所以支持数组。</p></blockquote></li></ul><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li>终结方法<ul><li>返回值类型不再是 <code>Stream</code> 接口自身类型的方法，因此不再支持链式调用。终结方法包括 <code>count</code> 和<code>forEach</code>方法。</li></ul></li><li>非终结方法<ul><li>返回值类型仍然是<code>Stream</code> 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方法均为非终结方法。）</li></ul></li></ul><ol><li><p>过滤：<code>filter</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>统计个数：count</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">处理后流对象.count();</span><br></pre></td></tr></table></figure></li><li><p>取用前几个：limit</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">limit</span><span class="params">(<span class="keyword">long</span> maxSize)</span></span>;</span><br><span class="line"><span class="comment">//如果集合当前长度大于参数则进行截取；否则不进行操作。</span></span><br></pre></td></tr></table></figure></li><li><p>跳过前几个：skip</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span></span>;</span><br><span class="line"><span class="comment">//如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>映射：<code>Map</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>组合：<code>concat</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">concat</span><span class="params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span></span></span><br></pre></td></tr></table></figure><p>如果有两个流，希望合并成为一个流，那么可以使用 <code>Stream</code>接口的静态方法<code>concat</code></p></li><li><p>逐个处理：<code>forEach</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br></pre></td></tr></table></figure></li></ol><h4 id="并发流"><a href="#并发流" class="headerlink" title="并发流"></a>并发流</h4><ul><li><p>引入</p><ul><li>当需要对存在于集合或数组中的若干元素进行并发操作时，简直就是噩梦！我们需要仔细考虑多线程环境下的原子性、竞争甚至锁问题。</li><li>即便是 <code>java.util.concurrent.ConcurrentMap&lt;K, V&gt;</code> 接口也必须谨慎地正确使用。 而对于Stream流来说，这很简单。</li></ul></li><li><p>转换为并发流</p><ul><li><code>Stream</code>的父接口 <code>java.util.stream.BaseStream</code> 中定义了一个<code>S parallel()</code> 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>).parallel();</span><br></pre></td></tr></table></figure></li><li><p>直接获取并发流</p><p>在通过集合获取流时，也可以直接调用 <code>parallelStream</code>方法来直接获取支持并发操作的流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">parallelStream</span><span class="params">()</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="收集流"><a href="#收集流" class="headerlink" title="收集流"></a>收集流</h4><ul><li><p>引入</p><ul><li>对流操作完成之后，如果需要将其结果进行收集，例如获取对应的集合、数组等，如何操作？</li></ul></li><li><p>收集到集合中</p><ul><li><code>Stream</code>流提供 <code>collect</code> 方法，其参数需要一个<code>java.util.stream.Collector&lt;T,A, R&gt;</code> 接口对象来指定收集到哪种集合中。幸运的是，<code>java.util.stream.Collectors</code> 类提供一些方法，可以作为 <code>Collector</code> 接口的实例：<ul><li><code>public static &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList()</code>：转换为 List 集合。 </li><li><code>public static &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet()</code>：转换为 Set 集合。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"10"</span>, <span class="string">"20"</span>, <span class="string">"30"</span>, <span class="string">"40"</span>, <span class="string">"50"</span>);</span><br><span class="line">List&lt;String&gt; list = stream.collect(Collectors.toList());</span><br><span class="line">Set&lt;String&gt; set = stream.collect(Collectors.toSet());</span><br></pre></td></tr></table></figure></li><li><p>收集到数组中</p><ul><li><code>Stream</code>提供 <code>toArray</code>方法来将结果放到一个数组中，由于泛型擦除的原因，返回值类型是<code>Object[] toArray();</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"10"</span>, <span class="string">"20"</span>, <span class="string">"30"</span>, <span class="string">"40"</span>, <span class="string">"50"</span>); </span><br><span class="line">Object[] objArray = stream.toArray();</span><br></pre></td></tr></table></figure><ul><li><p>有了Lambda和方法引用之后，可以使用 <code>toArray</code> 方法的另一种<strong>重载</strong>形式传递一个 <code>IntFunction&lt;A[]&gt;</code>的函数， 而从外面指定泛型参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);</span><br></pre></td></tr></table></figure><p>有了它，上例代码中不再局限于 <code>Object[]</code>结果，而可以得到 <code>String[]</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"10"</span>, <span class="string">"20"</span>, <span class="string">"30"</span>, <span class="string">"40"</span>, <span class="string">"50"</span>); String[] strArray = stream.toArray(String[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 反射 </tag>
            
            <tag> JDK 新特性 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java学习(5)</title>
      <link href="/2018/11/18/Java%E5%AD%A6%E4%B9%A05/"/>
      <url>/2018/11/18/Java%E5%AD%A6%E4%B9%A05/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p>多线程、设计模式、网络编程</p></blockquote><p><img src="https://image-link.nos-eastchina1.126.net/java_05"> </p><a id="more"></a><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul><li>进程和线程</li><li>并行与并发</li><li><code>Java</code>程序运行原理和<code>JVM</code>启动<ul><li><code>Java</code>命令会启动<code>java</code>虚拟机，启动<code>JVM</code>，等于启动了一个应用程序，也就是启动了一个进程。该进程会<strong>自动</strong>启动一个 “主线程” ，然后主线程去调用某个类的<code>main</code> 方法。</li><li><code>JVM</code>启动至少启动了垃圾回收线程和主线程，所以是多线程的。</li></ul></li></ul><h3 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h3><ul><li>继承Thread</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;<span class="comment">//1,定义类继承Thread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//2,重写run方法</span></span><br><span class="line">线程需要执行的内容  <span class="comment">//3,将要执行的代码,写在run方法中</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MyThread mt = <span class="keyword">new</span> MyThread();<span class="comment">//4,创建自定义类的对象</span></span><br><span class="line">mt.start();<span class="comment">//5,开启线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现<code>Runnable</code>接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;<span class="comment">//1,自定义类实现Runnable接口</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//2,重写run方法</span></span><br><span class="line">线程需要执行的内容     <span class="comment">//3,将要执行的代码,写在run方法中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MyRunnable mr = <span class="keyword">new</span> MyRunnable();<span class="comment">//4,创建自定义类对象</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(mr);    <span class="comment">//5,将其当作参数传递给Thread的构造函数</span></span><br><span class="line">t.start();<span class="comment">//6,开启线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：run()中异常不能抛，因为父类没抛，只能解决</p></blockquote><h4 id="两种方法区别"><a href="#两种方法区别" class="headerlink" title="两种方法区别"></a>两种方法区别</h4><ul><li>实现的原理<ul><li>第一种是，<code>Thread</code>是实现了<code>Runnable</code>接口，然后重写了<code>run()</code></li><li>第二种是，<code>Runnble</code>对象作为参数传递给<code>Thread</code>的成员变量<code>target</code>，多态实现<code>run()</code></li></ul></li><li>优缺点<ul><li>继承<code>Thread</code><ul><li>优点：可以直接使用<code>Thread</code>类中的方法,代码简单</li><li>弊端：如果已经有了父类,就不能用这种方法</li></ul></li><li>实现<code>Runnable</code><ul><li>优点：即使自己定义的线程类有了父类也没关系,因为有了父类也可以实现接口,而且接口是可以多实现的</li><li>弊端：不能直接使用<code>Thread</code>中的方法需要先获取到线程对象<code>Thread.currentThread()</code>后,才能得到<code>Thread</code>的方法,代码复杂</li></ul></li></ul></li></ul><h3 id="线程的五种状态"><a href="#线程的五种状态" class="headerlink" title="线程的五种状态"></a>线程的五种状态</h3><p><img src="https://image-link.nos-eastchina1.126.net/thread%20state"></p><h3 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h3><ul><li><code>getName()</code>：获取线程名字     名字可以通过<code>Thread()</code>构造函数传递</li><li><code>setName()</code>：设置线程名字</li><li><code>Thread.currentThread()</code>：获取当前线程对象，主线程也可</li></ul><h3 id="线程类型"><a href="#线程类型" class="headerlink" title="线程类型"></a>线程类型</h3><h4 id="休眠线程"><a href="#休眠线程" class="headerlink" title="休眠线程"></a>休眠线程</h4><ul><li><code>Thread.sleep(ms,ns)</code>：时间到会自动唤醒</li></ul><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><ul><li><code>setDaemon()</code>：设置一个线程为守护线程, 该线程不会单独执行, 当其他非守护线程都执行结束后, 自动退出</li></ul><h4 id="加入线程"><a href="#加入线程" class="headerlink" title="加入线程"></a>加入线程</h4><ul><li><code>join()</code>：当前线程暂停, 等待指定的线程执行结束后, 当前线程再继续（相当于插队）</li><li><code>join(int)</code>： 可以等待指定的毫秒之后继续</li></ul><h4 id="礼让线程"><a href="#礼让线程" class="headerlink" title="礼让线程"></a>礼让线程</h4><ul><li><code>Thread.yield()</code>让出cpu（效果不明显），因为礼让出，只是让当前线程为就绪态，还是有机会竞争到CPU运行</li></ul><h4 id="设置线程优先级"><a href="#设置线程优先级" class="headerlink" title="设置线程优先级"></a>设置线程优先级</h4><ul><li><code>setPriority()</code>：(1-10，默认5)，效果也一般，因为只是加大了竞争到CPU的概率</li></ul><h3 id="同步代码和锁"><a href="#同步代码和锁" class="headerlink" title="同步代码和锁"></a>同步代码和锁</h3><h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><ul><li>需求分析<ul><li>当多线程并发, 有多段代码同时执行时, 我们希望某一段代码执行的过程中CPU不要切换到其他线程工作. 这时就需要同步.</li><li>如果两段代码是同步的, 那么同一时间只能执行一段, 在一段代码没执行结束之前, 不会执行另外一段代码.</li></ul></li><li>实现<ul><li>使用<code>synchronized</code>关键字加上一个<strong>锁对象</strong>来定义一段代码, 这就叫同步代码块</li><li>多个同步代码块如果使用相同的锁对象, 那么他们就是同步的</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> </span>&#123;</span><br><span class="line">Object d = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(d)&#123;<span class="comment">//锁对象可以是任意对象,但是被锁的代码需要保证是同一把锁</span></span><br><span class="line">            System.out.print(<span class="string">"L"</span>);</span><br><span class="line">            System.out.print(<span class="string">"P"</span>);</span><br><span class="line">            System.out.print(<span class="string">"\r\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(d)&#123;</span><br><span class="line">System.out.print(<span class="string">"F"</span>);</span><br><span class="line">System.out.print(<span class="string">"Y"</span>);</span><br><span class="line">System.out.print(<span class="string">"D"</span>);</span><br><span class="line">System.out.print(<span class="string">"\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> </span>&#123;</span><br><span class="line">Object d = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">//非静态的同步方法的锁对象  this</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(d)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态同步方法的锁对象   字节码对象 Printer.class</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><ul><li>多线程并发修改同一数据<ul><li>建议用同步，因为在临界情况可能会有越界的可能（火车售票案例）</li></ul></li><li>两种方法实现售票<ul><li>继承<code>Thread</code>，需4个实例对象，故成员变量<code>tickets</code>需要设置为静态</li><li>实现<code>Runnable</code>，可传递同一个对象，故不用静态</li></ul></li><li>回顾以前说过的线程安全问题<ul><li><code>Vector</code>是线程安全的，<code>ArrayList</code>是线程不安全的</li><li><code>StringBuffer</code>是线程安全的,<code>StringBuilder</code>是线程不安全的</li><li><code>Hashtable</code>是线程安全的，<code>HashMap</code>是线程不安全的</li><li><code>Collections.synchroinzed(xxx)</code>，可以转换不安全为安全</li></ul></li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ul><li>多线程同步的时候, 如果同步代码嵌套, 使用相同锁, 就有可能出现死锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String s1 = <span class="string">"筷子左"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String s2 = <span class="string">"筷子右"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(s1) &#123;</span><br><span class="line">                    System.out.println(getName() + <span class="string">".拿到"</span>+s1+ <span class="string">"等待"</span> + s2);</span><br><span class="line">                    <span class="keyword">synchronized</span>(s2) &#123;</span><br><span class="line">                        System.out.println(getName() + <span class="string">".拿到"</span>+s2+ <span class="string">"开吃"</span>);</span><br><span class="line">&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();   <span class="comment">//会发生Thread0拿到s1,等待s2。Thread1拿到s2，等待s1。发生死锁</span></span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(s2) &#123;</span><br><span class="line">                    System.out.println(getName() + <span class="string">".拿到"</span>+s2+ <span class="string">"等待"</span> + s1);</span><br><span class="line">                    <span class="keyword">synchronized</span>(s1) &#123;</span><br><span class="line">                        System.out.println(getName() + <span class="string">".拿到"</span>+s1+ <span class="string">"开吃"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>用来代替<code>synchronized</code>，且功能更强大</p><ul><li>同步<ul><li>使用<code>ReentrantLock</code>类的<code>lock()</code>和<code>unlock()</code>方法进行同步</li></ul></li><li>通信<ul><li>使用<code>ReentrantLock</code>类的<code>newCondition()</code>方法可以获取<code>Condition</code>对象</li><li>需要等待的时候使用<code>Condition</code>的<code>await()</code>方法, 唤醒的时候用<code>signal()</code>方法</li><li>不同的线程使用不同的<code>Condition</code>, 这样就能区分唤醒的时候找哪个线程了</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer3</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> ReentrantLock r = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> Condition c1 = r.newCondition();</span><br><span class="line"><span class="keyword">private</span> Condition c2 = r.newCondition();</span><br><span class="line"><span class="keyword">private</span> Condition c3 = r.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">r.lock();<span class="comment">//获取锁</span></span><br><span class="line"><span class="keyword">if</span>(flag != <span class="number">1</span>) &#123;</span><br><span class="line">c1.await();</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(<span class="string">"第一段"</span>);</span><br><span class="line">System.out.print(<span class="string">"\r\n"</span>);</span><br><span class="line">flag = <span class="number">2</span>;</span><br><span class="line">c2.signal();</span><br><span class="line">r.unlock();<span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">r.lock();</span><br><span class="line"><span class="keyword">if</span>(flag != <span class="number">2</span>) &#123;</span><br><span class="line">c2.await();</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(<span class="string">"第二段"</span>);</span><br><span class="line">System.out.print(<span class="string">"\r\n"</span>);</span><br><span class="line">flag = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//this.notify();</span></span><br><span class="line">c3.signal();</span><br><span class="line">r.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">r.lock();</span><br><span class="line"><span class="keyword">if</span>(flag != <span class="number">3</span>) &#123;</span><br><span class="line">c3.await();</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(<span class="string">"第三段"</span>);</span><br><span class="line">        System.out.print(<span class="string">"\r\n"</span>);</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">c1.signal();</span><br><span class="line">r.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><h4 id="两个线程通信"><a href="#两个线程通信" class="headerlink" title="两个线程通信"></a>两个线程通信</h4><ul><li>什么时候需要通信<ul><li>多个线程并发执行时, 在默认情况下CPU是随机切换线程的</li><li>如果我们希望他们<strong>有规律</strong>的执行, 就可以使用通信, 例如每个线程执行一次打印</li></ul></li><li>怎么通信<ul><li>如果希望线程等待, 就调用<code>wait()</code></li><li>如果希望唤醒等待的线程, 就调用<code>notify()</code>;</li><li>这两个方法<strong>必须在同步代码中执行, 并且使用同步锁对象</strong>来调用</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"第一句"</span>);</span><br><span class="line">            flag = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">this</span>.notify();   <span class="comment">//随机唤醒单个等待线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag != <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"第二句"</span>);</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">this</span>.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三个及以上线程通信"><a href="#三个及以上线程通信" class="headerlink" title="三个及以上线程通信"></a>三个及以上线程通信</h4><ul><li>jdk1.5版本之前的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一段</span></span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span>(flag != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">this</span> <span class="title">wait</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flag = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">this</span>.notifyAll();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二段</span></span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span>(flag != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">this</span> <span class="title">wait</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flag = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">this</span>.notifyAll();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第三段</span></span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span>(flag != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">this</span> <span class="title">wait</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意的问题"><a href="#注意的问题" class="headerlink" title="注意的问题"></a>注意的问题</h4><ol><li>在同步代码块中，用哪个锁，就用哪个对象调用<code>wait()</code>方法</li><li>为什么<code>wait</code>方法和<code>notify</code>方法定义在<code>Object</code>中？<ul><li>因为锁对象可以任意，Object是所有类基类。</li></ul></li><li><code>sleep</code>方法和<code>wait</code>方法的区别？<ul><li>参数<ul><li><code>sleep(ms)</code>，必须传入参数，参数即时间，时间到自动醒来</li><li><code>wait()</code>可出传入参数，也可不传。传入参数就是在参数时间结束后等待，不传入直接等待</li></ul></li><li>锁<ul><li><code>sleep(ms)</code>方法在同步方法或同步代码块中，不释放锁</li><li><code>wait()</code>方法在同步方法或同步代码块中，释放锁</li></ul></li></ul></li></ol><h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><ul><li>概述<ul><li>Java中使用<code>ThreadGroup</code>来表示线程组，它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。</li><li>默认情况下，所有的线程都属于主线程组。<ul><li><code>public final ThreadGroup getThreadGroup()</code>：通过线程对象获取他所属于的组</li><li><code>public final String getName()</code>：通过线程组对象获取他组的名字</li></ul></li><li>我们也可以给线程设置分组<ul><li>1,<code>ThreadGroup(String name)</code>创建线程组对象并给其赋值名字</li><li>2,创建线程对象</li><li>3,<code>Thread(ThreadGroup?group, Runnable?target, String?name)</code></li><li>4,好处：设置整组的优先级或者守护线程</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ThreadGroup tg = <span class="keyword">new</span> ThreadGroup(<span class="string">"新线程组名"</span>); <span class="comment">//创建线程组</span></span><br><span class="line">MyRunnable mr = <span class="keyword">new</span> MyRunnable();  <span class="comment">//创建Runnable的子类对象</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(tg, mr, <span class="string">"线程1"</span>);     <span class="comment">//把新建线程放入线程组</span></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(tg, mr, <span class="string">"线程2"</span>);</span><br><span class="line">tg.setDaemon(<span class="keyword">true</span>);  <span class="comment">//一起操作</span></span><br></pre></td></tr></table></figure><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul><li><p>概述</p><p>​    程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的<strong>提高性能</strong>，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。在JDK5之前，我们必须手动实现自己的线程池，从JDK5开始，Java内置支持线程池</p></li><li><p>内置线程池使用</p><ul><li><p>JDK5新增了一个<code>Executors</code>工厂类来产生线程池，有如下几个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//这些方法的返回值是ExecutorService对象，该对象表示一个线程池，可以执行Runnable对象或者Callable对象代表的线程。它提供了如下方法</span></span></span><br><span class="line"><span class="function">Future&lt;?&gt; <span class="title">submit</span><span class="params">(Runnable task)</span></span></span><br><span class="line"><span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span></span><br></pre></td></tr></table></figure></li><li><p>使用步骤：</p><ul><li>创建线程池对象</li><li>创建<code>Runnable</code>实例</li><li>提交<code>Runnable</code>实例</li><li>关闭线程池</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">pool.submit(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">pool.submit(<span class="keyword">new</span> MyRunnable());</span><br><span class="line"><span class="comment">//结束线程池</span></span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Timer类"><a href="#Timer类" class="headerlink" title="Timer类"></a>Timer类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Timer t = <span class="keyword">new</span> Timer();</span><br><span class="line">t.schedule(<span class="keyword">new</span> MyTimerTask(), <span class="keyword">new</span> Date(<span class="number">118</span>,<span class="number">9</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">54</span>,<span class="number">20</span>),<span class="number">3000</span>);</span><br><span class="line">  <span class="comment">//安排指定任务           执行的时间           到时每过3s重复执行</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTimerTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"起床刷牙"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><ul><li>保证内存中<strong>只有一个</strong>对象</li><li>实现方法<ul><li>控制类的创建，不让其他类来创建本类的对象。<code>private</code>构造函数</li><li>在本类中定义一个本类的对象。<code>Singleton s</code>;</li><li>提供公共的访问方式。  <code>public static Singleton getInstance(){return s}</code></li></ul></li></ul><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1,私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//2,创建本类对象  私有是因为防止外部修改该对象为null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">//3,对外提供公共的访问方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"11111111111"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><p>单例的延迟加载模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1,私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//2,声明一个本类的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s;</span><br><span class="line">    <span class="comment">//3,对外提供公共的访问方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//线程1等待,线程2 有可能会创2个对象，开发不用</span></span><br><span class="line">            s = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>区别</p></blockquote><ol><li>饿汉式空间换时间，懒汉式时间换空间</li><li>多线程访问，饿汉式不会创多个对象，懒汉式会</li></ol><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><h5 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runtime r = Runtime.getRuntime(); <span class="comment">//获取与当前Java应用程序关联的运行时对象</span></span><br><span class="line">r.exec(<span class="string">"ls -l"</span>);</span><br></pre></td></tr></table></figure><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><ul><li>概述<ul><li>又叫静态工厂方法模式，它定义一个具体的工厂类负责创建一些类的实例</li></ul></li><li>优缺点<ul><li>好：客户端不需要在负责对象的创建，从而明确了各个类的职责。尤其是创建对象的工作如果比较麻烦的时候。</li><li>差：这个静态工厂类负责所有对象的创建，如果有新的对象增加，或者某些对象的创建方式不同，就需要不断的修改工厂类，不利于后期的维护</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AnimalFactory</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//public static Dog createDog() &#123;return new Dog();&#125;</span></span><br><span class="line"><span class="comment">//public static Cat createCat() &#123;return new Cat();&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//改进</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Animal <span class="title">createAnimal</span><span class="params">(String animalName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(“dog”.equals(animalName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(“cat”.equals(animale)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><ul><li><p>概述</p><p>​    工厂方法模式中，抽象工厂类负责定义创建对象的接口，具体对象的创建工作由继承抽象工厂的具体类实现。</p></li><li><p>优缺点</p><ul><li>客户端不需要在负责对象的创建，从而明确了各个类的职责，如果有新的对象增加，只需要增加一个具体的类和具体的工厂类即可，不影响已有的代码，后期维护容易，增强了系统的扩展性</li><li>需要额外的编写代码，增加了工作量</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> Animal &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>; </span><br><span class="line">&#125; <span class="comment">//动物抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Animal <span class="title">createAnimal</span><span class="params">()</span></span>;</span><br><span class="line">&#125; <span class="comment">//工厂接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;&#125; <span class="comment">//具体狗类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;&#125; <span class="comment">//具体猫类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DogFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Animal <span class="title">createAnimal</span><span class="params">()</span> </span>&#123;…&#125;</span><br><span class="line">&#125; <span class="comment">//狗工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CatFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Animal <span class="title">createAnimal</span><span class="params">()</span> </span>&#123;…&#125;</span><br><span class="line">&#125; <span class="comment">//猫工厂</span></span><br></pre></td></tr></table></figure><h3 id="适配器设计模式"><a href="#适配器设计模式" class="headerlink" title="适配器设计模式"></a>适配器设计模式</h3><ul><li>什么是适配器<ul><li>在使用监听器的时候, 需要定义一个类事件监听器接口.</li><li>通常接口中有多个方法, 而程序中不一定所有的都用到, 但又必须重写, 这很繁琐.</li><li>适配器简化了这些操作, 我们定义监听器时只要继承适配器, 然后重写需要的方法即可.</li></ul></li><li>适配器原理<ul><li>适配器就是一个类, 实现了监听器接口, 所有抽象方法都重写了, 但是方法全是空的.</li><li>适配器类需要定义成抽象的,因为创建该类对象,调用空方法是没有意义的</li><li>目的就是为了简化程序员的操作, 定义监听器时继承适配器, 只重写需要的方法就可以了.</li></ul></li></ul><hr><p><strong><u>划重点</u></strong>: 直接实现接口，有些方法不需要实现，弄个中间过渡抽象类，全部实现了，方法体为空，那到时候继承的时候，直接继承这个抽象类就可以了，要什么重写什么。</p><hr><h3 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h3><ul><li><p>概述</p><ul><li>模版方法模式就是定义一个算法的骨架，而将具体的算法延迟到子类中来实现</li></ul></li><li><p>优缺点</p><ul><li>优：使用模版方法模式，在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的需求</li><li>缺：如果算法骨架有修改的话，则需要修改抽象类</li></ul></li><li><p>案例</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象出算法骨架，具体算法实现由子类去实现</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GetTime</span> </span>&#123;</span><br><span class="line">    <span class="comment">//算法框架固定(不让子类重写)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">code();</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">return</span> end - start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//算法实现抽象(必须由子类重写)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">GetTime</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">具体算法</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>回顾</p></blockquote><p>已学设计模式：装饰、单例、简单工厂、工厂方法、适配器、模版</p><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><ul><li>IP<ul><li>本地回路地址：127.0.0.1 </li><li>广播地址：255.255.255.255</li></ul></li><li>端口<ul><li>每个程序在设备上的唯一标识，每个网络程序都需要绑定一个端口号，传输数据的时候除了确定发到哪台机器上，还要明确发到哪个程序。</li><li>范围 0~65535，尽量用1024以上</li><li>常用端口<ul><li>mysql: 3306</li><li>oracle: 1521</li><li>web: 80</li><li>tomcat: 8080</li><li>QQ: 4000</li><li>feiQ: 2425</li></ul></li></ul></li><li>协议<ul><li>UDP<ul><li>面向无连接，数据不安全，速度快。不区分客户端与服务端。</li></ul></li><li>TCP<ul><li>面向连接（三次握手），数据安全，速度略低。分为客户端和服务端。</li><li>三次握手: 客户端先向服务端发起请求, 服务端响应请求, 传输数据</li></ul></li></ul></li></ul><h3 id="Socket通信"><a href="#Socket通信" class="headerlink" title="Socket通信"></a>Socket通信</h3><ul><li>网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字。</li><li>通信的两端都有Socket。网络通信其实就是Socket间的通信。</li><li>数据在两个Socket间通过IO流传输。</li></ul><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><ul><li>发送Send<ul><li>创建<code>DatagramSocket</code>, 随机端口号</li><li>创建<code>DatagramPacket</code>, 指定数据, 长度, 地址, 端口</li><li>使用<code>DatagramSocket</code>发送<code>DatagramPacket</code></li><li>关闭<code>DatagramSocket</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(); <span class="comment">//创建Socket相当于创建码头</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    String line = sc.nextLine();</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"quit"</span>.equals(line)) &#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">    DatagramPacket packet = <span class="keyword">new</span> DatagramPacket( <span class="comment">//创建Packet相当于集装箱</span></span><br><span class="line">        str.getBytes(), str.getBytes().length,   <span class="comment">//(buf, length, address,port)</span></span><br><span class="line">        InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">6666</span></span><br><span class="line">    );</span><br><span class="line">    socket.send(packet); <span class="comment">//发货,将数据发出去</span></span><br><span class="line">&#125;</span><br><span class="line">socket.close();  <span class="comment">//关闭码头</span></span><br></pre></td></tr></table></figure><ul><li>接收Receive<ul><li>创建<code>DatagramSocket</code>, 指定端口号</li><li>创建<code>DatagramPacke</code>t, 指定数组, 长度</li><li>使用<code>DatagramSocket</code>接收<code>DatagramPacket</code></li><li>关闭<code>DatagramSocket</code></li><li>从<code>DatagramPacket</code>中获取数据</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(<span class="number">6666</span>);<span class="comment">//创建Socket相当于创建码头</span></span><br><span class="line">DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(<span class="comment">//创建Packet相当于创建集装箱</span></span><br><span class="line">    <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>], <span class="number">1024</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    socket.receive(packet);<span class="comment">//接货,接收数据</span></span><br><span class="line">    <span class="keyword">byte</span>[] arr = packet.getData();<span class="comment">//获取数据</span></span><br><span class="line">    <span class="keyword">int</span> len = packet.getLength();<span class="comment">//获取有效的字节个数</span></span><br><span class="line">    String ip = packet.getAddress().getHostAddress();<span class="comment">//获取ip地址</span></span><br><span class="line"><span class="keyword">int</span> port = packet.getPort();<span class="comment">//获取端口号</span></span><br><span class="line">   System.out.println(ip + <span class="string">":"</span> + port + <span class="string">":"</span> + <span class="keyword">new</span> String(arr,<span class="number">0</span>,len));</span><br><span class="line">&#125;</span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure><ul><li>接收方获取ip和端口号<ul><li><code>String ip = packet.getAddress().getHostAddress();</code></li><li><code>int port = packet.getPort();</code></li></ul></li><li>多线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receive</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Send</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><ul><li>客户端<ul><li>创建Socket连接服务端(指定ip地址,端口号)通过ip地址找对应的服务器</li><li>调用Socket的<code>getInputStream()</code>和<code>getOutputStream()</code>方法获取和服务端相连的IO流</li><li>输入流可以读取服务端输出流写出的数据</li><li>输出流可以写出数据到服务端的输入流</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">12345</span>);</span><br><span class="line"></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));<span class="comment">//将字节流包装成了字符流</span></span><br><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">System.out.println(br.readLine());</span><br><span class="line">ps.println(<span class="string">"客户端向服务端发送数据1"</span>);</span><br><span class="line">System.out.println(br.readLine());</span><br><span class="line">ps.println(<span class="string">"客户端向服务端发送数据2"</span>);</span><br><span class="line"></span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure><ul><li>服务端<ul><li>创建<code>ServerSocket</code>(需要指定端口号)</li><li>调用<code>ServerSocket</code>的<code>accept()</code>方法接收一个客户端请求，得到一个Socket</li><li>调用<code>Socket的getInputStream()</code>和<code>getOutputStream()</code>方法获取和客户端相连的IO流</li><li>输入流可以读取客户端输出流写出的数据</li><li>输出流可以写出数据到客户端的输入流</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">12345</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> Socket socket = server.accept();<span class="comment">//接受客户端的请求</span></span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                    <span class="keyword">new</span> InputStreamReader(socket.getInputStream())</span><br><span class="line">                );</span><br><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(socket.getOutputStream());</span><br><span class="line">                ps.println(<span class="string">"server2client data1"</span>);</span><br><span class="line">                System.out.println(br.readLine());</span><br><span class="line">                ps.println(<span class="string">"server2client data2"</span>);</span><br><span class="line">                System.out.println(br.readLine());</span><br><span class="line">               </span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;<span class="comment">//服务器不需要关闭</span></span><br></pre></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="客户端向服务器上传文件"><a href="#客户端向服务器上传文件" class="headerlink" title="客户端向服务器上传文件"></a>客户端向服务器上传文件</h4><ol><li>提示输入要上传的文件路径, 验证路径是否存在以及是否是文件夹</li><li>发送文件名到服务端</li><li>建立多线程的服务器</li><li>读取文件名</li><li>判断文件是否存在, 将结果发回客户端</li><li>接收结果, 如果存在给予提示, 程序直接退出</li><li>如果不存在, 定义<code>FileInputStream</code>读取文件, 写出到网络</li><li>定义<code>FileOutputStream</code>, 从网络读取数据, 存储到本地</li></ol><ul><li>客户端</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.提示输入要上传的文件路径, 验证路径是否存在以及是否是文件夹</span></span><br><span class="line">        File file = getFile();</span><br><span class="line">        <span class="comment">// 2.发送文件名到服务端</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">12345</span>);</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">            <span class="keyword">new</span> InputStreamReader(socket.getInputStream())</span><br><span class="line">        );</span><br><span class="line">        PrintStream ps = <span class="keyword">new</span> PrintStream(socket.getOutputStream());</span><br><span class="line">        ps.println(file.getName());</span><br><span class="line">        <span class="comment">// 6.接收结果, 如果存在给予提示, 程序直接退出</span></span><br><span class="line">        String result = br.readLine();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"exist"</span>.equals(result)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"The file already exists."</span>);</span><br><span class="line">            socket.close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 7.如果不存在, 定义FileInputStream读取文件, 写出到网络</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        <span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8192</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(arr)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            ps.write(arr, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> File <span class="title">getFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入待上传文件路径："</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            String str = sc.nextLine();</span><br><span class="line">            File f = <span class="keyword">new</span> File(str);</span><br><span class="line">            <span class="keyword">if</span>(!f.exists()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"您输入的路径无效，请重输："</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(f.isDirectory()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"您输入的是一个目录，请重输："</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> f;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>服务端</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//3,建立多线程的服务器</span></span><br><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">12345</span>);</span><br><span class="line">System.out.println(<span class="string">"Server is running on port 12345"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> Socket socket = server.accept();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                InputStream is = socket.getInputStream();</span><br><span class="line">                BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                    <span class="keyword">new</span> InputStreamReader(is)</span><br><span class="line">                );</span><br><span class="line">                PrintStream ps = <span class="keyword">new</span> PrintStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">                String line = br.readLine();</span><br><span class="line">                File dir = <span class="keyword">new</span> File(<span class="string">"UploadDir"</span>);</span><br><span class="line">                dir.mkdir();</span><br><span class="line">                <span class="comment">//4.读取文件名</span></span><br><span class="line">                File file = <span class="keyword">new</span> File(dir, line);</span><br><span class="line">                <span class="comment">//5.判断文件是否存在, 将结果发回客户端</span></span><br><span class="line">                <span class="keyword">if</span>(file.exists()) &#123;</span><br><span class="line">                    ps.println(<span class="string">"exist"</span>);</span><br><span class="line">                    socket.close();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ps.println(<span class="string">"upload"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//8.定义FileOutputStream, 从网络读取数据, 存储到本地</span></span><br><span class="line">                FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">                <span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8192</span>];</span><br><span class="line">                <span class="keyword">int</span> len;</span><br><span class="line">                <span class="keyword">while</span> ((len = is.read(arr)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    fos.write(arr, <span class="number">0</span>, len);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                fos.close();</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>个人小困惑</p></blockquote><p>当在传输的时候，客户端在写，同时服务端在读，如何同步。其实应该是服务端一直在<code>read()</code>如果没读到只不过是读到的<code>length</code>为0罢了，只有读到了文件结束符<code>EOF</code>才停止。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 多线程和网络 </tag>
            
            <tag> Java 简单的设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java学习(4)</title>
      <link href="/2018/11/05/Java%E5%AD%A6%E4%B9%A04/"/>
      <url>/2018/11/05/Java%E5%AD%A6%E4%B9%A04/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p>异常处理、File类、IO流<br>上周好朋友结婚，以及一些琐事，导致脱更。抱歉！</p></blockquote><p><img src="https://image-link.nos-eastchina1.126.net/java_04"></p><a id="more"></a><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul><li><p>异常继承体系</p><ul><li><p><code>Throwable</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getMessage() <span class="comment">//获取异常信息，返回字符串。</span></span><br><span class="line">toString()   <span class="comment">//获取异常类名和异常信息，返回字符串。</span></span><br><span class="line">printStackTrace()<span class="comment">//获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。</span></span><br></pre></td></tr></table></figure><ul><li><code>Error</code> ：服务器宕机，数据库崩溃</li><li><code>Exception</code><ul><li><code>RuntimeException</code></li><li>编译时异常，在编译阶段必须显示处理</li></ul></li></ul></li></ul></li><li><p><code>JVM</code>异常处理</p><ul><li><code>main</code>发现问题，自己处理，然后继续运行</li><li>自身没有针对的处理方法，交给<code>main</code>的<code>JVM</code>处理<ul><li><code>JVM</code>有一个默认的异常处理机制，并将该异常的名称,异常的信息.异常出现的位置打印在了控制台上,同时将程序停止运行。</li></ul></li></ul></li></ul><h3 id="异常处理格式"><a href="#异常处理格式" class="headerlink" title="异常处理格式"></a>异常处理格式</h3><h4 id="try-catch"><a href="#try-catch" class="headerlink" title="try catch"></a>try catch</h4><ul><li><code>try catch</code></li><li><code>try catch finally</code></li><li><code>try finally</code></li></ul><blockquote><p>jdk7处理多异常</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ArithmeticException | ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="细说Finally"><a href="#细说Finally" class="headerlink" title="细说Finally"></a>细说Finally</h5><ul><li><p>特点</p><ul><li><p>被<code>finally</code>控制的语句体一定会执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">"捕获异常"</span>);</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">//在return执行前，会先去执行finally，最后再彻底返回</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"执行收尾工作"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>特殊情况：在执行到<code>finally</code>之前jvm退出了(比如<code>System.exit(0)</code>)</p></li></ul></li><li><p>作用</p><ul><li>用于释放资源，在IO流操作和数据库操作中会见到</li></ul></li></ul><blockquote><p>面试题</p></blockquote><ol><li><p><code>final</code> <code>finally</code>和 <code>finalize</code>区别</p><p><code>finalize</code>是一个方法，当垃圾回收器确定不存在对该对象的更多引用时，由对象垃圾回收器调用该方法</p></li><li><p>运行顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    x = <span class="number">20</span>;</span><br><span class="line">    System.out.println(<span class="number">1</span>/<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    x = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">return</span> x; <span class="comment">//结果返回30，因为此时，虽然执行finnaly,但此时的x值已经确定</span></span><br><span class="line">&#125; finnaly &#123;</span><br><span class="line">    x = <span class="number">40</span>; <span class="comment">//禁止写return,会覆盖上面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h4><ul><li>定义功能方法时，需要把出现的问题暴露出来让调用者去处理。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"编译时异常"</span>); <span class="comment">//抛出必须处理，编译通不过</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"运行时异常"</span>); <span class="comment">//抛出后可以不处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>和<code>throw</code>区别</p><p><code>throw</code>概述：在功能方法内部出现某种情况，程序不能继续运行，需要进行跳转时，就用<code>throw</code>把异常对象抛出。</p><ul><li><code>throws</code><ul><li>用在方法声明后面，跟的是异常类名</li><li>可以跟多个异常类名，用逗号隔开</li><li>表示抛出异常，由该方法的调用者来处理</li></ul></li><li><code>throw</code><ul><li>用在方法体内，跟的是异常对象名</li><li>只能抛出一个异常对象名</li><li>表示抛出异常，由方法体内的语句处理</li></ul></li></ul></li></ul><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><ul><li><p>缘由</p><ul><li>主要用来通过名字区分到底是什么异常，有针对性解决</li></ul></li><li><p>继承<code>Exception</code>或<code>RuntimeException</code></p></li></ul><h3 id="异常注意事项"><a href="#异常注意事项" class="headerlink" title="异常注意事项"></a>异常注意事项</h3><ul><li>子类重写父类方法时，子类的方法必须抛出相同的异常或父类异常的子类。</li><li>如果父类抛出了多个异常,子类重写父类时,只能抛出相同的异常或者是他的子集,子类不能抛出父类没有的异常</li><li>如果被重写的方法没有异常抛出,那么子类的方法绝对不可以抛出异常,如果子类方法内有异常发生,那么子类只能<code>try</code> 不能<code>throws</code></li></ul><blockquote><p>小案例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    String line = sc.nextLine();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(line);</span><br><span class="line">        System.out.println(Integer.toBinaryString(num));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> BigInteger(line);</span><br><span class="line">System.out.println(<span class="string">"录入错误,您录入的是一个过大整数"</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">new</span> BigDecimal(line);</span><br><span class="line">System.out.println(<span class="string">"录入错误,您录入的是一个小数"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">                System.out.println(<span class="string">"录入错误,您录入的是非法字符"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><ul><li>构造方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File(String pathname) </span><br><span class="line">File(String parent, String child)</span><br><span class="line">    <span class="comment">//根据一个目录和一个子文件/目录得到File对象</span></span><br><span class="line">File(File parent, String child)</span><br><span class="line">    <span class="comment">//根据一个父File对象和一个子文件/目录得到File对象</span></span><br></pre></td></tr></table></figure><h3 id="创建功能"><a href="#创建功能" class="headerlink" title="创建功能"></a>创建功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">createNewFile</span><span class="params">()</span><span class="comment">//创建文件 如果存在这样的文件，就不创建了</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">mkdir</span><span class="params">()</span><span class="comment">//创建文件夹 如果存在这样的文件夹，就不创建了</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">mkdirs</span><span class="params">()</span><span class="comment">//创建多级目录</span></span></span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><p>如果你创建文件或者文件夹忘了写盘符路径，那么，默认在<strong>项目路径</strong>下。</p><h3 id="重命名和删除"><a href="#重命名和删除" class="headerlink" title="重命名和删除"></a>重命名和删除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">renameTo</span><span class="params">(File dest)</span>  <span class="comment">//把文件重命名为指定的文件路径</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">delete</span><span class="params">()</span>  <span class="comment">//删除文件或者文件夹</span></span></span><br></pre></td></tr></table></figure><ul><li>重命名注意事项<ul><li>如果路径名相同，就是改名。</li><li>如果路径名不同，就是改名并剪切。</li></ul></li><li>删除注意事项<ul><li>Java中的删除不走回收站。</li><li>要删除一个文件夹，请注意该文件夹内不能包含文件或者文件夹</li></ul></li></ul><h3 id="判断功能"><a href="#判断功能" class="headerlink" title="判断功能"></a>判断功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDirectory</span><span class="params">()</span><span class="comment">//判断是否是目录</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span><span class="comment">//判断是否是文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span><span class="comment">//判断是否存在</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canRead</span><span class="params">()</span><span class="comment">//判断是否可读  win下默认都可读</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canWrite</span><span class="params">()</span><span class="comment">//判断是否可写</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isHidden</span><span class="params">()</span><span class="comment">//判断是否隐藏</span></span></span><br></pre></td></tr></table></figure><h3 id="获取功能"><a href="#获取功能" class="headerlink" title="获取功能"></a>获取功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getAbsolutePath</span><span class="params">()</span><span class="comment">//获取绝对路径</span></span></span><br><span class="line"><span class="function">String <span class="title">getPath</span><span class="params">()</span><span class="comment">//获取路径  构造方法中传入的</span></span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span><span class="comment">//获取名称</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">length</span><span class="params">()</span><span class="comment">//获取长度。字节数  (目录不行)  </span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">lastModified</span><span class="params">()</span><span class="comment">//获取最后一次的修改时间，毫秒值</span></span></span><br><span class="line"><span class="function">String[] <span class="title">list</span><span class="params">()</span><span class="comment">//获取指定目录下的所有文件或者文件夹的名称数组</span></span></span><br><span class="line"><span class="function">File[] <span class="title">listFiles</span><span class="params">()</span><span class="comment">//获取指定目录下的所有文件或者文件夹的File数组</span></span></span><br></pre></td></tr></table></figure><h3 id="文件名称过滤器"><a href="#文件名称过滤器" class="headerlink" title="文件名称过滤器"></a>文件名称过滤器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] list(FilenameFilter filter)</span><br><span class="line">File[] listFiles(FileFilter filter)</span><br></pre></td></tr></table></figure><p>案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">File dir = <span class="keyword">new</span> File(<span class="string">"path"</span>);</span><br><span class="line">dir.list(<span class="keyword">new</span> FilenameFilter() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//return false;</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(dir, name);</span><br><span class="line">        <span class="keyword">return</span> file.isFile() &amp;&amp; file.getName().endsWith(<span class="string">".jpg"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul><li>弊端:不能调用次数过多,容易导致栈内存溢出<ul><li>好处:不用知道循环次数</li></ul></li></ul><blockquote><p>注意点：</p><ol><li>构造方法不能使用递归调用</li><li>递归调用的返回值不一定(可以有,也可以没有)</li></ol></blockquote><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><ol><li>统计文件夹大小和删除文件夹</li><li>文件夹拷贝(多敲几次)</li><li>层级打印，类似tree的效果</li><li>1000！0个数及尾部0个数（尾部0用递归做）</li><li>约瑟夫环</li></ol><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><ul><li>概念<ul><li>IO流用来处理设备之间的数据传输</li><li>Java对数据的操作是通过流的方式</li><li>Java用于操作流的类都在IO包中</li><li>流按流向分为两种：输入流，输出流。</li><li>流按操作类型分为两种：<ul><li>字节流 : 字节流可以操作任何数据,因为在计算机中任何数据都是以字节的形式存储的</li><li>字符流 : 字符流只能操作纯字符数据，比较方便。</li></ul></li></ul></li><li>IO流常用父类<ul><li>字节流的抽象父类：<ul><li><code>InputStream</code></li><li><code>OutputStream</code></li></ul></li><li>字符流的抽象父类：<ul><li><code>Reader</code></li><li><code>Writer</code>    </li></ul></li></ul></li><li>3.IO程序书写<ul><li>使用前，导入IO包中的类</li><li>使用时，进行IO异常处理</li><li>使用后，释放资源</li></ul></li></ul><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><ul><li><p>FileInputStream</p><ul><li>读取一个字节</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"aaa.txt"</span>);</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">while</span>((b = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure><ul><li>问：<code>read()</code>方法返回值为什么是<code>int</code></li></ul><p>​    每次读取都返回<code>byte</code>,有可能在读到中间的时候遇到111111111</p></li><li><p>FileOutputStream</p><ul><li>写一个字节</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"bbb.txt"</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//bbb文件存在，不存在则创建. 默认覆盖，若要追加则改true</span></span><br><span class="line">fis.write(<span class="number">97</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h4><h5 id="逐字节拷贝"><a href="#逐字节拷贝" class="headerlink" title="逐字节拷贝"></a>逐字节拷贝</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"summer.mp3"</span>);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"copy.mp3"</span>);</span><br><span class="line"><span class="comment">//效率低</span></span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">while</span>((b = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line">fis.close();</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure><h5 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h5><ul><li>整个拷贝</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[fis.available];<span class="comment">//创建与读文件大小一样的数组</span></span><br><span class="line"><span class="comment">//容易内存溢出</span></span><br><span class="line">fis.read(arr);</span><br><span class="line">fos.write(arr);</span><br></pre></td></tr></table></figure><ul><li>小数组拷贝</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len = fis.read(arr)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    fos.write(arr, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="缓冲区拷贝"><a href="#缓冲区拷贝" class="headerlink" title="缓冲区拷贝"></a>缓冲区拷贝</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BufferedInputStream fis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">BufferedInputStream fos = <span class="keyword">new</span> BufferedInputStream(fos);</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">while</span>((b = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">    bos.write(b);</span><br><span class="line">&#125;</span><br><span class="line">bis.close();</span><br><span class="line">bos.close();</span><br></pre></td></tr></table></figure><ul><li><code>BufferedInputStream</code><ul><li>内置了一个缓冲区(数组)</li><li>从中读取一个字节时，<code>BufferedInputStream</code>会<strong>一次性</strong>从文件中读取8192个字节, 存在缓冲区中, 返回给程序一个字节</li><li>程序再次读取时, 就不用找文件了, 直接从缓冲区中获取</li><li>直到缓冲区中所有的都被使用过, 才<strong>重新</strong>从文件中读取8192个</li></ul></li><li><p><code>BufferedOutputStream</code></p><ul><li>也内置了一个缓冲区(数组) 8KB</li><li>程序向流中写出字节时, 不会直接写到文件, 先写到缓冲区中</li><li>直到缓冲区写满, <code>BufferedOutputStream</code>才会把缓冲区中的数据一次性写到文件里</li></ul></li><li><p><code>flush()</code>和<code>close()</code>区别</p><ul><li><code>flush()</code><ul><li>用来刷新缓冲区的,刷新后可以再次写出 </li></ul></li><li><code>close()</code><ul><li>用来关闭流释放资源的的,如果是带缓冲区的流对象的<code>close()</code>方法,不但会关闭流,还会再关闭流之前刷新缓冲区,关闭后不能再写出 </li></ul></li></ul></li></ul><h4 id="读取中文"><a href="#读取中文" class="headerlink" title="读取中文"></a>读取中文</h4><ul><li>字节流读取中文的问题<ul><li>字节流在读中文的时候有可能会读到半个中文,造成乱码 <ul><li>用字符流解决</li><li>也可用内存输出流解决</li></ul></li></ul></li><li>字节流写出中文的问题<ul><li>字节流直接操作的字节,所以写出中文必须将字符串转换成字节数组 </li><li>写出回车换行 <code>write(&quot;\r\n&quot;.getBytes())</code>;</li></ul></li></ul><blockquote><p> 流处理异常代码规范</p></blockquote><ul><li><p>jdk1.6以前</p><p><code>try finally</code>嵌套</p></li><li><p>Jdk1.7</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"aaa.txt"</span>);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"bbb.txt"</span>);</span><br><span class="line">    MyClose mc = <span class="keyword">new</span> MyClose();<span class="comment">//必须实现close方法</span></span><br><span class="line">)&#123;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">while</span>((b = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        fos.write(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>原理</p><p>​    在<code>try()</code>中创建的流对象必须实现了<code>AutoCloseable</code>这个接口,如果实现了,在<code>try</code>后面的<code>{}</code>(读写代码)执行后就会<strong>自动调用</strong>,流对象的<code>close</code>方法将流关掉 。</p></li></ul></li></ul><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><ul><li><p><code>FileReader</code></p><ul><li><code>read()</code>方法可以按照字符大小读取</li></ul></li><li><p><code>FileWriter</code></p><ul><li><code>write()</code>方法可以自动把字符、字符串等转为字节写出</li></ul></li></ul><h4 id="拷贝-1"><a href="#拷贝-1" class="headerlink" title="拷贝"></a>拷贝</h4><ul><li>逐字符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"a.txt"</span>);</span><br><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"b.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line"><span class="keyword">while</span>((ch = fr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">fw.write(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fr.close();</span><br><span class="line">fw.close();<span class="comment">//在Writer类中有个2KB的小缓冲区，若不关流，则会存在于缓冲区</span></span><br></pre></td></tr></table></figure><blockquote><p>用字符流来拷贝</p></blockquote><ol><li><p>文本文件</p><p>因为读取时会把字节转为字符, 写出时还要把字符转回字节。效率低。一般用来普通读写文本文件</p></li><li><p><strong>不能</strong>拷贝非文本文件</p><p>因为在读的时候会将字节转换为字符,在转换过程中,可能找不到对应的字符,就会用?代替,写出的时候会将字符转换成字节写出去如果是?,直接写出,这样写出之后的文件就乱了,看不了</p></li></ol><ul><li><p>小数组拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">char</span>[] arr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>*<span class="number">8</span>];</span><br><span class="line"><span class="keyword">while</span>((len = fr.read(arr)) != -<span class="number">1</span>) &#123;</span><br><span class="line">fw.write(arr, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>带缓冲区拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"aaa.txt"</span>));<span class="comment">//创建字符输入流对象,关联aaa.txt</span></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"bbb.txt"</span>));<span class="comment">//创建字符输出流对象,关联bbb.txt</span></span><br><span class="line"><span class="comment">//其后写法同字节流</span></span><br></pre></td></tr></table></figure><ul><li><code>readLine()</code>和<code>newLine()</code>方法<ul><li><code>BufferedReader</code>的<code>readLine()</code>方法可以读取一行字符(不包含换行符号)</li><li><code>newLine()</code>可以输出一个跨平台的换行符号<code>&quot;\r\n&quot;</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    bw.write(line);</span><br><span class="line">    bw.newLine();<span class="comment">//支持跨平台换行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>LineNumberReader</code>类<ul><li><code>getLineNumber()</code>方法可以获取当前行号</li><li><code>setLineNumber()</code>方法可以设置当前行号</li></ul></li></ul></li></ul><h4 id="指定编码表"><a href="#指定编码表" class="headerlink" title="指定编码表"></a>指定编码表</h4><ul><li><code>InputStreamReader(字节流, 编码表)</code>    将字节流按<strong>指定</strong>编码表转换成字符流</li><li><code>OutputStreamWriter(字节流,编码表)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">    <span class="keyword">new</span> InputStreamReader(</span><br><span class="line">        <span class="keyword">new</span> FileInputStream(<span class="string">"UTF-8.txt"</span>), <span class="string">"UTF-8"</span></span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(</span><br><span class="line">    <span class="keyword">new</span> OutputStreamWriter(</span><br><span class="line">        <span class="keyword">new</span> FileOutputStream(<span class="string">"GBK.txt"</span>), <span class="string">"GBK"</span></span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line"><span class="keyword">while</span>((ch = br.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">    bw.write(ch);</span><br><span class="line">&#125;</span><br><span class="line">br.close();</span><br><span class="line">bw.close();</span><br></pre></td></tr></table></figure><h4 id="小测验"><a href="#小测验" class="headerlink" title="小测验"></a>小测验</h4><p>统计一个文本文件中，各字符出现个数</p><h4 id="装饰设计模式"><a href="#装饰设计模式" class="headerlink" title="装饰设计模式"></a>装饰设计模式</h4><ul><li>优点<ul><li>耦合性不强</li><li>被装饰的类的变化与装饰类的变化无关</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Coder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Coder</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"javase"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeiMaStudent</span> <span class="keyword">implements</span> <span class="title">Coder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.获取到被包装的类的引用</span></span><br><span class="line"><span class="keyword">private</span> Student s;</span><br><span class="line">    <span class="comment">//2.通过构造函数创建对象的时候,传入被包装的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ItcastStudent</span><span class="params">(Student s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.s = s;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//3.对其原有功能进行升级</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">s.code();</span><br><span class="line">System.out.println(<span class="string">"数据库"</span>);</span><br><span class="line">System.out.println(<span class="string">"ssm"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列流"><a href="#序列流" class="headerlink" title="序列流"></a>序列流</h3><ul><li><p>概念</p><p>​    <code>SequenceInputStream</code>可以把多个字节输入流整合成一个, 从序列流中读取数据时, 将从被整合的第一个流开始读, 读完一个之后继续读第二个, 以此类推.</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis1 = <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);</span><br><span class="line">FileInputStream fis2 = <span class="keyword">new</span> FileInputStream(<span class="string">"b.txt"</span>);</span><br><span class="line">FileInputStream fis3 = <span class="keyword">new</span> FileInputStream(<span class="string">"c.txt"</span>);</span><br><span class="line">Vector&lt;InputStream&gt; v = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">v.add(fis1);</span><br><span class="line">v.add(fis2);</span><br><span class="line">v.add(fis3);</span><br><span class="line">Enumeration&lt;InputStream&gt; en = v.elements();<span class="comment">//获取枚举引用</span></span><br><span class="line">SequenceInputStream sis = <span class="keyword">new</span> SequenceInputStream(en);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"d.txt"</span>);</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">while</span>((b = sis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">fos.write(b);</span><br><span class="line">&#125;</span><br><span class="line">sis.close();</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure><h3 id="内存输出流"><a href="#内存输出流" class="headerlink" title="内存输出流"></a>内存输出流</h3><ul><li><p>概念</p><p>​    <code>ByteArrayOutputStream</code>该输出流可以向内存中写数据, 把内存当作一个缓冲区, 写出之后可以一次性获取出所有数据</p></li><li><p>使用方式</p><ul><li>创建：<code>new ByteArrayOutputStream()</code></li><li>写出：<code>write(int)</code>, <code>write(byte[])</code></li><li>获取：<code>toByteArray()</code> <code>toString()</code></li></ul></li></ul><h3 id="对象操作流"><a href="#对象操作流" class="headerlink" title="对象操作流"></a>对象操作流</h3><ul><li><p>概念</p><p>​    <code>ObjectOutputStream</code>该流可以将一个对象写出, 或者读取一个对象到程序中. 也就是执行了序列化和反序列化的操作.</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">23</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">24</span>);</span><br><span class="line"><span class="comment">//无论是字节输出流,还是字符输出流都不能直接写出对象</span></span><br><span class="line"><span class="comment">//将对象写出,序列化</span></span><br><span class="line"><span class="comment">//Person 类必须实现 Serializable 接口，才可实现序列化</span></span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"e.txt"</span>));</span><br><span class="line">oos.writeObject(p1);</span><br><span class="line">oos.writeObject(p2);</span><br><span class="line">oos.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取对象,反序列化</span></span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"e.txt"</span>));</span><br><span class="line">Person p1 = (Person) ois.readObject();</span><br><span class="line">Person p2 = (Person) ois.readObject();</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure><ul><li>优化写法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(p1);</span><br><span class="line">list.add(p2);</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"f.txt"</span>));</span><br><span class="line"><span class="comment">//集合写进去</span></span><br><span class="line">oos.writeObject(list);</span><br><span class="line">oos.close();</span><br><span class="line"></span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"f.txt"</span>));</span><br><span class="line">ArrayList&lt;Person&gt; list = (ArrayList&lt;Person&gt;)ois.readObject();</span><br><span class="line"><span class="comment">//泛型在运行期会被擦除,索引运行期相当于没有泛型</span></span><br><span class="line"><span class="keyword">for</span> (Person person : list) &#123;</span><br><span class="line">    System.out.println(person);</span><br><span class="line">&#125;</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure><ul><li><p>id</p><p>用来识别当前类的版本号，不用必须加。</p></li></ul><h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><ul><li><p>概念</p><p>​    该流可以很方便的将对象的<code>toString()</code>结果输出, 并且自动加上换行, 而且可以使用自动刷出的模式。</p><ul><li><code>PrintStream</code><ul><li><code>System.out</code>, 其默认向控制台输出信息</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PrintStream ps = System.out;</span><br><span class="line">ps.println(<span class="number">97</span>);<span class="comment">//其实底层用的是Integer.toString(x),将x转换为数字字符串打印</span></span><br><span class="line">ps.println(<span class="string">"xxx"</span>);</span><br><span class="line">ps.println(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">23</span>));</span><br><span class="line">Person p = <span class="keyword">null</span>;</span><br><span class="line">ps.println(p); <span class="comment">//如果是null,就返回null,如果不是null,就调用对象的toString()</span></span><br></pre></td></tr></table></figure><ul><li><code>PrintWrite</code><ul><li>自动刷出：<code>PrintWrite(OutputStream out, boolean autoFlush, String encoding)</code>       (自动只针对<code>println()</code>)，所以没什么用</li></ul></li></ul></li><li><p><code>PrintStream</code>和<code>PrintWrite</code>区别</p><p>​         2个类的功能基本相同，<code>PrintStream</code>能做的<code>PrintWriter</code>也都能实现，并且<code>PrintWriter</code>的功能更为强大。但是由于<code>PrintWriter</code>出现的比较晚，较早的<code>System.out</code>使用的是<code>PrintStream</code>来实现的，所以为了兼容就没有废弃<code>PrintStream</code>。 </p><p>​    2个类最大的<strong>差别</strong>是，<code>PrintStream</code>在输出字符，将字符转换为字节时采用的是系统默认的编码格式，这样当数据传输另一个平台，而另一个平台使用另外一个编码格式解码时就会出现问题，存在不可控因素。而<code>PrintWriter</code>可以在传入<code>Writer</code>时可由程序员指定字符转换为字节时的编码格式，这样兼容性和可控性会更好。</p></li></ul><blockquote><p> 打印流只操作数据目的，相当于<strong>只写</strong></p></blockquote><h3 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h3><ul><li><code>System.in</code>是<code>InputStream</code>, 标准输入流, 默认可以从键盘输入读取字节数据</li><li><code>System.out</code>是<code>PrintStream</code>, 标准输出流, 默认可以向Console中输出字符和字节数据</li><li>修改输入流： <code>System.setIn(InputStream)</code>   当跟硬盘文件产生关联时，则需要关闭</li><li>修改输出流：<code>System.setOut(PrintStream)</code></li></ul><h3 id="随机访问流"><a href="#随机访问流" class="headerlink" title="随机访问流"></a>随机访问流</h3><ul><li><p>概述</p><ul><li><code>RandomAccessFile</code>类不属于流，是<code>Object</code>类的子类。但它融合了<code>InputStream</code>和<code>OutputStream</code>的功能。</li><li>支持对随机访问文件的读取和写入。</li></ul></li><li><p>API</p><ul><li><code>read()</code>,<code>write()</code>,<code>seek()</code>   可用于多线程下载</li></ul></li></ul><h3 id="数据输入输出流"><a href="#数据输入输出流" class="headerlink" title="数据输入输出流"></a>数据输入输出流</h3><blockquote><p>用的不多</p></blockquote><ul><li><code>DataInputStream</code>, <code>DataOutputStream</code>可以按照基本数据类型大小读写数据</li><li>例如按<code>Long</code>大小写出一个数字, 写出时该数据占8字节. 读取的时候也可以按照Long类型读取, 一次读取8个字节.</li></ul><h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><ul><li><p>概述</p><ul><li><code>Properties</code>类表示了一个持久的属性集。</li><li><code>Properties</code>可保存在流中或从流中加载。</li><li>属性列表中每个键及其对应值都是一个字符串。 </li></ul></li><li><p>作为Map集合的使用</p><ul><li><code>Object setProperty(String key,String value)</code></li><li><code>String getProperty(String key)</code></li><li><code>Enumeration&lt;String&gt; stringPropertyNames()</code></li></ul></li><li><p>加载和存储</p><ul><li><p><code>load()</code></p></li><li><p><code>store()</code></p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java IO流 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java学习(3)</title>
      <link href="/2018/11/01/Java%E5%AD%A6%E4%B9%A03/"/>
      <url>/2018/11/01/Java%E5%AD%A6%E4%B9%A03/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p>Collection(List、Set)、泛型、迭代器、Map(HashMap、TreeMap)</p></blockquote><p><img src="https://image-link.nos-eastchina1.126.net/java_03"></p><a id="more"></a><h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><ul><li><p>由来</p><ul><li>集合类,能存储任意对象,长度是可以改变的,随着元素的增加而增加,随着元素的减少而减少 </li></ul></li><li><p>和数组区别</p><ul><li><p>difference1</p><ul><li><p>数组既可以存储基本数据类型,又可以存储引用数据类型</p></li><li><p>集合只能存储引用数据类型(对象)集合中也可以存储基本数据类型,但是在存储的时候会自动装箱变成对象</p></li></ul></li><li><p>difference2</p><ul><li>长度，数组定，集合不定灵活。</li></ul></li></ul></li><li><p>继承图</p><p><code>Collection</code>(单列集合的根接口)</p><ul><li>List有序（存取顺序一致）有索引、可存储重复<ul><li><code>ArrayList</code> ：数组实现</li><li><code>LinkList</code> ：链表实现</li><li><code>Vector</code>  : jdk1.0产生</li></ul></li><li>Set无序（存取顺序不一） 无索引、不可存储重复<ul><li><code>HashSet</code> ：哈希算法</li><li><code>TreeSet</code> ：二叉树算法</li></ul></li></ul></li></ul><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><ul><li><p>基本功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span>     <span class="comment">//到添加基本类型的时候，会自动装箱</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li><li><p>带 all 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection c)</span>  <span class="comment">//此处参数为集合，注意和add()区别</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection c)</span> <span class="comment">//删除的是交集</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection c)</span> <span class="comment">//判断调用集合是否包含传入的集合</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection c)</span><span class="comment">//保留取交集，如果调用的集合改变就true，不变就false</span></span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">c.add(<span class="string">"a"</span>);</span><br><span class="line">c.add(<span class="string">"b"</span>);</span><br><span class="line">c.add(<span class="string">"c"</span>);</span><br><span class="line">c.add(<span class="string">"c"</span>);</span><br><span class="line"></span><br><span class="line">Collection c2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">c2.add(<span class="string">"a"</span>);</span><br><span class="line">c2.add(<span class="string">"b"</span>);</span><br><span class="line">c2.add(<span class="string">"c"</span>);</span><br><span class="line">System.out.println(c.retainAll(c2)); <span class="comment">//false</span></span><br><span class="line">System.out.println(c);     <span class="comment">//["a","b","c","c"]</span></span><br></pre></td></tr></table></figure></li><li><p>集合转数组</p><p><code>public &lt;T&gt; T[] toArray(T[] a)</code></p><p>转换后的数组长度：当指定的参数a数组长度大于集合size，则为指定长度，否则为size</p></li></ul><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = c.iterator();<span class="comment">//获取迭代器的引用</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;<span class="comment">//集合中的迭代方法(遍历)</span></span><br><span class="line">System.out.println(it.next());<span class="comment">//注意此处，in.next()返回的是object类引用</span></span><br><span class="line">&#125;<span class="comment">//next方法用一次指针移1次</span></span><br></pre></td></tr></table></figure><h4 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> <span class="comment">//是否有下一个</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span><span class="comment">//是否有前一个 </span></span></span><br><span class="line"><span class="function">Object <span class="title">next</span><span class="params">()</span><span class="comment">//返回下一个元素</span></span></span><br><span class="line"><span class="function">Object <span class="title">previous</span><span class="params">()</span><span class="comment">//返回上一个元素</span></span></span><br></pre></td></tr></table></figure><h4 id="增强for"><a href="#增强for" class="headerlink" title="增强for"></a>增强for</h4><ul><li><p>功能：简化数组和Collection集合的遍历</p></li><li><p>格式：for(元素数据类型 变量 : 数组或者Collection集合) {<br>​        使用变量即可，该变量就是元素<br>​    }</p></li></ul><h4 id="三种迭代器删除"><a href="#三种迭代器删除" class="headerlink" title="三种迭代器删除"></a>三种迭代器删除</h4><ul><li><p>普通for循环,可以删除,但是索引要–</p></li><li><p>迭代器,可以删除,但是必须使用迭代器自身的remove方法,否则会出现并发修改异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法1</span></span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"b"</span>.equals(it.next())) &#123;</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//法2</span></span><br><span class="line"><span class="keyword">for</span>(Iterator&lt;String&gt; it2) = list.iterator(); it2.hasNext();) &#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="string">"b"</span>.equals(it.next())) &#123;</span><br><span class="line">        it2.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>增强for循环不能删除，因为其底层也是用迭代器实现，并发修改异常。</p></li></ul><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul><li><p>由来</p><ul><li>通过Object转型问题引入</li><li>早期的Object类型可以接收任意的对象类型，但是在实际的使用中，会有类型转换的问题。也就存在这隐患，所以Java提供了泛型来解决这个安全问题。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tool t = <span class="keyword">new</span> Tool();<span class="comment">//该类内部有Object类成员变量</span></span><br><span class="line">t.setObj(<span class="keyword">new</span> Student(<span class="string">"张三"</span>));</span><br><span class="line">Worker w = (Worker) t.getObj(); <span class="comment">//编译不会报错</span></span><br><span class="line"><span class="comment">//运行会出错，因为Object是任何类的父类，存在转换出错</span></span><br></pre></td></tr></table></figure></li><li><p>泛型好处</p><ul><li>提高安全性(将运行期的错误转换到编译期) </li><li>省去强转的麻烦</li></ul></li><li><p>泛型基本使用</p><ul><li>&lt;&gt;中放的必须是引用数据类型</li></ul></li><li><p>泛型使用注意事项</p><ul><li>前后的泛型必须一致,或者后面的泛型可以省略不写(1.7的新特性菱形泛型)  </li></ul></li></ul><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getName</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>&lt;T&gt; <span class="keyword">void</span> <span class="title">method</span><span class="params">(T t)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; <span class="keyword">void</span> <span class="title">method</span><span class="params">(T t)</span> </span>;<span class="comment">//静态方法必须申明自己的泛型</span></span><br></pre></td></tr></table></figure><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接,推荐用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">implements</span> <span class="title">Inter</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String s)</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//再泛型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Inter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">     <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h4><ul><li><p>泛型通配符&lt;?&gt;</p><ul><li>任意类型，如果没有明确，那么就是Object以及任意的Java类了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">//当右边不确定的时，左可用?</span></span><br></pre></td></tr></table></figure></li><li><p>? extends E</p><ul><li>固定上边界，E及其子类，放进集合，父类引用指向子类对象。</li><li>本质：元素添加进集合的时候，用<code>addAll()</code>，此刻的<strong>E为父类</strong>，所以只要是子类都能添加进去</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span></span><br></pre></td></tr></table></figure></li><li><p>? super E</p><ul><li>固定下边界，父类引用指向子类对象。</li><li>子类对象调用父类<code>compare</code>方法，此刻的<strong>E为子类</strong>，所以只要父类的compare方法都可以拿来用。</li></ul></li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul><li><p>特有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,E element)</span> <span class="comment">//0 &lt;= index &lt;= size </span></span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>ListIterator</code> add() </p><p>处理并发修改异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ListIterator lit = list.listIterator(); <span class="comment">//获取迭代器(List集合特有的)</span></span><br><span class="line">lit.add(内容);</span><br><span class="line"><span class="keyword">while</span>(lit.hasNext()) &#123;</span><br><span class="line">    it.next();</span><br><span class="line">lit.add(<span class="string">"迭代器边查询边加入内容"</span>); <span class="comment">//此处若用集合中的add()会发生并发修改异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Arrays.asList()</code></p><p>数组转集合虽然不能增加或减少元素，但可以用集合思想操作数组，可用集合API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">List&lt;<span class="keyword">int</span>[]&gt; list = Arrays.asList(arr);<span class="comment">//基本数据类型数据转换，会将整个数组当做一个对象转换</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><ul><li>去除重复元素<ul><li>调用<code>contains</code>或者<code>remove</code>方法，<strong>注意</strong>其内部实现都依赖<code>equals</code>方法</li></ul></li></ul><h4 id="LinkList"><a href="#LinkList" class="headerlink" title="LinkList"></a>LinkList</h4><ul><li><p>特有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span>及<span class="title">addLast</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function">E <span class="title">getFirst</span><span class="params">()</span>及<span class="title">getLast</span><span class="params">()</span></span></span><br><span class="line"><span class="function">E <span class="title">removeFirst</span><span class="params">()</span>及<span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span></span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><ul><li><p><code>Vector</code>类概述</p></li><li><p><code>Vector</code>类特有功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addElement</span><span class="params">(E obj)</span></span></span><br><span class="line"><span class="function">E <span class="title">elementAt</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">Enumeration <span class="title">elements</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li><li><p>案例演示    </p><ul><li><p><code>Vector</code>的迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vector v = <span class="keyword">new</span> Vector();<span class="comment">//创建集合对象,List的子类</span></span><br><span class="line">v.addElement(<span class="string">"a"</span>);</span><br><span class="line">v.addElement(<span class="string">"b"</span>);</span><br><span class="line"><span class="comment">//Vector迭代</span></span><br><span class="line">Enumeration en = v.elements();<span class="comment">//获取枚举</span></span><br><span class="line"><span class="keyword">while</span>(en.hasMoreElements()) &#123;<span class="comment">//判断集合中是否有元素</span></span><br><span class="line">System.out.println(en.nextElement());<span class="comment">//获取集合中的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p> List的三个子类特点</p><ul><li><code>ArrayList</code>:<ul><li>底层数据结构是数组，查询快，增删慢。</li><li>线程不安全，效率高。</li></ul></li><li><code>Vector</code>:<ul><li>底层数据结构是数组，查询快，增删慢。</li><li>线程安全，效率低。</li></ul></li><li><code>LinkedList</code><ul><li>底层数据结构是链表，查询慢，增删快。</li><li>线程不安全，效率高。</li></ul></li></ul></blockquote><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>无索引，不可重复，无序（存取不一致）</p><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><ul><li><p>存储自定义对象保证元素<strong>唯一性</strong></p><ul><li><p>案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;Person&gt; hs = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">hs.add(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">23</span>)); </span><br><span class="line">hs.add(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">23</span>)); <span class="comment">//当添加不成功的时候返回false</span></span><br><span class="line">hs.add(<span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">23</span>));</span><br><span class="line">hs.add(<span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">23</span>));</span><br><span class="line">hs.add(<span class="keyword">new</span> Person(<span class="string">"王五"</span>, <span class="number">23</span>));</span><br><span class="line"><span class="comment">//结果都添加进去了，并未唯一，原因？？？</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>原理</p><ul><li>我们使用<code>Set</code>集合都是需要去掉重复元素的, 如果在存储的时候逐个<code>equals()</code>比较, 效率较低,哈希算法提高了去重复的效率, 降低了使用<code>equals()</code>方法的次数</li><li>当<code>HashSet</code>调用<code>add()</code>方法存储对象的时候, 先调用对象的<code>hashCode()</code>方法得到一个哈希值, 然后在集合中查找是否有哈希值相同的对象。不相同，则直接添加进集合（桶结构），如果相同，则调用<code>equals()</code>方法。</li></ul></li><li><p>将自定义类的对象存入<code>HashSet</code>去重复</p><ul><li>类中必须重写<code>hashCode()</code>和<code>equals()</code>方法</li><li><code>hashCode()</code>: 属性相同的对象返回值必须相同, 属性不同的返回值尽量不同(提高效率)</li><li><code>equals()</code>: 属性相同返回<code>true</code>, 属性不同返回<code>false</code>,返回<code>false</code>的时候存储</li></ul></li></ul><h5 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h5><ul><li>特点<ul><li>底层是链表实现，是<code>Set</code>集合中唯一一个能保证存取一致的集合对象</li><li>是<code>HashSet</code>子类，所以保证元素唯一性原理和父类同。</li></ul></li></ul><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><ul><li><p>特点</p><p>TreeSet集合是用来对象元素进行<strong>排序</strong>的,同样他也可以保证元素的唯一</p></li><li><p>原理</p><ul><li><p>自然排序(<code>Comparable</code>)</p><ul><li><code>TreeSet</code>类的<code>add()</code>方法中会把存入的对象提升为<code>Comparable</code>类型</li><li>调用对象的<code>compareTo()</code>方法和集合中的对象比较</li><li>根据<code>compareTo()</code>方法返回的结果进行存储</li></ul><blockquote><p>二叉树结构存储</p><ol><li><p>第一个数据进来<code>compareTo</code>方法返回0</p></li><li><p>之后数据根据<code>compareTo</code>方法结果，小的存左边（负数），大的右边（正数），相等就不存（0）</p></li></ol></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> length = <span class="keyword">this</span>.name.length() - o.name.length();</span><br><span class="line">        <span class="comment">//比较长度为主要条件</span></span><br><span class="line"><span class="keyword">int</span> num = length == <span class="number">0</span> ? <span class="keyword">this</span>.name.compareTo(o.name) : length;</span><br><span class="line">        <span class="comment">//比较内容为次要条件</span></span><br><span class="line"><span class="keyword">return</span> num == <span class="number">0</span> ? <span class="keyword">this</span>.age - o.age : num;</span><br><span class="line">        <span class="comment">//比较年龄为次要条件</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>比较器顺序(<code>Comparator</code>)</p><ul><li>创建<code>TreeSet</code>的时候可以制定 一个<code>Comparator</code><ul><li>TreeSet(Comparator&lt;? super E&gt; comparator)</li></ul></li><li>如果传入了<code>Comparator</code>的子类对象, 那么<code>TreeSet</code>就会按照比较器中的顺序排序</li><li><code>add()</code>方法内部会自动调用<code>Comparator</code>接口中<code>compare()</code>方法排序</li><li>调用的对象是<code>compare</code>方法的第一个参数,集合中的对象是<code>compare</code>方法的第二个参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;String&gt; ts = <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = s1.compareTo(s2);<span class="comment">//比较内容为主要条件</span></span><br><span class="line"><span class="keyword">return</span> num == <span class="number">0</span> ? <span class="number">1</span> : num;<span class="comment">//保留重复</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul><li><code>Map</code>接口概述<ul><li>查看API可以知道：<ul><li>将键映射到值的对象</li><li>一个映射不能包含重复的键</li><li>每个键最多只能映射到一个值</li></ul></li></ul></li><li><p><code>Map</code>接口和<code>Collection</code>接口的不同</p><ul><li><code>Map</code>是<strong>双列</strong>的，<code>Collection</code>是<strong>单列</strong>的(其实也是双列，只不过value是个常量对象)</li><li><code>Map</code>的键唯一，<code>Collection</code>的子体系<code>Set</code>是唯一的</li><li><code>Map</code>集合的数据结构值针对键有效，跟值无关；<code>Collection</code>集合的数据结构是针对元素有效</li></ul></li><li><p>常用API</p><ul><li>添加功能<ul><li><code>V put(K key,V value)</code>:添加元素。<ul><li>如果键是第一次存储，就直接存储元素，返回null</li><li>如果键不是第一次存在，就用值把以前的值替换掉，返回以前的值</li></ul></li></ul></li><li>删除功能<ul><li><code>void clear()</code>:移除所有的键值对元素</li><li><code>V remove(Object key)</code>：根据键删除键值对元素，并把值返回</li></ul></li><li>判断功能<ul><li><code>boolean containsKey(Object key)</code>：判断集合是否包含指定的键</li><li><code>boolean containsValue(Object value)</code>:判断集合是否包含指定的值</li><li><code>boolean isEmpty()</code>：判断集合是否为空</li></ul></li><li>获取功能<ul><li><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>:</li><li><code>V get(Object key)</code>:根据键获取值</li><li><code>Set&lt;K&gt; keySet()</code>:获取集合中所有键的集合</li><li><code>Collection&lt;V&gt; values()</code>:获取集合中所有值的集合</li></ul></li><li>e:长度功能<ul><li><code>int size()</code>：返回集合中的键值对的个数</li></ul></li></ul></li><li><p><code>Map</code>集合的遍历</p><ul><li><p>键找值</p><ul><li>获取所有键的集合</li><li>遍历键的集合，获取到每一个键</li><li>根据键找值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Set&lt;String&gt; keySet = hm.keySet();//获取集合中所有的键</span></span><br><span class="line"><span class="comment">Iterator&lt;String&gt; it = keySet.iterator();//获取迭代器</span></span><br><span class="line"><span class="comment">while(it.hasNext()) &#123;//判断单列集合中是否有元素</span></span><br><span class="line"><span class="comment">String key = it.next();//获取集合中的每一个元素,其实就是双列集合中的键</span></span><br><span class="line"><span class="comment">Integer value = hm.get(key);//根据键获取值</span></span><br><span class="line"><span class="comment">System.out.println(key + "=" + value);//打印键值对</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String key : hm.keySet()) &#123;  <span class="comment">//增强for循环迭代双列集合第一种方式</span></span><br><span class="line">System.out.println(key + <span class="string">"="</span> + hm.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>键值对对象找键和值</p><ul><li>获取所有键值对对象的集合</li><li>遍历键值对对象的集合，获取到每一个键值对对象</li><li>根据键值对对象找键和值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = hm.entrySet();</span><br><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; it = entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">    <span class="comment">//直接用Entry注意import静态内部类</span></span><br><span class="line">Entry&lt;String, Integer&gt; en = it.next();<span class="comment">//获取键值对对象</span></span><br><span class="line">String key = en.getKey();<span class="comment">//根据键值对对象获取键</span></span><br><span class="line">Integer value = en.getValue();<span class="comment">//根据键值对对象获取值</span></span><br><span class="line">System.out.println(key + <span class="string">"="</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Entry&lt;String,Integer&gt; en : hm.entrySet()) &#123;</span><br><span class="line">System.out.println(en.getKey() + <span class="string">"="</span> + en.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ul><li><p>原理</p><p>等同于<code>HashSet</code>，添加自定义类的时候，需要重写自定义类对应<code>hashCode()</code>和<code>equals()</code>方法</p></li><li><p>和<code>HashTable</code>区别</p><ul><li>Hashtable是JDK1.0版本出现的,是线程安全的,效率低,HashMap是JDK1.2版本出现的,是线程不安全的,效率高</li><li>Hashtable不可以存储null键和null值,HashMap可以存储null键和null值</li></ul></li></ul><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><ul><li>保证了存取一致</li></ul><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><ul><li><p>原理</p><p>等同于<code>TreeSet</code>，添加自定义类的时候，需要重写比较方法，两种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> TreeMap&lt;Student,Integer&gt; tm = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> num = o1.name.compareTo(o2.name);<span class="comment">//按照姓名比较</span></span><br><span class="line">         <span class="keyword">return</span> num == <span class="number">0</span> ? Integer.compare(o1.age, o2.age) : num;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br><span class="line">tm.put(<span class="keyword">new</span> Student(<span class="number">24</span>,<span class="string">"lp"</span>),<span class="number">56</span>);</span><br><span class="line">tm.put(<span class="keyword">new</span> Student(<span class="number">20</span>,<span class="string">"lp"</span>),<span class="number">23</span>);</span><br><span class="line">System.out.println(tm);</span><br></pre></td></tr></table></figure></li></ul><h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><ul><li><p>常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;T&gt; <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;?&gt; list,T key)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;T&gt; T <span class="title">max</span><span class="params">(Collection&lt;?&gt; coll)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List&lt;?&gt; list)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List&lt;?&gt; list)</span></span></span><br></pre></td></tr></table></figure></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p><code>Collection</code></p><ul><li><p><code>Lis</code>t(存取有序,有索引,可以重复)</p><ul><li><p><code>ArrayList</code></p><p> 底层是数组实现的,线程不安全,查找和修改快,增和删比较慢</p><ul><li><code>LinkedList</code></li></ul><p>底层是链表实现的,线程不安全,增和删比较快,查找和修改比较慢</p><ul><li><code>Vector</code></li></ul><p>底层是数组实现的,线程安全的,无论增删改查都慢</p></li></ul><blockquote><ol><li><p>如果查找和修改多,用<code>ArrayList</code></p></li><li><p>如果增和删多,用<code>LinkedList</code></p></li><li><p>如果都多,用<code>ArrayList</code></p></li></ol></blockquote><ul><li><p><code>Set</code>(存取无序,无索引,不可以重复)</p><ul><li><p><code>HashSet</code></p><p>底层是哈希算法实现</p><p><code>LinkedHashSet</code></p><ul><li>底层是链表实现,但是也是可以保证元素唯一,和<code>HashSet</code>原理一样</li></ul></li><li><p><code>TreeSet</code></p><p>底层是二叉树算法实现</p></li></ul><blockquote><ol><li>一般在开发的时候不需要对存储的元素排序,所以在开发的时候大多用<code>HashSet</code>，其效率比较高</li><li><code>TreeSet</code>在面试的时候比较多,问你有几种排序方式,和几种排序方式的区别</li></ol></blockquote></li></ul></li><li><p><code>Map</code></p><ul><li><p><code>HashMap</code></p><p>底层是哈希算法,针对键</p><ul><li><p><code>LinkedHashMap</code></p><p>底层是链表,针对键</p></li></ul></li><li><p><code>TreeMap</code></p><p>底层是二叉树算法,针对键</p></li></ul><blockquote><p> 开发中用HashMap比较多</p></blockquote></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合框架 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java学习(2)</title>
      <link href="/2018/10/29/Java%E5%AD%A6%E4%B9%A02/"/>
      <url>/2018/10/29/Java%E5%AD%A6%E4%B9%A02/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p>Object、Scanner、String相关类、Arrays类、包装类、正则表达式、常用类</p></blockquote><p><img src="https://image-link.nos-eastchina1.126.net/java_02"></p><a id="more"></a><h2 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h2><ul><li><p><code>hashCode()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;  <span class="comment">//借助本地系统资源计算hashcode</span></span><br></pre></td></tr></table></figure></li><li><p><code>getClass()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class c = obj.getClass();</span><br><span class="line"><span class="comment">//c这个Class实例对象包含了这个obj实例对象所属类信息</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>toString()</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Object类中实现源码，方法调用前面省略了this</span></span><br><span class="line"><span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode())</span><br></pre></td></tr></table></figure><p>如果直接打印对象的引用，会默认调用<code>toString()</code>方法</p></li><li><p><strong><code>equals(Object obj)</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span> === obj)</span><br></pre></td></tr></table></figure></li></ul><p>所以综上，<strong><code>toString()</code></strong>和<strong><code>equals(Object obj)</code></strong>方法一般子类内都需要重写。</p><h2 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);  <span class="comment">//键盘录入</span></span><br><span class="line"><span class="keyword">if</span>(sc.hashNextInt())&#123;     <span class="comment">//判断键盘是不是int数</span></span><br><span class="line">    <span class="keyword">int</span> i= sc.nextInt();  <span class="comment">//键盘录入整数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意点：当键盘先录取整数再录取字符串会出问题</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i= sc.nextInt();</span><br><span class="line">String line1 = sc.nextLine(); <span class="comment">//键盘录入字符串，遇到\r\n结束，且不录入这2个字符</span></span><br></pre></td></tr></table></figure><p>所以当先录取整数的时候，123\r\n， \r\n会还在缓冲区中，被nextLine()获取成””空串。</p><p>解决办法</p><ul><li>创建两次对象，但浪费空间</li><li>键盘录入都是字符串，都用nextLine()，后字符串转整数</li></ul><h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><p>字面量创建</p><p><code>String str = &quot;abc&quot;</code>;</p><ul><li>字符串字面量”abc”也可以看成是一个字符串对象</li><li>字符串是常量，一旦被赋值，不可更改<ul><li>当str = “def”，此处”abc”在常量池中变成垃圾，并非改变了其值。</li></ul></li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span>[] bytes, <span class="keyword">int</span> index, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span>[] value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span>[] value, <span class="keyword">int</span> index, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span></span>; <span class="comment">//把字符串常量值转成</span></span><br></pre></td></tr></table></figure><h3 id="常见面试"><a href="#常见面试" class="headerlink" title="常见面试"></a>常见面试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>; <span class="comment">//常量池中没这个字符串对象，就创一个，有就直接用</span></span><br><span class="line">String s2 = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//true，引用常量池同一个地址</span></span><br><span class="line">System.out.println(s1.equals(s2));  <span class="comment">//比内容true </span></span><br><span class="line"><span class="comment">//======================================================================</span></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"abc"</span>); <span class="comment">//创建了2个对象，一个在常量池，一个在堆内存（副本）</span></span><br><span class="line">   <span class="comment">//实际s3引用指向堆内存这个对象</span></span><br><span class="line"><span class="comment">//======================================================================</span></span><br><span class="line">String s4 = <span class="string">"a"</span> + <span class="string">"b"</span> + <span class="string">"c"</span>;   <span class="comment">//常量优化机制，实常量池际就是"abc"</span></span><br><span class="line"><span class="comment">//======================================================================</span></span><br><span class="line">String s5 = <span class="string">"ab"</span>;</span><br><span class="line">String s6 = s5 + <span class="string">"c"</span>;   <span class="comment">//此处s5是变量</span></span><br></pre></td></tr></table></figure><blockquote><p>注意点：上面最后一项</p></blockquote><p>​    在Java中<code>+</code>，字符串串联是通过<code>StringBuilder</code>(或<code>StringBuffer</code>)类及其<code>append</code>方法实现。字符串转换通过<code>toString()</code>方法实现。</p><p>​       换言之，底层String和别的数据相加，<strong>先创建</strong>一个<code>StringBuilder</code>对象然后调用<strong><code>append</code></strong>把其他数据添加进来。最后调用<code>toString()</code>转成<code>String</code>对象。</p><h3 id="常见方法API"><a href="#常见方法API" class="headerlink" title="常见方法API"></a>常见方法API</h3><h4 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(object obj)</span></span>; <span class="comment">//区分大小写</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String str)</span></span>; <span class="comment">//忽略大小写</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String str)</span></span>; <span class="comment">//是否包含指定字符串</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String str)</span></span>;<span class="comment">//判断是不是以某指定字符串开头</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String str)</span></span>;<span class="comment">//结尾</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;<span class="comment">//判断字符串是否为空</span></span><br></pre></td></tr></table></figure><blockquote><p> 注意点：””和null的区别</p></blockquote><p><code>&quot;&quot;</code>是字符串常量，同时也是一个<code>String</code>类对象，可以调用其方法</p><p><code>null</code>是空常量，不能调用任何方法，否则会空指针异常</p><h4 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span></span>;</span><br><span class="line"><span class="comment">//lastIndexOf类似</span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>; <span class="comment">//包含头，不包含尾，尾部默认全部end = length()</span></span><br></pre></td></tr></table></figure><h4 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] getBytes();   <span class="comment">//字符串转换为 字节 数组 gbk</span></span><br><span class="line"><span class="keyword">char</span>[] toCharArray(); <span class="comment">//字符串转换为 字符 数组 unicode码表</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span>[] data)</span></span>;<span class="comment">//字符数组转换成字符串,底层是由String构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(Object obj)</span></span>; <span class="comment">//会调用对象的toString()方法</span></span><br><span class="line"><span class="comment">//...任意类型数据（基础、引用）都可以转换</span></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">String <span class="title">concat</span><span class="params">(String str)</span></span>; <span class="comment">//字符串拼接，一般直接用+</span></span><br></pre></td></tr></table></figure><h4 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//替换功能</span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> old, <span class="keyword">char</span> new)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(String old, String new)</span></span>;</span><br><span class="line"><span class="comment">//去除字符串两空格</span></span><br><span class="line"><span class="function">String <span class="title">trim</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//按字典顺序比较两个字符串</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareToIgnoreCase</span><span class="params">(String str)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h2><p><code>String</code>是不可变的字符序列（不可变是指其堆或常量池内容，引用可变）</p><p><code>StringBuffer</code> 是可变的</p><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer();   <span class="comment">//构造一个不带字符的字符串缓冲区，初始容量为16个字符</span></span><br><span class="line">StringBuffer(CharSequence seq);</span><br><span class="line">StringBuffer(<span class="keyword">int</span> capacity);<span class="comment">//不带字符，指定初始容量</span></span><br><span class="line">StringBuffer(String str);<span class="comment">//构造一个字符缓冲区，并将内容初始化为指定字符串内容，16+str长度</span></span><br></pre></td></tr></table></figure><p><code>length()</code>：容器实际字符个数，实际值</p><p><code>capacity()</code>：容器初始容量，理论值</p><h3 id="常用方法API"><a href="#常用方法API" class="headerlink" title="常用方法API"></a>常用方法API</h3><h4 id="添加功能"><a href="#添加功能" class="headerlink" title="添加功能"></a>添加功能</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StringBuffer <span class="title">append</span><span class="params">(String str)</span></span>;<span class="comment">//把任意类型数据添加到缓冲区，并返回缓冲区本身(地址)</span></span><br><span class="line"><span class="comment">//同引用多次调用，影响的是堆上内容，返回的都是同一个地址</span></span><br><span class="line"><span class="function">StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, String str)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="删除功能"><a href="#删除功能" class="headerlink" title="删除功能"></a>删除功能</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StringBuffer <span class="title">deleteCharAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function">StringBuffer <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;<span class="comment">//包含头，不包含尾</span></span><br></pre></td></tr></table></figure><h4 id="替换和反转功能"><a href="#替换和反转功能" class="headerlink" title="替换和反转功能"></a>替换和反转功能</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StringBuffer <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str)</span></span>;</span><br><span class="line"><span class="function">StringBuffer <span class="title">reverse</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="截取功能"><a href="#截取功能" class="headerlink" title="截取功能"></a>截取功能</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="String-相互转换"><a href="#String-相互转换" class="headerlink" title="String 相互转换"></a>String 相互转换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String --&gt; StringBuffer</span><br><span class="line"><span class="comment">//通过构造方法</span></span><br><span class="line"><span class="comment">//通过append()方法</span></span><br><span class="line">StringBuffer --&gt; String</span><br><span class="line"><span class="comment">//通过构造方法</span></span><br><span class="line"><span class="comment">//通过toString()</span></span><br><span class="line"><span class="comment">//通过subString(0,length)</span></span><br></pre></td></tr></table></figure><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>把int数组<code>{1,2,3}</code>转换成字符串<code>[1, 2, 3]</code></p><p>用<code>String</code>相关方法做，或者用<code>StringBuffer</code>做，<strong>用后者更好</strong>，因为前者过程中<strong>堆上</strong>会产生很多垃圾。</p><h3 id="String、StringBuffer、StringBuilder区别"><a href="#String、StringBuffer、StringBuilder区别" class="headerlink" title="String、StringBuffer、StringBuilder区别"></a>String、StringBuffer、StringBuilder区别</h3><ul><li><p>运行速度</p><p><code>StringBuilder</code> &gt; <code>StringBuffer</code> &gt;<code>String</code></p><p>　　<code>String</code>为字符串常量，而<code>StringBuilder</code>和<code>StringBuffer</code>均为字符串变量，即String对象一旦创建之后该对象是<strong>不可更改</strong>的，但后两者的对象是变量，是可以更改的。</p><p>​    正式因为不可改，所以当参数传递的时候，<code>String</code>传递过去等于值传递。</p></li><li><p>线程安全</p><p><code>StringBuilder</code>是线程不安全的，而<code>StringBuffer</code>是线程安全的</p><p><a href="https://www.cnblogs.com/su-feng/p/6659064.html" target="_blank" rel="noopener">参考链接</a></p></li></ul><blockquote><p>总结</p><p>String：适用于<strong>少量</strong>的字符串操作的情况</p><p>StringBuilder：适用于<strong>单线程</strong>下在字符缓冲区进行<strong>大量</strong>操作的情况</p><p>StringBuffer：适用<strong>多线程</strong>下在字符缓冲区进行<strong>大量</strong>操作的情况</p></blockquote><h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><p>冒泡、选择、二分查找（有序），自己写实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] a, intkey)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="变参"><a href="#变参" class="headerlink" title="变参"></a>变参</h3><ul><li><p>格式</p><ul><li><p>修饰符 返回值类型 方法名(数据类型…  变量名){}</p><p><code>public static void print(int ... arr)</code></p></li></ul></li><li><p>注意事项：</p><ul><li>这里的变量其实是一个数组</li><li>如果一个方法有可变参数，并且有多个参数，那么，可变参数肯定是最后一个</li></ul></li></ul><h2 id="基本数据类包装类"><a href="#基本数据类包装类" class="headerlink" title="基本数据类包装类"></a>基本数据类包装类</h2><p>byte    –&gt;    Byte</p><p>short              Short</p><p>int            Integer</p><p>long        Long</p><p>float         Float</p><p>double        Double</p><p>char        Character</p><p>boolean        Boolean</p><h3 id="Integer为例"><a href="#Integer为例" class="headerlink" title="Integer为例"></a>Integer为例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Interger.toBinaryString();</span><br><span class="line">Interger.toOctalString();</span><br><span class="line">Interger.toOHexString();</span><br></pre></td></tr></table></figure><h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer(<span class="keyword">int</span> value);</span><br><span class="line">Integer(String s);</span><br></pre></td></tr></table></figure><h3 id="String-和-int-相互转换"><a href="#String-和-int-相互转换" class="headerlink" title="String 和 int 相互转换"></a>String 和 int 相互转换</h3><ul><li><p><code>int</code> –&gt; <code>Sring</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">法<span class="number">1</span>：和<span class="string">""</span>拼接</span><br><span class="line">法<span class="number">2</span>：<span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">法<span class="number">3</span>：<span class="keyword">int</span> --&gt; Interger --&gt; String(Integer类的toString())</span><br><span class="line">法<span class="number">4</span>：<span class="function"><span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i)</span></span>;(Inter类的静态方法)</span><br></pre></td></tr></table></figure></li><li><p><code>String</code> –&gt; <code>int</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String --&gt; Integer --&gt; <span class="keyword">int</span></span><br><span class="line">   - Integer i = <span class="keyword">new</span> Interger(str)</span><br><span class="line">   - <span class="keyword">int</span> i2 = i.intValue()</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s)</span></span>;</span><br><span class="line"><span class="comment">//基本数据类型包装类，都有parseXxx()转换成基本数据类型</span></span><br><span class="line"><span class="comment">//char不行，需要toCharArray()</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="JDK5特性：自动装箱拆箱"><a href="#JDK5特性：自动装箱拆箱" class="headerlink" title="JDK5特性：自动装箱拆箱"></a>JDK5特性：自动装箱拆箱</h3><p>自动装箱：基本类型转成包装类型   <code>Integer.valueOf</code></p><p>自动拆箱：反之亦然    <code>i.intValue</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">100</span>;  <span class="comment">//隐调用 i = Integer.valueOf(100)</span></span><br><span class="line">i += <span class="number">200</span>;   <span class="comment">//隐调用 Integer.valueOf.(i.intValue() + 200).</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>在使用 Integer x = null 代码会出现空指针异常</p><p>建议先判断是否为null，然后再使用</p></blockquote><h3 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="keyword">new</span> Integer(<span class="number">97</span>);</span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">97</span>);</span><br><span class="line">System.out.println(i1 == i2);  <span class="comment">//false</span></span><br><span class="line">System.out.println(i1.equals(i2));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Integer i3 = <span class="keyword">new</span> Integer(<span class="number">197</span>);</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">197</span>);</span><br><span class="line">System.out.println(i3 == i4);  <span class="comment">//false</span></span><br><span class="line">System.out.println(i3.equals(i4));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Integer i5 = <span class="number">97</span>;  <span class="comment">//自动装箱了</span></span><br><span class="line">Integer i6 = <span class="number">97</span>;</span><br><span class="line">System.out.println(i5 == i6);  <span class="comment">//true</span></span><br><span class="line">System.out.println(i5.equals(i6));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* -128到127是byte取值范围，如果在该范围内，自动装箱就不会创新对象，而是从常量池中获取 </span></span><br><span class="line"><span class="comment">* 如果超过了byte取值范围就会再新创建对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">Integer i7 = <span class="number">197</span>;</span><br><span class="line">Integer i8 = <span class="number">197</span>;</span><br><span class="line">System.out.println(i7 == i8);  <span class="comment">//false</span></span><br><span class="line">System.out.println(i7.equals(i8));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>基于上述最后的分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>在第一次创建`Integer`对象时，自动装箱会用到`IntegerCache`这个内部类，加载该内部类`.class`文件，同时该类内部有`static`代码块，执行后生成`IntegerCache.cache[0-255]`缓存数组并存放于常量池。在jdk1.6后，最大值映射到 `java.lang.Integer.IntegerCache.high`，可以使用 JVM 的启动参数设置最大值。这使我们可以根据应用程序的实际情况灵活地调整来提高性能。</code></pre><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ul><li>描述或匹配一系列符合规则字符串，用来检测注册账号、邮箱，手机号码等。</li><li>调用字符串类方法<code>public boolean matches(String regex)</code></li></ul><h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3><ul><li><p>简单类</p><ul><li>[abc]：   a、b或c （简单类）</li><li>[^abc]：  任何字符，除了a、b或c</li><li>[a-zA-Z] ：a到z 或 A到Z</li><li>[a-d[m-p]]   &lt;=&gt; [a-dm-p]</li><li>[a-z&amp;&amp;[def]]：d、e或、f（交集）</li></ul></li><li><p>预定义字符类</p><ul><li>.      任何字符：</li><li>\d    数字：<code>[0-9]</code>      \表示转义字符，所以需要<code>\\d</code></li><li>\D    非数字：<code>[^0-9]</code></li><li>\s     空白字符：    <code>[\t\n\x0B\f\r]</code></li><li>\S     非空白字符：<code>[^\s]</code></li><li>\w    单词字符：<code>[a-zA-Z_0-9]</code></li><li>\W    非单词字符：<code>[^\w]</code></li></ul></li></ul><h3 id="数量词"><a href="#数量词" class="headerlink" title="数量词"></a>数量词</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X?<span class="comment">//X一次或一次也没有   </span></span><br><span class="line">X*<span class="comment">//零次或多次</span></span><br><span class="line">X+<span class="comment">//一次或多次</span></span><br><span class="line">X&#123;n&#125;<span class="comment">//恰好n次</span></span><br><span class="line">X&#123;n,&#125;<span class="comment">//至少n次</span></span><br><span class="line">X&#123;n,m&#125;<span class="comment">//至少n次，但不超过m次</span></span><br></pre></td></tr></table></figure><h3 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"xyc.你我他.@%$"</span>;   <span class="comment">//xyc..你我他..@%$</span></span><br><span class="line">String[] arr = s.split(<span class="string">"\\."</span>);  </span><br><span class="line"><span class="comment">//arr = ["xyc, "你我他", "@%$"]   结果会有5个,["xyc, "", "你我他", "", "@%$"]</span></span><br></pre></td></tr></table></figure><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p><code>&quot;(.)\\1(.)\\2&quot;</code>        <code>()</code>表示一组，<code>\\1</code>表示第一组又出现1次，<code>\\2</code>表示第二组又出现1次</p><p>练习：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"我....我...我.要...要要...要学......学.编..编编编.编.程.程.程..程"</span>;</span><br><span class="line">String s2 = s.replaceAll(<span class="string">"\\.+"</span>, <span class="string">""</span>);</span><br><span class="line">String s3 = s2.replaceAll(<span class="string">"(.)\\1+"</span>, <span class="string">"$1"</span>); <span class="comment">//$1代表第一组内容</span></span><br></pre></td></tr></table></figure><blockquote><p>注意 </p><p> <code>.?</code>   <code>.*</code>   <code>.+</code>   理解</p></blockquote><h3 id="Pattern-和-Matcher"><a href="#Pattern-和-Matcher" class="headerlink" title="Pattern 和 Matcher"></a>Pattern 和 Matcher</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pattern p = Pattern.compile(<span class="string">"a*b"</span>); <span class="comment">//获取正则表达式</span></span><br><span class="line">Matcher m = p.matcher(<span class="string">"aaaab"</span>);    <span class="comment">//获取匹配器</span></span><br><span class="line"><span class="keyword">boolean</span> b = m.matches();<span class="comment">//看是否能匹配</span></span><br></pre></td></tr></table></figure><p>案例：获取手机号码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"广告词13456473832,广告词18723940579"</span>;</span><br><span class="line">Pattern p = Pattern.compile(<span class="string">"1[3578]\\d&#123;9&#125;"</span>); <span class="comment">//获取正则表达式</span></span><br><span class="line">Matcher m = p.matcher(s);    <span class="comment">//获取匹配器</span></span><br><span class="line"><span class="keyword">while</span>(m.find()) &#123;</span><br><span class="line">    System.out.println(m.group());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><p><code>abs()</code>  <code>ceil()</code>  <code>floor()</code>  <code>round()</code></p><p><code>max()</code>  <code>pow()</code>  <code>random()</code>  <code>sqrt()</code></p><h3 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random(); <span class="comment">//默认系统时间ns值作为种子</span></span><br><span class="line"><span class="keyword">int</span> x = r.nextInt(<span class="number">100</span>);  <span class="comment">//0到100不包括100</span></span><br></pre></td></tr></table></figure><h3 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span></span>; <span class="comment">//运行垃圾回收器  配合重写Object类中finalize()垃圾回收前工作</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>; <span class="comment">//非0状态是异常终止，退出jvm</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">currentTimeMillis</span><span class="params">()</span></span>; <span class="comment">//1970年1月1日到现在ms，可用来计算运行时间</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src, <span class="keyword">int</span> srcPos, Object dest, <span class="keyword">int</span> destPos, <span class="keyword">int</span> length)</span></span>; <span class="comment">//拷贝数组,集合实现底层基础</span></span><br></pre></td></tr></table></figure><h3 id="BigInteger类"><a href="#BigInteger类" class="headerlink" title="BigInteger类"></a>BigInteger类</h3><ul><li><p>概述</p><ul><li>可以让超过Integer范围内的数据进行运算</li></ul></li><li><p>构造方法</p><ul><li><code>public BigInteger(String val)</code></li></ul></li><li><p>成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BigInteger <span class="title">add</span><span class="params">(BigInteger val)</span></span>;</span><br><span class="line"><span class="function">BigInteger <span class="title">subtract</span><span class="params">(BigInteger val)</span></span>;</span><br><span class="line"><span class="function">BigInteger <span class="title">multiply</span><span class="params">(BigInteger val)</span></span>;</span><br><span class="line"><span class="function">BigInteger <span class="title">divide</span><span class="params">(BigInteger val)</span></span>;</span><br><span class="line">BigInteger[] divideAndRemainder(BigInteger val);</span><br></pre></td></tr></table></figure></li></ul><h3 id="BigDecimal类"><a href="#BigDecimal类" class="headerlink" title="BigDecimal类"></a>BigDecimal类</h3><ul><li>概述<ul><li>由于在运算的时候，float类型和double很容易丢失精度，演示案例。<ul><li>2.0 - 1.1  结果是0.8999999……所以需要更精确</li></ul></li><li>不可变的、任意精度的有符号十进制数。</li></ul></li><li><p>构造方法</p><ul><li><code>public BigDecimal(String val)</code>  推荐用字符串，若用<code>double</code>数还会有问题的</li></ul></li><li><p>成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BigDecimal <span class="title">add</span><span class="params">(BigDecimal augend)</span></span>;</span><br><span class="line"><span class="comment">//还有减、乘、除等</span></span><br></pre></td></tr></table></figure></li></ul><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal bd = <span class="keyword">new</span> BigDecimal(<span class="string">"2.0"</span>);</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">BigDecimal bd = BigDecimal.valueOf(<span class="number">2.0</span>);<span class="comment">//底层其实就是调用上面</span></span><br></pre></td></tr></table></figure><h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><ul><li><p>概述</p><p>表示特定瞬间，精确到毫秒</p></li><li><p>构造</p><ul><li><p><code>public Date()</code></p></li><li><p><code>public Date(long date)</code></p></li></ul></li><li><p>成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">long</span> time)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h4><ul><li><p>继承自DateFormat类</p></li><li><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleDateFormat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleDateFormat</span><span class="params">(String pattern)</span></span></span><br></pre></td></tr></table></figure></li><li><p>成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">format</span><span class="params">(Date date)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">parse</span><span class="params">(String source)</span></span></span><br></pre></td></tr></table></figure><p>案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line">SimpleDateFormat sdf = <span class="function">nwe <span class="title">SimpleDateFormat</span><span class="params">(<span class="string">"日期格式"</span>)</span></span>;</span><br><span class="line">sdf.format(d);<span class="comment">//格式化后字符串时间</span></span><br><span class="line"></span><br><span class="line">String str = <span class="string">"2018年10月31日23:54:30"</span>;</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日HH:mm:ss"</span>);</span><br><span class="line">Date d = sdf.parse(str);<span class="comment">//注意处理异常</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><ul><li><p>概述</p><p>​         <code>Calendar</code> 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。</p></li><li><p>成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> field)</span></span></span><br></pre></td></tr></table></figure><p>案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">c.get(Calendar.YEAR);</span><br><span class="line">c.get(Calendar.MONTH);      <span class="comment">//月，从0开始计</span></span><br><span class="line">c.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">c.get(Calendar.DAY_OF_WEEK);<span class="comment">//周日是第一天</span></span><br><span class="line">c.get(Calendar.Year);</span><br></pre></td></tr></table></figure></li><li><p>其他设置方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> field,<span class="keyword">int</span> amount)</span> <span class="comment">//对指定字段进行向前加或后减 (年月日)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> date)</span></span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础语法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java学习(1)</title>
      <link href="/2018/10/28/Java%E5%AD%A6%E4%B9%A01/"/>
      <url>/2018/10/28/Java%E5%AD%A6%E4%B9%A01/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p>本文为学习笔记，内容为己补充之用，非系统性字典。</p></blockquote><p><img src="/2018/10/28/Java学习1/2.jpg" alt=""></p><a id="more"></a><h2 id="Java环境配置"><a href="#Java环境配置" class="headerlink" title="Java环境配置"></a>Java环境配置</h2><ol><li><p>jdk更新，官网下载dmg安装，才能保证在/Libraray/Java/JavaVirturalMachines 中，控制面板更新的不在该路径。</p></li><li><p>设置jdk版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim ~/.bash_profile</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=<span class="string">"/Library/Java/JavaVirturalMachines/版本/Contents/Home"</span></span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure></li><li><p>查看版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/libexec/java_home  -V <span class="comment">#查看当前jdk包，及正在用的jdk</span></span><br><span class="line">java -version   <span class="comment">#jre版本</span></span><br><span class="line">javac -version  <span class="comment">#jdk版本</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="JDK-amp-JRE"><a href="#JDK-amp-JRE" class="headerlink" title="JDK &amp; JRE"></a>JDK &amp; JRE</h2><ul><li><p>JRE ：JVM+类库(Java程序所需的核心类库)，即Java程序<strong>运行</strong>环境。</p></li><li><p>JDK：java的开发工具（javac、jar等）+ JRE，即Java程序<strong>开发</strong>环境</p></li><li>JVM：java实现<strong>跨平台</strong>的最核心的部分。.class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。</li></ul><h2 id="Java语言基础"><a href="#Java语言基础" class="headerlink" title="Java语言基础"></a>Java语言基础</h2><h3 id="变量相加和常量相加区别"><a href="#变量相加和常量相加区别" class="headerlink" title="变量相加和常量相加区别"></a>变量相加和常量相加区别</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1 = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">byte</span> b2 = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">byte</span> b3 = b1 + b2;  <span class="comment">//编译error</span></span><br><span class="line"><span class="comment">//b1和b2是两个变量,变量里面存储的值都是变化的,所以在程序运行中JVM是无法判断里面具体的值</span></span><br><span class="line"><span class="comment">//byte类型的变量在进行运算的时候,会自动类型提升为int类型 ，而int类型数据相加为int类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> b4 = <span class="number">3</span> + <span class="number">4</span>;    <span class="comment">//编译right</span></span><br><span class="line"><span class="comment">//3和4都是常量,java有常量优化机制,就是在编译的的时候直接把3和4的结果赋值给b4了，判断了7在其范围内即可赋值</span></span><br></pre></td></tr></table></figure><h3 id="赋值运算符隐式强制转换"><a href="#赋值运算符隐式强制转换" class="headerlink" title="赋值运算符隐式强制转换"></a>赋值运算符隐式强制转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s=<span class="number">1</span>;s = s+<span class="number">1</span>;<span class="comment">//error</span></span><br><span class="line"><span class="keyword">short</span> s=<span class="number">1</span>;s+=<span class="number">1</span>;  &lt;=&gt;  s = (<span class="keyword">byte</span>)(s + <span class="number">1</span>) <span class="comment">// ++ --同理</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>Java中boolean类型不能通过其他类型隐式或显式转换</strong>(和js有区别)</p><p>&amp;&amp;  || ? :  if() 中表达式必须是严格的关系表达式，即结果必须是true或者false</p></blockquote><h3 id="位异或运算符的特点"><a href="#位异或运算符的特点" class="headerlink" title="位异或运算符的特点"></a>位异或运算符的特点</h3><ul><li>^的特点：一个数据对另一个数据位异或两次，该数本身不变。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">3</span>,b=<span class="number">4</span>;</span><br><span class="line"><span class="comment">//方式1：用位异或实现</span></span><br><span class="line">a = a ^ b;</span><br><span class="line"><span class="comment">// a^b^b=a</span></span><br><span class="line">b = a ^ b;</span><br><span class="line"><span class="comment">// a^b^a=b</span></span><br><span class="line">a = a ^ b;</span><br><span class="line"><span class="comment">// 方式2：一句话搞定</span></span><br><span class="line">b = (a + b) - (a = b);</span><br></pre></td></tr></table></figure><h3 id="switch语法"><a href="#switch语法" class="headerlink" title="switch语法"></a>switch语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)<span class="comment">//byte,short,char,int    枚举(JDK1.5)  String(JDK1.7)</span></span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>：</span><br><span class="line">    <span class="keyword">break</span>；</span><br><span class="line">    <span class="keyword">default</span>：</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ol><li><p>定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;  <span class="comment">//不允许动静结合(动态和静态初始化)[]中不能有数字</span></span><br><span class="line"><span class="keyword">int</span>[] arr2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125; ;</span><br></pre></td></tr></table></figure></li><li><p>二维数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">2</span>][];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[个数];</span><br><span class="line">arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[个数];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] arr = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="面向对象（OOP）"><a href="#面向对象（OOP）" class="headerlink" title="面向对象（OOP）"></a>面向对象（OOP）</h3><p>(Object Oriented Programming)</p><ul><li>特点：抽象、封装、继承、多态</li></ul><h4 id="内存图"><a href="#内存图" class="headerlink" title="内存图"></a>内存图</h4><p>（<a href="https://www.jianshu.com/p/6e2bc593f31c" target="_blank" rel="noopener">https://www.jianshu.com/p/6e2bc593f31c</a>)</p><p><img src="/2018/10/28/Java学习1/1.jpg" alt=""></p><p>对象创建过程步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="number">1</span>.Student.class加载进内存</span><br><span class="line"><span class="number">2</span>.栈内声明一个Student类型引用s</span><br><span class="line"><span class="number">3</span>.在堆内存创建对象,</span><br><span class="line"><span class="number">4</span>.给对象中属性默认初始化值  （基本数据类型为<span class="number">0</span>,<span class="number">0.0</span>,/u0000,<span class="keyword">false</span>，引用数据类型为<span class="keyword">null</span>）</span><br><span class="line"><span class="number">5</span>.属性进行显示初始化</span><br><span class="line"><span class="number">6</span>.构造方法进栈,对对象中的属性赋值,构造方法弹栈</span><br><span class="line"><span class="number">7</span>.将对象的地址值赋值给s</span><br></pre></td></tr></table></figure><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><ul><li>随着类的加载而加载，随着类的消失而消失</li><li>优先于对象存在</li><li>被类的所有对象共享</li></ul><blockquote><p>注意点：</p><ol><li>静态方法中是没有this关键字的，所以静态方法只能访问静态的成员变量和静态的成员方法</li><li>简记：静态只能访问静态</li></ol></blockquote><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><ul><li>代码块概述<ul><li>在Java中，使用{}括起来的代码被称为代码块。</li></ul></li><li>代码块分类<ul><li>根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块(多线程)。</li></ul></li><li>常见代码块的应用<ul><li>局部代码块 <ul><li>在方法中出现；限定变量生命周期，及早释放，提高内存利用率</li></ul></li><li>构造代码块 (初始化块)<ul><li>在类中方法外出现；多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行</li></ul></li><li>静态代码块 <ul><li>在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，并且只执行一次。</li><li>一般用于加载驱动</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Student 静态代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">System.out.println(<span class="string">"Student 构造代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Student 构造方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"Main静态代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"我是main方法"</span>);</span><br><span class="line"></span><br><span class="line">Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">Student s2 = <span class="keyword">new</span> Student();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><blockquote><p>子类只能继承父类所有非私有的成员(成员方法和成员变量)</p><p>子类不能继承父类的构造方法，但是可以通过super去访问父类构造方法。</p></blockquote><ol><li>this 和 super</li></ol><ul><li><p><code>this</code> 和 <code>super</code>都代表什么</p><ul><li><code>this</code>:代表当前对象的引用,谁来调用我,我就代表谁</li><li><code>super</code>:代表当前对象父类的引用</li></ul></li><li><p><code>this</code> 和 <code>super</code>的使用区别</p><ul><li><p>调用成员变量</p><ul><li>this.成员变量 调用本类的成员变量,也可以调用父类的成员变量</li><li>super.成员变量 调用父类的成员变量</li></ul></li><li><p>调用构造方法</p><ul><li><p>this(…)    调用本类的构造方法</p></li><li><p>super(…)    调用父类的构造方法</p><blockquote><p>this()或super()必须放在构造函数第一行</p></blockquote></li></ul></li><li><p>调用成员方法</p><ul><li>this.成员方法 调用本类的成员方法,也可以调用父类的方法</li><li>super.成员方法 调用父类的成员方法</li></ul></li></ul></li></ul><ol start="2"><li>方法重写(覆盖)override</li></ol><ul><li>什么是方法重写<ul><li>重写:子父类出现了一模一样的方法(注意:返回值类型可以是子父类,这个我们学完面向对象讲) </li></ul></li><li><p>方法重写的应用：</p><ul><li>当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法。这样，即沿袭了父类的功能，又定义了子类特有的内容。</li></ul></li><li><p>重写<strong>注意</strong>事项</p><ul><li>子类重写父类方法时，访问权限不能更低<ul><li>最好就一致</li></ul></li><li>父类静态方法，子类也必须通过静态方法进行重写<ul><li>其实这个算不上方法重写，但是现象确实如此，至于为什么算不上方法重写，多态中我会讲解(静态只能覆盖静态)</li></ul></li></ul></li></ul><ol start="3"><li><p><code>final</code></p><ul><li><p>修饰类，类不能被继承</p></li><li><p>修饰变量，变量就变成了常量，只能被赋值一次</p><blockquote><p>基本类型，是值不能被改变         引用类型，是地址值不能被改变,对象中的属性可以改变</p></blockquote></li><li><p>修饰方法，方法不能被重写</p></li></ul></li></ol><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><ol><li><p>前提</p><ul><li>出现继承</li><li>方法重写</li><li>父类引用指向子类对象</li></ul></li><li><p>多态成员访问特点</p><ul><li>成员变量<ul><li>编译看左边（父类），运行看左边（父类）</li></ul></li><li>成员方法<ul><li>编译看左边（父类），运行看右边（子类）</li></ul></li><li>静态方法<ul><li>编译看左边（父类），运行看左边（父类）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        show2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"爱"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"你"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> B();</span><br><span class="line">        a.show();</span><br><span class="line">        </span><br><span class="line">        B b = <span class="keyword">new</span> C();</span><br><span class="line">        b.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><ol><li><p>特点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名 </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> 方法名() &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类或接口</li><li>抽象类不能实例化，可以按照多态子类实例化赋值给抽象类引用</li><li>抽象类子类<ul><li>要么是抽象类</li><li>要么重写抽象类中所有抽象方法</li></ul></li></ul></li><li><p>成员特点</p><ul><li>成员变量：可以变量、常量。abstract不能用来修饰成员变量</li><li>构造方法：存在，用于子类访问父类数据的初始化</li><li>成员方法：可以是抽象、非抽象</li></ul></li><li><font color="red"><code>abstract</code></font>关键字不能与那些共存<ul><li><font color="red"><code>static</code></font>:类型.method()没用意义</li><li><font color="red"><code>final</code></font>：需要让子类去重写</li><li><font color="red"><code>private</code></font>：需要子类可访问并对它重写</li></ul></li></ol><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> 接口名 </span>&#123;    <span class="comment">//接口没有构造方法,所以其成员变量必须初始化</span></span><br><span class="line">    <span class="keyword">int</span> varible = <span class="number">0</span>;     <span class="comment">//默认自带 public static final</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;   <span class="comment">//默认自带 public abstract</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> 接口名 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修饰符小结"><a href="#修饰符小结" class="headerlink" title="修饰符小结"></a>修饰符小结</h4><ul><li><p>修饰符：</p><ul><li>权限修饰符：private , 默认 , protected , public</li><li>状态修饰符：static , final</li><li>抽象修饰符：abstract</li></ul></li><li><p>类：</p><ul><li><p>public , 默认</p></li><li><p>final</p></li><li><p>abstract</p></li></ul></li><li><p>成员变量：</p><ul><li>private , 默认 , protected , public</li><li>static , final</li></ul></li><li><p>构造方法:</p><ul><li>private , 默认 , protected , public</li></ul></li><li><p>成员方法：</p><ul><li>private , 默认 , protected , public</li><li>static , final</li><li>abstract</li></ul></li></ul><h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><ul><li>内部类可以直接访问外部类的成员 via <code>Outer.this</code></li><li>外部类要访问内部类成员，必须创建对象</li></ul><ol><li><p>实名内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">30</span>;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.num);</span><br><span class="line">            System.out.println(Outer.<span class="keyword">this</span>.num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer.Inner oi = <span class="keyword">new</span> Outer().new Inner();<span class="comment">//创建内部类对象</span></span><br><span class="line">        oi.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>静态成员内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Outer.Inner oi = <span class="keyword">new</span> Outer.Inner();</span><br></pre></td></tr></table></figure></li><li><p>局部内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">10</span>;  <span class="comment">//必须为final,如果下面局部内部类要访问的话</span></span><br><span class="line">                                 <span class="comment">//jdk1.8取消了</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                 System.out.println(num); </span><br><span class="line">                <span class="comment">//为什么上面必须为final</span></span><br><span class="line">                <span class="comment">//因为如果是变量，周期随着method结束就没了，而对象可能还未被回收。</span></span><br><span class="line">                <span class="comment">//只有进内存方法区常量池，才能保持生命周期</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner i = <span class="keyword">new</span> Inner();</span><br><span class="line">        i.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>匿名内部类</p><ul><li><p>前提：存在一个类或者接口（可以是抽象类）</p></li><li><p>本质：继承了该类或实现了该接口的子类匿名对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方法1</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> <span class="keyword">implements</span> <span class="title">Inter</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             System.out.println(<span class="string">"num"</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//Inner i = new Inner();</span></span><br><span class="line">        <span class="comment">//i.print();</span></span><br><span class="line">     <span class="comment">//方法2   匿名内部类实现及实例化</span></span><br><span class="line">        <span class="comment">//写法1</span></span><br><span class="line">        <span class="keyword">new</span> Inter() &#123;    <span class="comment">//固定格式，实现Inter接口 或者继承这个类</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//重写抽象方法</span></span><br><span class="line">        &#125;.print();</span><br><span class="line">        <span class="comment">//写法2推荐，</span></span><br><span class="line">        <span class="comment">// 弊端：但该方法无法调用子类特有的方法，因为编译看的左边(父类)无法通过</span></span><br><span class="line">        <span class="comment">// 原因：如果要调用子类，必须向下强转成子类对象引用，然而是匿名，无法强转</span></span><br><span class="line">        Inter i = <span class="keyword">new</span> Inter()&#123;     <span class="comment">//Inter父类对象引用，new出来的是子类对象，多态</span></span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//重写抽象方法</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>工程中应用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">        p.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PersonDemo pd = <span class="keyword">new</span> PersonDemo();</span><br><span class="line">        pd.method(<span class="keyword">new</span> Person()&#123; <span class="comment">//匿名内部类当参数传递，利用了多态，匿名子对象</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">               System.out.println(<span class="string">"匿名内部类方法重写"</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础语法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Welcome</title>
      <link href="/2018/10/12/welcome/"/>
      <url>/2018/10/12/welcome/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p>坚 持 <br>每 周 更 新 一 篇 博 文</p></blockquote><p><img src="https://image-link.nos-eastchina1.126.net/welcome"></p><a id="more"></a>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>CSS — 层叠样式表</title>
      <link href="/2018/06/25/CSS%20%E2%80%94%20%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/"/>
      <url>/2018/06/25/CSS%20%E2%80%94%20%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="常见属性"><a href="#常见属性" class="headerlink" title="常见属性"></a>常见属性</h2><h3 id="文字属性"><a href="#文字属性" class="headerlink" title="文字属性"></a>文字属性</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="comment">/*1.规定文字样式的属性*/</span></span><br><span class="line">    <span class="attribute">font-style</span>:italic  (normal);</span><br><span class="line">    <span class="comment">/*2.规定文字粗细的属性*/</span></span><br><span class="line">    <span class="attribute">font-weight</span>: bold;   <span class="comment">/*单词取值：bold 加粗  bolder更粗  数字取值：100-900之间整百数字*/</span></span><br><span class="line">    <span class="comment">/*3.规定文字大小的属性*/</span></span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="comment">/*4.规定文字字体的属性*/</span></span><br><span class="line">    <span class="attribute">font-family</span>:<span class="string">"微软雅黑"</span>,<span class="string">"备选字体"</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*简写style weight size family*/</span></span><br><span class="line">    <span class="attribute">font</span>:italic bold <span class="number">10px</span> <span class="string">"楷体"</span>; <span class="comment">/*size和family不能省略，且一定要放最后*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>关于字体：</li></ul><blockquote><ol><li><p>如果取值是中文要用引号，且字体必须是用户电脑上已安装的字体。</p></li><li><p>英文不可以处理中文，中文可以处理英文</p><p>  “Times New Roman”,”微软雅黑”可以单独处理英文和中文字体</p></li></ol></blockquote><h3 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="comment">/*1.文本装饰属性*/</span></span><br><span class="line">    text-decoration: underline;(line-through,overline,none去掉超链接下划线)</span><br><span class="line">    <span class="comment">/*2.水平对齐的属性*/</span></span><br><span class="line">    <span class="selector-tag">text-aligh</span>: <span class="selector-tag">center</span> (<span class="selector-tag">right</span>,<span class="selector-tag">left</span>);</span><br><span class="line">    <span class="comment">/*3.缩进的属性*/</span></span><br><span class="line">    <span class="selector-tag">text-indent</span>: 2<span class="selector-tag">em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="颜色属性"><a href="#颜色属性" class="headerlink" title="颜色属性"></a>颜色属性</h3><p>color：</p><ol><li>英文单词：</li><li>rgb</li><li>rgba：rgba(255,0,0,a) a取值为0~1，表示透明度</li><li>十六进制：#FF0000</li><li>十六进制缩写：#F00，每两位都一样可简写</li></ol><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    background-color;</span><br><span class="line">    <span class="selector-tag">background-image</span><span class="selector-pseudo">:url()</span>;</span><br><span class="line">    <span class="selector-tag">background-repeat</span><span class="selector-pseudo">:repeat</span> <span class="comment">/*图片平铺方式*/</span> </span><br><span class="line">          <span class="selector-tag">no-repeat</span></span><br><span class="line">              <span class="selector-tag">repeat-x</span></span><br><span class="line">                    <span class="selector-tag">repeat-y</span>;</span><br><span class="line">    <span class="selector-tag">background-position</span><span class="selector-pseudo">:left</span>    <span class="selector-tag">top</span>;   (<span class="selector-tag">x</span>,<span class="selector-tag">y</span>)不平铺</span><br><span class="line">                        <span class="selector-tag">center</span>  <span class="selector-tag">center</span></span><br><span class="line">                        <span class="selector-tag">right</span>   <span class="selector-tag">bottom</span></span><br><span class="line">                        100<span class="selector-tag">px</span>   200<span class="selector-tag">px</span>  (可为负，则移出，精灵图切图用)</span><br><span class="line">    <span class="selector-tag">background-attachment</span>: <span class="selector-tag">scroll</span> (<span class="selector-tag">fixed</span>);</span><br><span class="line"><span class="comment">/*缩写，任意属性都可以省略*/</span></span><br><span class="line">    <span class="selector-tag">background</span>：背景颜色 图片 平铺 关联 定位</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>背景图片和插入图片的区别</p></blockquote><ul><li>bg不会占用位置，插入会</li><li>背景图片好定位，插入无定位属性，不好控制</li><li>插入图片语义强，要被搜索引擎收录，推荐用插入</li></ul><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><p> p{}</p><h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h3><p>形式:    #id{}，id唯一</p><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><p>  .classname{}</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class="类名1 类名2"&gt;文本&lt;/p&gt;</span><br></pre></td></tr></table></figure><h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><p>标签1 标签2…标签n{}一代代找下去</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>(<span class="selector-tag">id</span>和<span class="selector-tag">calss</span>均可)   <span class="selector-tag">p</span>&#123;&#125;<span class="comment">/*后代不仅仅是儿子，孙子全是*/</span></span><br><span class="line">&lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="子选择器"><a href="#子选择器" class="headerlink" title="子选择器"></a>子选择器</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&gt;<span class="selector-tag">p</span>&#123;&#125;   <span class="comment">/*只找子一代*/</span></span><br><span class="line">&lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h3><p>选择器1选择器2{}</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.para1</span>&#123;&#125;<span class="comment">/*开发用的不多*/</span></span><br><span class="line">&lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;p class="para1"&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h3><p>选择器1，选择器2{}</p><h3 id="兄弟选择器"><a href="#兄弟选择器" class="headerlink" title="兄弟选择器"></a>兄弟选择器</h3><ul><li><p>相邻兄弟选择器CSS2：给指定选择器1后紧跟那个选择器2选中标签（<strong>1</strong>个）设值</p><p>（不能隔开，必须同级相邻上下）</p><p>选择器1+选择器2{}  eg: <code>div+h1{}</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;h1&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure></li><li><p>通用兄弟选择器CSS3</p><p>选择器1~选择器2      无论隔不隔开均可（可多个）</p></li></ul><h3 id="序选择器"><a href="#序选择器" class="headerlink" title="序选择器"></a>序选择器</h3><p>（CSS3）</p><ul><li><p>同级第几个</p><p>p:first-child{}  若第一个标签不是p则无效</p><p>  :last-child{}   :nth-child(n){}  :nth-last-child(n){} </p><p>  :only-child{}  子标签只有一个标签</p><ul><li>:nth-child(odd)奇数</li><li>:nth-child(xn+y)用户自定义</li></ul></li><li><p>同级同类第几个</p><p>p:first-of-type{} 只要同级下面仍有p仍有效</p></li></ul><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><p>p[class]  p[id]  input[type=password]</p><ul><li><p>属性的取值以什么开头</p><p>[attribute|=value] css2 有局限value字符必须-隔开</p><p>[attribute^=value] css3</p></li><li><p>属性的取值以什么结尾</p><p>[attribute$=value] css3</p></li><li><p>属性取值是否包含某个特定的值</p><p>[attribute~=value] css2</p><p>[attribute*=value] css3</p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[class = box]</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class="box"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h3><p>*{} 一般不用，测试时可用于全局初始化。</p><h2 id="CSS三大特性"><a href="#CSS三大特性" class="headerlink" title="CSS三大特性"></a>CSS三大特性</h2><h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><ul><li>只有以color/font-/text-/line开头的属性才可以继承</li><li>所有后代均可继承</li><li>特殊性<ul><li><a>文字颜色和下划线不能继承</a></li><li>h标签文字大小无法继承</li></ul></li></ul><p>body{}</p><h3 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h3><p>CSS处理冲突，多个选择器选中同个标签，又设置了相同属性。</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><ul><li><p>是否直接选中（间接选中指代继承）</p><p> 间接选中，就近原则。</p></li><li><p>是否是相同选择器</p><p>都是直接选中，都是同类型选择器，谁写在后面就执行谁的</p></li><li><p>是否不同选择器</p><p>如果是直接选中，并且是不同类型</p><p>id&gt;类&gt;标签&gt;通配符&gt;继承&gt;浏览器默认</p></li></ul><blockquote><p>Important 只能用于直接选中，不能用于间接选中，提至最高</p></blockquote><p><code>*{color:red !important;}</code></p><blockquote><p>优先级权重（直接选中时才计算）</p></blockquote><p><strong>权重：</strong>多个后代选择器时，id个数多最高，类名数目次之，标签数目…若还是同，谁写在后面听谁</p><h2 id="CSS显示模式"><a href="#CSS显示模式" class="headerlink" title="CSS显示模式"></a>CSS显示模式</h2><h3 id="div和span标签"><a href="#div和span标签" class="headerlink" title="div和span标签"></a>div和span标签</h3><ol><li>div一般用于配合CSS完成网页基本布局</li><li>span用于配合CSS修改网页中一些局部信息</li><li>div和span区别？<ul><li>div会单独占一行，span为行内</li><li>div是容器级标签，而span是文本级<ul><li>容器级中可以嵌套所有其他标签</li><li>文本级中只能嵌套文字/超链接/图片</li></ul></li></ul></li></ol><h3 id="显示模式"><a href="#显示模式" class="headerlink" title="显示模式"></a>显示模式</h3><p>CSS中将标签分两类，块级和行内元素</p><p>区别：</p><ul><li><p>块级</p><ul><li>独占一行</li><li>if 没设置width，那么默认和父元素一样宽</li><li>if 设置了height，那么就按照设置来显示，默认为<strong>0px</strong>，会被内容撑起来，(浮动不可以)</li><li>要想使其在父级元素中水平居中，只能用<code>margin:0 auto;</code></li></ul></li><li><p>行内</p><ul><li>不会独占一行</li><li>如果没有设置宽度，那么默认和内容一样宽</li><li>行内元素不能设置width和height</li><li>父级  <code>text-align:center;</code>可使其水平居中  </li></ul></li><li><p>行内块级元素</p><p>不独占一行也能设置width和height： <img></p></li></ul><h3 id="显示模式转换"><a href="#显示模式转换" class="headerlink" title="显示模式转换"></a>显示模式转换</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    display: inline; (行内)</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">span</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: block；（块级）(inline-block 行内块级)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><ul><li><p>边框属性</p><ul><li><p>连写（同时设置四条边的边框）</p><p>border: 边框的宽度  样式  颜色;</p></li><li><p>连写（分别设置四条边的边框）</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">border-top</span>:<span class="number">1px</span> solid red;</span><br><span class="line">border-right;</span><br><span class="line"><span class="selector-tag">border-bottom</span>;</span><br><span class="line"><span class="selector-tag">border-left</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border-width</span>:上 右 下 左;</span><br><span class="line">    <span class="attribute">border-style</span>:上 右 下 左;</span><br><span class="line">    <span class="attribute">border-color</span>:上 右 下 左;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    上 右 下  =&gt;   左=右</span></span><br><span class="line"><span class="comment">    上 右    =&gt;   左=右  下=上</span></span><br><span class="line"><span class="comment">    上      =&gt;   右下左 = 上</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>注意点：</p></blockquote><ol><li>连写中颜色可以省略，默认为黑</li><li>样式不能省略，省略后看不到边框</li><li>宽度可以省略</li></ol></li></ul><h3 id="内边距"><a href="#内边距" class="headerlink" title="内边距"></a>内边距</h3><p>边框和内容之间的间距</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">padding-top</span>:;</span><br><span class="line">    <span class="attribute">padding-right</span>:;</span><br><span class="line">    <span class="attribute">padding-bottom</span>:;</span><br><span class="line">    <span class="attribute">padding-left</span>:;    <span class="comment">/*会影响标签本身的大小*/</span></span><br><span class="line">    <span class="attribute">padding</span>:;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  1.增加了padding后元素的宽高也会发生变化</span></span><br><span class="line"><span class="comment">  2.如果增加了padding后仍想保持元素即盒子（不包括margin)的宽高，那就必须减去内容的宽高</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h3><p>标签与标签之间的间距</p><p>margin-top (right bottom left)</p><p><strong>*</strong>    外边距在水平方向不会出现合并现象即（正常叠加），只有<strong>垂直方向</strong>会有合并的现象。谁大听谁的。</p><blockquote><ul><li>内容大小:         content</li><li>元素大小:         content、padding、boder</li><li>元素空间大小  content、padding、boder、margin</li></ul></blockquote><h3 id="box-sizing属性"><a href="#box-sizing属性" class="headerlink" title="box-sizing属性"></a>box-sizing属性</h3><ol><li>css3中新增的属性，该属性可以保证盒子新增padding和border后，盒子元素的高度和宽度不变</li><li>通过改变内容宽高来实现整体元素不变的</li><li>box-sizing：<ul><li>content-box    元素的宽高 = 边框 + 内边距 +内容宽高</li><li>border-box      width/height的宽高, 修改padding和border，元素大小不变</li></ul></li></ol><blockquote><p>注意点</p><ul><li>如果两个盒子是嵌套关系，那么设置了里面一个盒子的margin-top，外面一个盒子也会被顶下来</li><li>如果外面盒子不想被顶下来，那么可以给外面的盒子添加一个边框属性</li><li>企业开发中，一般如果需要控制嵌套父子盒子之间的距离，首先考虑用padding，margin本质用于控制兄弟之间的间隙</li></ul></blockquote><p><code>margin:0 auto</code>：只对水平方向居中有效，对垂直无效。让盒子水平居中。</p><p>​                盒子中内容居中要使用<code>text-align</code></p><h3 id="行高和盒子高度"><a href="#行高和盒子高度" class="headerlink" title="行高和盒子高度"></a>行高和盒子高度</h3><p>line-height设置行高，当line-height = height（内容的高度），保证一行文字在盒子中垂直居中。多行垂直居中只能靠padding</p><h3 id="居中小结"><a href="#居中小结" class="headerlink" title="居中小结"></a>居中小结</h3><p>水平方向：盒子居中   <code>margin:0 auto</code></p><p>​                   内容居中   <code>text-align:center</code>   包括文本，图像，以及行内、行内块级元素</p><p>垂直方向：单行文字居中   <code>line-height: 外面大盒子内容高度</code></p><p>​                    盒子、多行文字居中，靠padding设置</p><h2 id="网页布局"><a href="#网页布局" class="headerlink" title="网页布局"></a>网页布局</h2><p>盒模型：IE盒子模型（舍弃）和W3C盒子模型</p><p>​        标准 W3C 盒子模型的范围包括 margin,border,padding,content,并且 content 部分不包含其他部分。</p><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><h4 id="布局方式"><a href="#布局方式" class="headerlink" title="布局方式"></a>布局方式</h4><ul><li><p>标准流（文档流/普通流）</p><ul><li>浏览器默认排版方式</li><li>在CSS中元素分为3类：块级/行内/行内块级</li><li>标准流垂直、水平排版</li></ul></li><li><p>浮动流</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box1</span>&#123;</span><br><span class="line">    float:left ;(right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>浮动流是一种“半脱离标准流”排版方式 </p></li><li><p>只能水平排版，只能设置某个元素在父元素下左对齐或右对齐</p><ul><li><p>注意点 </p><p>无居中对齐，且<code>margin: 0  auto</code>无法设置水平居中</p></li></ul></li></ul><blockquote><p>特点</p></blockquote><ol><li>浮动流不区分块级/行内/行内块级，均可水平排版</li><li>所有元素均可设置宽高</li><li>综上所述，类似标准流的行内块级</li></ol></li><li><p>定位流</p></li></ul><h4 id="浮动元素脱标"><a href="#浮动元素脱标" class="headerlink" title="浮动元素脱标"></a>浮动元素脱标</h4><p>脱标：脱离标准流</p><p>当某一个元素浮动之后，那么这个元素看上去就像被从标准流中删除一样。</p><p>影响：</p><p>若前一个元素浮动了，而后一个元素没有浮动，那么此时前一个元素就会盖住后一个元素</p><h4 id="浮动排序规则"><a href="#浮动排序规则" class="headerlink" title="浮动排序规则"></a>浮动排序规则</h4><ol><li>相同方向上的浮动元素，先浮动会显示在前，后浮在后</li><li>不同方向上浮动元素，左浮找左浮，右浮找右浮</li><li>浮动元素浮动之后的位置，由浮动元素浮动之前在标准流中的位置来确定</li></ol><h4 id="浮动贴靠现象"><a href="#浮动贴靠现象" class="headerlink" title="浮动贴靠现象"></a>浮动贴靠现象</h4><p>当父元素的width足够放下所有浮动元素时，会并列显示一行；</p><p>但当后面的浮动元素放不下一行的时候，就会往前一个元素贴靠，直到贴到父元素的最左（右）边，这时，无论放不放的下，都会贴靠。</p><h4 id="浮动字围现象"><a href="#浮动字围现象" class="headerlink" title="浮动字围现象"></a>浮动字围现象</h4><p>内容文本级标签会给浮动元素让出位置。浮动元素不会盖住内容。</p><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><h4 id="浮动高度问题"><a href="#浮动高度问题" class="headerlink" title="浮动高度问题"></a>浮动高度问题</h4><ol><li>在标准流中内容高度可以撑起父元素盒子高度</li><li>浮动中不可以</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">p&#123;</span><br><span class="line"> float:left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>文本1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>文本2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>文本3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>文本4<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>文本5<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>文本6<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">文本123456会显示在同一行</span><br></pre></td></tr></table></figure><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>方法1：给父元素设置盒子高度（一般不用）</p><p>方法2：clear属性 （一般也不用，因为设置不了margin）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    clear:none;     left right both inherit</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*常用both，当前元素浮动（或者非浮动元素）另起一行，不追随前面一个浮动元素*/</span></span><br></pre></td></tr></table></figure><blockquote><p>注意点</p><p>当你给某个元素添加了clear属性后，那么这个属性的margin就会失效</p></blockquote><p>方法3：</p><ul><li><p>外墙法</p><p>在两个盒子中间添加一个 div 块级元素，给这个标签添加clear属性</p><p>此时，可以给下面的盒子设置margin-top，但是不能给第一个盒子设置margin-bottom。</p></li><li><p>内墙法</p><p>在第一个盒子中最后面，添加div块级元素，给它加clear，此时，即可以给第一个加margin-bottom，也可以给第2个加margin-top。</p></li></ul><blockquote><p> 外墙法和内墙法区别：</p><p>内墙法能撑起第一个盒子的高度，而外墙法不行。</p><p>且这2种方法都要额外加div，无语义，阅读差，所以不常用。</p></blockquote><p>方法4：</p><p>伪元素选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div::before&#123;           &lt;after&gt;</span><br><span class="line">    <span class="selector-tag">content</span><span class="selector-pseudo">:""</span>;</span><br><span class="line">    <span class="selector-tag">visibility</span><span class="selector-pseudo">:hidden</span>;  <span class="comment">/*可以隐藏伪元素*/</span></span><br><span class="line">    <span class="selector-tag">display</span><span class="selector-pseudo">:block</span>;</span><br><span class="line">    <span class="selector-tag">clear</span><span class="selector-pseudo">:both</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 注意</p><p>伪元素选择器为了兼容IE6，需要在父级样式中添加<code>*zoom:1</code></p></blockquote><p>方法5：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">overflow</span>:hidden;&#125;  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.可清除超出容器的文本内容</span></span><br><span class="line"><span class="comment">2.可清除浮动</span></span><br><span class="line"><span class="comment">3.如果2个盒子是嵌套关系，可以让里面的盒子设置margin-top，外面的盒子不会被顶下来，而不用设置boader属性</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="定位流"><a href="#定位流" class="headerlink" title="定位流"></a>定位流</h3><h4 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h4><p>相对于自己以前在标准流中的位置来移动，不影响其他元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    top:;        [bottom]</span><br><span class="line">    <span class="selector-tag">right</span>:;      <span class="selector-attr">[left]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意点</p><ul><li>相对定位是不脱离标准流，继续在标准流中占用空间</li><li>在相对定位中同一个方向上的定位属性只能使用一个。 left right只能选其一 top bottom也是</li><li>相对定位中区别块级/行内/行内块级 </li><li>当设置其margin/padding属性，会影响其标准流布局。*故而，先在标准流中确定布局，在考虑其相对流的位置</li></ul></blockquote><p>使用场景：</p><ul><li>用于对元素进行微调</li><li>配合后面学习绝对定位来使用</li></ul><h4 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h4><p>绝对定位就是相对于body来定位</p><blockquote><p>注意点1：</p><ul><li>绝对定位的元素是脱离标准流的</li><li>不区分块级/元素/行内块级，   和浮动很像，抽离出来，单独定位</li></ul></blockquote><p>绝对定位-参考点：</p><pre><code> 1. 默认下所有的绝对定位元素，无论有无祖先元素，都会以body作为参考点    2. 如果一个绝对定位的元素有祖先元素，并且祖先元素也是定位流，那么这个绝对定位的元素就会以定位流的祖先元素作为参考点 - 只要是这个绝对定位元素的祖先元素均可 - 定位流指   绝对/相对/固定 定位 - 只有 静态定位 不行3. 如果一个绝对定位的元素有祖先元素，并且祖先元素也是定位流，而且祖先元素中有多个元素都是定位流，那么这个绝对定位的元素以离它最近的那个定位流祖先元素为参考点。   简言：就近原则 </code></pre><blockquote><p>注意点2：</p><ul><li>如果一个绝对定位的元素是以body作为参考点，其实以网页首屏的宽高作为参考点，而不是以整个网页的宽高作为参考点。 </li><li>一个绝对定位的元素会忽略祖先元素的padding</li></ul></blockquote><p>子绝父相</p><p>​     企业中不单独用绝对定位，因为以body参考有Bug；也不单独用相对定位。</p><p>​    而是采用子元素用绝对定位，父元素用相对定位。</p><p>绝对定位水平居中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">300px</span>;  <span class="comment">/*若为100%宽度始终为浏览器宽度*/</span></span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -元素宽度的一半 -<span class="number">150px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h4><ol><li><p>脱离标准流，不占用标准流空间。</p></li><li><p>行内块级</p><p>固定定位类似背景的关联方式，背景定位可以让bg图片不随滚动条滚动而滚动</p></li></ol><p>而固定定位可让某个盒子不随着滚动条滚动而滚动。</p><h4 id="静态定位"><a href="#静态定位" class="headerlink" title="静态定位"></a>静态定位</h4><p>默认就是静态定位</p><h4 id="定位流z-index"><a href="#定位流z-index" class="headerlink" title="定位流z-index"></a>定位流z-index</h4><p>默认情况下，所有的元素都有一个默认的z-index属性，取值为0。</p><p>z-index的作用是专门用于控制定位流元素的覆盖关系</p><ol><li>默认，定位流的元素会盖住标准流的元素</li><li>默认，定位流的元素后面编写会盖住前面编写的</li><li>如果设置了z-index，谁的z-index大，谁就显示在上面。</li></ol><blockquote><p>注意点</p><p>从父现象</p><ul><li>若父元素都没设置z-index，则直接比较子元素的z-index</li><li>若父元素设置了，则子元素的z-index就会失效，听从父元素z-index比较大小</li></ul></blockquote><h2 id="过渡模块"><a href="#过渡模块" class="headerlink" title="过渡模块"></a>过渡模块</h2><h3 id="a标签伪类选择器"><a href="#a标签伪类选择器" class="headerlink" title="a标签伪类选择器"></a>a标签伪类选择器</h3><p>a标签4种状态</p><ul><li>从未被访问      a:link</li><li>被访问过          a:visited</li><li>鼠标悬停          a:hover</li><li>鼠标长按          a:active</li></ul><blockquote><p>顺序不能错</p></blockquote><p>过渡要素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:red;</span><br><span class="line">    <span class="attribute">transition-property</span>: width,background-color;</span><br><span class="line">    <span class="attribute">transition-duration</span>: <span class="number">5s</span>,<span class="number">5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="过渡模块属性"><a href="#过渡模块属性" class="headerlink" title="过渡模块属性"></a>过渡模块属性</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">transition-property</span>:;</span><br><span class="line">    <span class="attribute">transition-duration</span>:;</span><br><span class="line">    tansition-timing-function:linear;   &lt;ease,ease-in,ease-out,ease-in-out&gt;</span><br><span class="line">    <span class="selector-tag">tansition-delay</span>:;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>transition</code>连写：</p><blockquote><p>注意点</p><ul><li>可以分开定义，用<code>,</code>隔开</li><li>连写时可以省略后面2个参数，因为前2者已能满足过渡要素</li><li>如果所用属性运动速度/延迟时间/持续时间都一样，可简写为<code>tansition:all 0s;</code></li></ul></blockquote><p>eg:弹性效果   手风琴效果</p><h2 id="2D转换模块"><a href="#2D转换模块" class="headerlink" title="2D转换模块"></a>2D转换模块</h2><h3 id="2D形变属性"><a href="#2D形变属性" class="headerlink" title="2D形变属性"></a>2D形变属性</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    transform:rotate(45deg);  /*旋转,默认为Z轴*/ rotateX  rotateY  rotateZ</span><br><span class="line">    <span class="selector-tag">transform</span><span class="selector-pseudo">:translate(</span>水平<span class="selector-tag">px</span>,垂直<span class="selector-tag">px</span>); <span class="comment">/*平移*/</span></span><br><span class="line">    <span class="selector-tag">transform</span><span class="selector-pseudo">:scale(1.5</span>,1);   <span class="comment">/*水平缩放倍数，垂直缩放倍数*/</span></span><br><span class="line">    <span class="selector-tag">transform</span><span class="selector-pseudo">:rotate(45deg)</span>  <span class="selector-tag">translate</span>(水平<span class="selector-tag">px</span>,垂直<span class="selector-tag">px</span>);  <span class="comment">/*综合，属性按照先后顺序，会修改坐标系*/</span></span><br><span class="line">    <span class="selector-tag">transform-origin</span><span class="selector-pseudo">:center(50</span>%) <span class="selector-tag">center</span>(50%); <span class="comment">/*形变中心点，默认为自身中心*/</span>  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">perspective</span><span class="selector-pseudo">:100px</span>;   <span class="comment">/*透视属性，近大远小*/</span> 必须添加到父元素上</span><br></pre></td></tr></table></figure><h3 id="盒子和文字阴影"><a href="#盒子和文字阴影" class="headerlink" title="盒子和文字阴影"></a>盒子和文字阴影</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="built_in">h-shadow</span>(水平偏移)  px可为负</span><br><span class="line">         v-shadow </span><br><span class="line">         <span class="built_in">blur</span>(模糊度)    px</span><br><span class="line">        <span class="built_in">spread</span>(阴影扩展,原本的阴影四周扩展)     px</span><br><span class="line">        color <span class="comment">/*默认颜色由盒子内容颜色决定*/</span></span><br><span class="line">        <span class="built_in">inset</span>(内外阴影，默认为外);</span><br><span class="line">&#125;</span><br><span class="line">文字偏移没有  内外阴影和阴影扩展</span><br></pre></td></tr></table></figure><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    display:none; /*不显示*/ 无法配合动画</span><br><span class="line">    <span class="selector-tag">opacity</span><span class="selector-pseudo">:0</span>~1; <span class="comment">/*透明度*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动画模块"><a href="#动画模块" class="headerlink" title="动画模块"></a>动画模块</h2><p>过渡和动画的异同</p><ul><li>不同：过渡必须人为，动画不需要</li><li>相同：<ul><li>都是给元素添加动画</li><li>都需要满足三要素</li></ul></li></ul><h3 id="动画三要素"><a href="#动画三要素" class="headerlink" title="动画三要素"></a>动画三要素</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="comment">/*1.需要执行的动画*/</span></span><br><span class="line">    <span class="attribute">animation-name</span>:lp;</span><br><span class="line">    <span class="comment">/*动画持续时长*/</span></span><br><span class="line">    <span class="attribute">animation-duration</span>:<span class="number">3s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*需要创建一个名称为lp的动画*/</span></span><br><span class="line">@<span class="keyword">keyframes</span> lp&#123;</span><br><span class="line">    <span class="selector-tag">from</span>&#123;</span><br><span class="line">        <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">to</span>&#123;</span><br><span class="line">        <span class="attribute">margin</span>:<span class="number">0</span> auto;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动画其他属性"><a href="#动画其他属性" class="headerlink" title="动画其他属性"></a>动画其他属性</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="comment">/*动画延迟多久开始执行*/</span></span><br><span class="line">    <span class="attribute">animation-delay</span>:<span class="number">2s</span>;</span><br><span class="line">    <span class="comment">/*动画执行过程速度曲线*/</span></span><br><span class="line">    <span class="attribute">animation-timing-function</span>:linear;</span><br><span class="line">    <span class="comment">/*动画需要执行几次*/</span></span><br><span class="line">    <span class="attribute">animation-iteration-count</span>:<span class="number">3</span>;</span><br><span class="line">    <span class="comment">/*是否需要执行往返动画*/</span></span><br><span class="line">    <span class="attribute">animation-direction</span>:alternate;</span><br><span class="line">                取值：  normal 默认，执行完一次后回到启动继续执行下一次</span><br><span class="line">                  <span class="selector-tag">alternate</span> 往返动画</span><br><span class="line">    <span class="selector-tag">animation-play-state</span><span class="selector-pseudo">:running</span>; </span><br><span class="line">    取值：  <span class="selector-tag">running</span> 默认</span><br><span class="line">       <span class="selector-tag">paused</span> 暂停动画</span><br><span class="line">    <span class="selector-tag">animation-fill-mode</span>：<span class="selector-tag">none</span></span><br><span class="line">    取值：  <span class="selector-tag">none</span> 默认，不做任何改变</span><br><span class="line">       <span class="selector-tag">forwards</span> 让元素结束状态保持最后一帧样式</span><br><span class="line">       <span class="selector-tag">backwards</span> 让元素等待状态时显示动画第一帧的样式即0%</span><br><span class="line">       <span class="selector-tag">both</span> 上面2个叠加</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> lp&#123;</span><br><span class="line">   <span class="comment">/*时间片变化*/</span></span><br><span class="line">    0%&#123;     </span><br><span class="line">        <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    25%&#123;</span><br><span class="line">        <span class="attribute">margin</span>:<span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3D转换模块"><a href="#3D转换模块" class="headerlink" title="3D转换模块"></a>3D转换模块</h2><p>默认，所有元素都是2D呈现，如何让元素呈3D？</p><p>和透视一样，想看到某个元素的3D效果，只需要给其<strong>父</strong>元素添加一个<code>transform-style</code>属性，设置其值为<code>preserve-3d</code>。</p><h2 id="背景相关"><a href="#背景相关" class="headerlink" title="背景相关"></a>背景相关</h2><h3 id="背景尺寸"><a href="#背景尺寸" class="headerlink" title="背景尺寸"></a>背景尺寸</h3><p>背景尺寸属性是css3中新增属性，专门用来设置背景图片大小</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">"img/logo.png"</span>) no-repeat;</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">150px</span> <span class="number">100px</span>;  <span class="comment">/*宽度  高度*/</span></span><br><span class="line">                     30% 50%;      /*盒宽百分比  高*/</span><br><span class="line">                     <span class="selector-tag">auto</span> 100<span class="selector-tag">px</span>;   <span class="comment">/*宽度等比拉伸  高度*/</span></span><br><span class="line">                     100<span class="selector-tag">px</span> <span class="selector-tag">auto</span>;   <span class="comment">/*宽度  高度等比拉伸*/</span></span><br><span class="line">                     <span class="selector-tag">cover</span>;    <span class="comment">/*等比拉伸覆盖整个盒子，不留空*/</span></span><br><span class="line">                     <span class="selector-tag">contain</span>;    <span class="comment">/*等比拉伸覆盖整个盒子，一旦宽或高遇到盒子边缘就停止，会留空*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="comment">/*背景图片起始位置*/</span></span><br><span class="line">    background-origin:padding-box;  默认</span><br><span class="line">      <span class="selector-tag">border-box</span>;</span><br><span class="line">      <span class="selector-tag">content-box</span>;</span><br><span class="line">    <span class="comment">/*背景绘制区域属性，指定从哪个区域开始绘制背景*/</span></span><br><span class="line">    <span class="selector-tag">background-clip</span><span class="selector-pseudo">:border-box</span> 默认</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多重背景图片"><a href="#多重背景图片" class="headerlink" title="多重背景图片"></a>多重背景图片</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">"img/1.png"</span>) no-repeat left top,</span><br><span class="line">       <span class="built_in">url</span>(<span class="string">"img/2.png"</span>) no-repeat right top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多张用<code>,</code>隔开，先添加的会盖住后添加</p><p>最好分开写</p><h2 id="CSS书写格式"><a href="#CSS书写格式" class="headerlink" title="CSS书写格式"></a>CSS书写格式</h2><p>外链样式和导入样式区别：</p><ul><li><p>外链 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>导入</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">".css"</span>;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul><p>@import是CSS2.1推出，有兼容性问题</p><p>外链显示，会先加载CSS，再加载结构。而导入会先加载结构，可能体验会不好。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git 操作小结</title>
      <link href="/2018/06/24/git%E6%93%8D%E4%BD%9C%E5%B0%8F%E7%BB%93/"/>
      <url>/2018/06/24/git%E6%93%8D%E4%BD%9C%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="git提交代码"><a href="#git提交代码" class="headerlink" title="git提交代码"></a>git提交代码</h2><ol><li>可以先pull的情况</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#该方法适合远端代码和你当前的(包括未add或者已add未commit)进行比较</span></span><br><span class="line">git pull  <span class="comment">#若无冲突，可直接merge</span></span><br><span class="line">git commit -a -m <span class="string">"message"</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><ol start="2"><li>无法先pull（即存在冲突）方案一：推荐</li></ol><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git stash <span class="comment">#把当前的所有修改暂存下来，此时status会恢复到最初干净的状态</span></span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line">git stash pop <span class="comment">#把暂存区的修改恢复出来，并且冲突的地方会标记出来，待手动修改</span></span><br><span class="line">git stash apply stash@&#123;0&#125; <span class="comment">#上面这样恢复若无冲突和自动删除stash记录，而这个不会</span></span><br><span class="line"></span><br><span class="line">git commit -a -m <span class="string">"message"</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>附加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git stash list <span class="comment">#查看暂存的内容列表(包含在哪条分支上的暂存)</span></span><br><span class="line"><span class="comment">#如果使用git stash pop 不加名，则恢复最近一条记录，哪怕是mybranch上的内容也会被恢复到master。(若无冲突，会吧list中记录删除，若冲突则需冲动删除)</span></span><br><span class="line">git stash clear <span class="comment">#清空所有内容</span></span><br><span class="line">git stash drop stash@&#123;0&#125;<span class="comment">#删除第一个队列，不加默认删除编号为0</span></span><br></pre></td></tr></table></figure><ol start="3"><li>无法先pull（即存在冲突）方案二（缺点：需要提交2次，有时并不想提交）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m <span class="string">"messgae1"</span></span><br><span class="line">git pull <span class="comment">#此时冲突处会标记出来，手动解决冲突</span></span><br><span class="line">git commit -a -m <span class="string">"messgae2"</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h2 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --all <span class="comment">#查看所有分支情况，包括本地和远端</span></span><br></pre></td></tr></table></figure><p>无论在主分支，或者其他分支上修改了东西，但是未commit，切换分支时，会<strong>仍然存在</strong>。</p><p>因此，在切换分支的时候，最好commit再切换，或者git stash下来。</p><h3 id="分支新建与合并"><a href="#分支新建与合并" class="headerlink" title="分支新建与合并"></a>分支新建与合并</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.新建分支并切换到该分支上</span></span><br><span class="line">git checkout -b 分支名 </span><br><span class="line"><span class="comment">#等价于下面两条命令</span></span><br><span class="line">git branch 分支名</span><br><span class="line">git checkout 分支名</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.合并</span></span><br><span class="line">git checkout master</span><br><span class="line">git merge 分支名 <span class="comment">#fast-forward 无需解决冲突</span></span><br><span class="line">                <span class="comment">#如果当前master和分支的起点不是同个点，可能会有矛盾需解决</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.删除无用的分支</span></span><br><span class="line">git branch -d 分支名 <span class="comment">#(-D 强制删除，-d无法删除未merge的分支)</span></span><br></pre></td></tr></table></figure><h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><ol><li>分支由本地新建并推送给远程</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git push</span><br><span class="line">git pull <span class="comment">#可缺省后面的仓库名 &lt;远程库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;  </span></span><br><span class="line">                        <span class="comment"># git push是  &lt;本地分支&gt;:&lt;远程分支&gt;  </span></span><br><span class="line"></span><br><span class="line">git checkout mybranch1</span><br><span class="line">git push origin mybranch1</span><br><span class="line">git pull origin mybranch1  <span class="comment">#后面仓库名、分支名不可缺省</span></span><br></pre></td></tr></table></figure><blockquote><p>git pull和push后面有些可以省略，需要<strong>配置</strong>push.default默认行为</p><p>*<strong>建议</strong>分支操作的时候，每次pull和push加上仓库名<origin> &lt;分支名&gt;(本地和远程分支名相同)</origin></p></blockquote><ol start="2"><li>分支由远程新建好本地跟踪</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -t(--track) origin/mybranch1 <span class="comment">#克隆远端分支并创建到本地，名与远端同</span></span><br></pre></td></tr></table></figure><p><strong>合并分支与前面相同，git merge</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge mybranch1</span><br><span class="line">git push &lt;origin&gt; &lt;master&gt;</span><br></pre></td></tr></table></figure><p>最后删除无用的分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除远程分支</span></span><br><span class="line">git push origin --delete(-d) mybranch1</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除本地分支</span></span><br><span class="line">git branch -d mybranch1 <span class="comment">#-D强制删除</span></span><br></pre></td></tr></table></figure><h3 id="删除远程分支后本地未同步"><a href="#删除远程分支后本地未同步" class="headerlink" title="删除远程分支后本地未同步"></a>删除远程分支后本地未同步</h3><ul><li>方法1</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch -p 命令</span><br><span class="line"><span class="comment">#命令行解释--prune -p  删除不存在的远程跟踪分支</span></span><br></pre></td></tr></table></figure><ul><li>方法2</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote show origin <span class="comment">#查看远程分支，还有本地分支与之相对应关系等信息。</span></span><br><span class="line">git remote prune origin <span class="comment">#可以删除远程已经不存在的分支</span></span><br></pre></td></tr></table></figure><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
